# 八、安装rockylinux

原因：centos停止维护，这个centos替代品，开始安装



## 1. 准备工作

安装完vm软件，准备好centos映射文件

1. 下载并安装VMware

![](/operations/simulate/vmware/system/001.png)

2. 安装方式

[进入官网](https://rockylinux.org/zh-CN)


![](/operations/simulate/vmware/system/159.png)

## 2. vm 设置

1. 安装方式

自定义安装=>设置完配置=>加载光盘安装

2. 安装类型选择rockylinux

![](/operations/simulate/vmware/system/160.png)

3. 配置项

![](/operations/simulate/vmware/system/161.png)


## 3. 启动选项

1. 选择安装第一个

![](/operations/simulate/vmware/system/163.png)

2. 语言选择：中文简体，点击继续

![](/operations/simulate/vmware/system/162.png)

3. 调整带有感叹号的

![](/operations/simulate/vmware/system/164.png)

4. 安装空间：自动安装就可以

![](/operations/simulate/vmware/system/165.png)

5. root密码：不要选择锁定账号，并且要允许ssh登录。

![](/operations/simulate/vmware/system/166.png)

6. 新建用户

![](/operations/simulate/vmware/system/167.png)

7. 需要的是服务器，不需要桌面

![](/operations/simulate/vmware/system/168.png)

![](/operations/simulate/vmware/system/169.png)

8. 等待安装

![](/operations/simulate/vmware/system/170.png)

## 4. 系统配置

1. 调整IP

Rocky Linux 9 使用 `/etc/NetworkManager/system-connections/` 目录下的 `.nmconnection` 文件来存储网络配置。

- 以下是编辑网络配置文件的步骤：

    - 进入网络配置目录：

        ```sh
        cd /etc/NetworkManager/system-connections/
        ```

        ![](/operations/simulate/vmware/system/171.png)

    - 编辑配置文件：

        ```sh
        sudo vim <接口名>.nmconnection  # 例如 ens160.nmconnection
        ```

        ![](/operations/simulate/vmware/system/172.png)

    - 找到 `[ipv4]` 部分，修改为以下内容：

        ```ini
        [ipv4]
        method=manual ## 在IPV4下面修改如下内容
        address1=192.168.0.5/24,192.168.0.1 ## 修改IP，子网掩码（24是子网掩码的24位，对应255.255.255.0）， 网关
        dns=119.29.29.29;114.114.114.114 ## 设置DNS服务
        may-fail=false
        ```

         ![](/operations/simulate/vmware/system/173.png)
     
   - 重新加载配置文件

        ```sh
        nmcli connection reload ens160.nmconnection
        ```
    
    - 激活配置文件
        
        ```sh
        nmcli connection up ens160
        ```
    - 验证结果

        ```sh
        ip addr
        ```
        
        ![](/operations/simulate/vmware/system/174.png)


## 5. 使用rockyLinux做克隆机器

1. 主机配置

    ![](/operations/simulate/vmware/system/185.png)

    > 这里都使用最小配置，后续使用可以进行扩容

2. 安装要求

    - 用户：root用户（root密码设置简单，且运行ssh连接）
    - 软件选择：服务器（如果是linu基础，网络与yum都需要自己配置）
    - 磁盘需要选择下

    ![](/operations/simulate/vmware/system/186.png)


3. 更新dnf与yum

```shell
# 更新yum
sudo yum update
# 或者更新dnf
sudo dnf update
```


4. 创建-清理脚本（原机使用）

    1. 脚本内容

        ```sh
        # 克隆清理脚本
        sudo cat > /usr/local/bin/prepare-for-clone.sh << 'EOF'
        #!/bin/bash
        # Rocky Linux 克隆准备脚本

        echo "=== 准备系统进行克隆 ==="

        # 1. 停止网络服务
        systemctl stop NetworkManager

        # 2. 清理网络配置
        rm -f /etc/udev/rules.d/70-persistent-net.rules
        rm -f /etc/udev/rules.d/80-net-name-slot.rules
        rm -f /etc/sysconfig/network-scripts/ifcfg-*
        rm -f /var/lib/NetworkManager/*
        rm -f /var/lib/dhclient/*

        # 3. 清理机器ID
        rm -f /etc/machine-id
        rm -f /var/lib/dbus/machine-id
        dbus-uuidgen --ensure=/etc/machine-id

        # 4. 清理 SSH 主机密钥
        rm -f /etc/ssh/ssh_host_*

        # 5. 清理日志
        journalctl --rotate
        journalctl --vacuum-time=1s

        # 6. 清理临时文件
        rm -rf /tmp/*
        rm -rf /var/tmp/*

        # 7. 清理 YUM/DNF 缓存
        dnf clean all

        # 8. 创建首次启动标记
        rm -f /var/firstboot-done

        # 9. 清理 Bash 历史
        rm -f /root/.bash_history
        rm -f /home/*/.bash_history

        # 10. 关闭系统
        echo "系统已准备好进行克隆。"
        echo "请在克隆后执行以下操作："
        echo "1. 启动系统"
        echo "2. 系统将自动配置网络（使用脚本中的默认IP或修改脚本）"
        echo "3. 根据需要修改 /usr/local/bin/firstboot-network.sh 中的网络配置"
        ```

    2. 使用实例

        ```sh
        # 创建文件夹
        sudo mkdir -p /usr/local/bin/

        # 1. 保存脚本
        vi /usr/local/bin/prepare-for-clone.sh

        # 2. 给予执行权限
        chmod +x /usr/local/bin/prepare-for-clone.sh

        # 3. 运行脚本
        sudo /usr/local/bin/prepare-for-clone.sh
        ```

5. 创建-启动配置脚本（克隆机使用）

    1. 脚本内容

        ```sh
        #!/bin/bash

        # 等待网络服务启动
        sleep 10

        # 获取第一个非 lo 的网络接口
        INTERFACE=$(ip link show | grep -E '^[0-9]+:' | grep -v lo | grep -v '^[0-9]*: docker' | head -n 1 | awk -F: '{print $2}' | xargs)

        if [ -z "$INTERFACE" ]; then
            INTERFACE="ens160"
        fi

        # 用户配置变量（可以在克隆前修改）
        IP_ADDRESS="192.168.18.100"
        NETMASK="24"
        GATEWAY="192.168.1.1"
        DNS_SERVER="8.8.8.8;8.8.4.4"

        # 生成新的 UUID
        NEW_UUID=$(uuidgen)

        # 删除原有网络配置
        rm -f /etc/NetworkManager/system-connections/*.nmconnection

        # 创建新的网络配置
        cat > /etc/NetworkManager/system-connections/${INTERFACE}.nmconnection << CONFIG
        [connection]
        id=${INTERFACE}
        uuid=${NEW_UUID}
        type=ethernet
        interface-name=${INTERFACE}
        autoconnect=true

        [ethernet]

        [ipv4]
        address1=${IP_ADDRESS}/${NETMASK},${GATEWAY}
        dns=${DNS_SERVER};
        method=manual

        [ipv6]
        addr-gen-mode=stable-privacy
        method=disabled
        CONFIG

        # 设置权限
        chmod 600 /etc/NetworkManager/system-connections/${INTERFACE}.nmconnection
        chown root:root /etc/NetworkManager/system-connections/${INTERFACE}.nmconnection

        # 重启 NetworkManager
        systemctl restart NetworkManager

        # 激活连接
        nmcli connection up ${INTERFACE}

        # 标记已执行
        touch /var/firstboot-done
        ```

    2. 使用实例

        ```shell
        # 1. 保存脚本
        vi /usr/local/bin/firstboot-network.sh

        # 2. 给予执行权限
        chmod +x /usr/local/bin/firstboot-network.sh

        # 3. 运行脚本 (启动前一定要修改静态IP)
        sudo /usr/local/bin/firstboot-network.sh
        ```

6. 创建-自动扩容脚本（VMware改变磁盘大小后，这里直接修改）


    1. 脚本内容

        ```sh
        #!/bin/bash
        # extend-rocky9-lvm-simple.sh
        # Rocky Linux 9 自动扩展磁盘脚本（精简版）

        set -e  # 遇到错误立即退出

        echo "=== Rocky Linux 9 磁盘扩展脚本（精简版） ==="
        echo ""

        # 获取LVM物理卷分区
        get_lvm_partition() {
            # 检查NVMe磁盘
            for disk in /dev/nvme*n*p*; do
                [ -b "$disk" ] || continue
                if sudo blkid -o value -s TYPE "$disk" 2>/dev/null | grep -q "LVM2_member"; then
                    echo "$disk"
                    return 0
                fi
            done
            
            # 检查SATA/SCSI磁盘
            for disk in /dev/sd*[0-9]; do
                [ -b "$disk" ] || continue
                if sudo blkid -o value -s TYPE "$disk" 2>/dev/null | grep -q "LVM2_member"; then
                    echo "$disk"
                    return 0
                fi
            done
            
            echo "未找到LVM物理卷分区"
            return 1
        }

        # 检查当前状态
        check_status() {
            echo "=== 当前系统状态 ==="
            
            echo -e "\n磁盘信息:"
            echo "设备    大小    类型    挂载点"
            echo "-----------------------------------"
            lsblk -o NAME,SIZE,TYPE,MOUNTPOINT
            
            echo -e "\n文件系统使用情况:"
            df -hT --type=xfs --type=ext4 --type=ext3
            
            LVM_PARTITION=$(get_lvm_partition)
            if [ -n "$LVM_PARTITION" ] && [ "$LVM_PARTITION" != "未找到LVM物理卷分区" ]; then
                echo -e "\n找到LVM物理卷分区: $LVM_PARTITION"
                
                # 提取磁盘和分区号
                if [[ $LVM_PARTITION =~ /dev/(nvme[0-9]+n[0-9]+)p([0-9]+) ]]; then
                    DISK_NAME="/dev/${BASH_REMATCH[1]}"
                    PART_NUM="${BASH_REMATCH[2]}"
                elif [[ $LVM_PARTITION =~ /dev/([a-z]+)([0-9]+) ]]; then
                    DISK_NAME="/dev/${BASH_REMATCH[1]}"
                    PART_NUM="${BASH_REMATCH[2]}"
                fi
                
                echo "磁盘: $DISK_NAME, 分区号: $PART_NUM"
            fi
            
            # LVM 信息
            if command -v pvs &> /dev/null; then
                echo -e "\nLVM 信息:"
                echo "物理卷(PV):"
                pvs --noheadings -o pv_name,pv_size,pv_free 2>/dev/null || echo "  LVM未激活"
                
                echo -e "\n卷组(VG):"
                vgs --noheadings -o vg_name,vg_size,vg_free 2>/dev/null || echo "  LVM未激活"
                
                echo -e "\n逻辑卷(LV):"
                lvs --noheadings -o lv_path,lv_size 2>/dev/null || echo "  LVM未激活"
            fi
        }

        # 安装必要工具
        install_tools() {
            echo "检查并安装必要工具..."
            
            # 检查growpart工具
            if ! command -v growpart &> /dev/null; then
                echo "安装cloud-utils-growpart..."
                if command -v dnf &> /dev/null; then
                    dnf install -y cloud-utils-growpart
                elif command -v yum &> /dev/null; then
                    yum install -y cloud-utils-growpart
                elif command -v apt &> /dev/null; then
                    apt update && apt install -y cloud-guest-utils
                else
                    echo "无法安装growpart，不支持的包管理器"
                    return 1
                fi
            fi
            
            echo "工具检查完成"
            return 0
        }

        # 扩展分区
        extend_partition() {
            echo -e "\n=== 扩展分区 ==="
            
            # 获取LVM物理卷分区
            LVM_PARTITION=$(get_lvm_partition)
            if [ -z "$LVM_PARTITION" ] || [ "$LVM_PARTITION" = "未找到LVM物理卷分区" ]; then
                echo "未找到LVM物理卷分区"
                return 1
            fi
            
            # 提取磁盘和分区号
            if [[ $LVM_PARTITION =~ /dev/(nvme[0-9]+n[0-9]+)p([0-9]+) ]]; then
                DISK_NAME="/dev/${BASH_REMATCH[1]}"
                PART_NUM="${BASH_REMATCH[2]}"
            elif [[ $LVM_PARTITION =~ /dev/([a-z]+)([0-9]+) ]]; then
                DISK_NAME="/dev/${BASH_REMATCH[1]}"
                PART_NUM="${BASH_REMATCH[2]}"
            else
                echo "无法解析分区信息: $LVM_PARTITION"
                return 1
            fi
            
            echo "磁盘: $DISK_NAME"
            echo "分区号: $PART_NUM"
            echo "LVM分区: $LVM_PARTITION"
            
            # 安装growpart工具
            install_tools
            
            # 扩展分区
            echo "执行: growpart $DISK_NAME $PART_NUM"
            if growpart "$DISK_NAME" "$PART_NUM"; then
                echo "分区扩展成功"
            else
                echo "分区扩展失败"
                return 1
            fi
            
            # 重新读取分区表
            echo "重新读取分区表..."
            partprobe "$DISK_NAME"
            udevadm settle
            sleep 2
            
            return 0
        }

        # 扩展物理卷
        extend_pv() {
            echo -e "\n=== 扩展物理卷 ==="
            
            # 找到物理卷
            PV_DEVICE=$(get_lvm_partition)
            if [ -z "$PV_DEVICE" ] || [ "$PV_DEVICE" = "未找到LVM物理卷分区" ]; then
                echo "未找到物理卷"
                return 1
            fi
            
            echo "找到物理卷: $PV_DEVICE"
            
            # 扩展物理卷
            echo "执行: pvresize $PV_DEVICE"
            if pvresize "$PV_DEVICE"; then
                echo "物理卷扩展成功"
            else
                echo "物理卷扩展失败"
                return 1
            fi
            
            NEW_PV_SIZE=$(pvs --noheadings -o pv_size "$PV_DEVICE" 2>/dev/null | xargs || echo "未知")
            echo "物理卷扩展完成，新大小: $NEW_PV_SIZE"
            
            return 0
        }

        # 扩展逻辑卷
        extend_lv() {
            echo -e "\n=== 扩展逻辑卷 ==="
            
            # 找到根逻辑卷
            ROOT_LV=$(df / | tail -1 | awk '{print $1}')
            if [ -z "$ROOT_LV" ]; then
                echo "未找到根逻辑卷"
                return 1
            fi
            
            echo "找到根逻辑卷: $ROOT_LV"
            
            # 获取卷组名称
            VG_NAME=$(lvs --noheadings -o vg_name "$ROOT_LV" 2>/dev/null | xargs)
            if [ -z "$VG_NAME" ]; then
                echo "无法获取卷组名称"
                return 1
            fi
            
            # 获取可用空间
            FREE_SPACE=$(vgs --noheadings -o vg_free "$VG_NAME" 2>/dev/null | xargs || echo "0")
            
            echo "卷组: $VG_NAME"
            echo "可用空间: $FREE_SPACE"
            
            if [ "$FREE_SPACE" = "0" ] || [ -z "$FREE_SPACE" ]; then
                echo "没有可用空间可以扩展"
                return 0
            fi
            
            # 扩展逻辑卷
            echo "执行: lvextend -l +100%FREE $ROOT_LV"
            if lvextend -l +100%FREE "$ROOT_LV"; then
                echo "逻辑卷扩展成功"
            else
                echo "逻辑卷扩展失败"
                return 1
            fi
            
            NEW_LV_SIZE=$(lvs --noheadings -o lv_size "$ROOT_LV" 2>/dev/null | xargs || echo "未知")
            echo "逻辑卷扩展完成，新大小: $NEW_LV_SIZE"
            
            return 0
        }

        # 扩展文件系统
        extend_fs() {
            echo -e "\n=== 扩展文件系统 ==="
            
            # 获取根文件系统设备
            ROOT_DEVICE=$(df / | tail -1 | awk '{print $1}')
            MOUNT_POINT="/"
            
            # 获取文件系统类型
            FS_TYPE=$(df -T "$MOUNT_POINT" | tail -1 | awk '{print $2}')
            if [ -z "$FS_TYPE" ]; then
                echo "无法获取文件系统类型"
                return 1
            fi
            
            echo "根设备: $ROOT_DEVICE"
            echo "挂载点: $MOUNT_POINT"
            echo "文件系统类型: $FS_TYPE"
            
            # 根据文件系统类型扩展
            case $FS_TYPE in
                xfs)
                    echo "执行: xfs_growfs $MOUNT_POINT"
                    if xfs_growfs "$MOUNT_POINT"; then
                        echo "xfs文件系统扩展成功"
                    else
                        echo "xfs文件系统扩展失败"
                        return 1
                    fi
                    ;;
                ext4|ext3)
                    echo "执行: resize2fs $ROOT_DEVICE"
                    if resize2fs "$ROOT_DEVICE"; then
                        echo "ext文件系统扩展成功"
                    else
                        echo "ext文件系统扩展失败"
                        return 1
                    fi
                    ;;
                btrfs)
                    echo "执行: btrfs filesystem resize max $MOUNT_POINT"
                    if btrfs filesystem resize max "$MOUNT_POINT"; then
                        echo "btrfs文件系统扩展成功"
                    else
                        echo "btrfs文件系统扩展失败"
                        return 1
                    fi
                    ;;
                *)
                    echo "不支持的文件系统类型: $FS_TYPE"
                    return 1
                    ;;
            esac
            
            echo "文件系统扩展完成"
            return 0
        }

        # 验证结果
        verify_result() {
            echo -e "\n=== 验证扩展结果 ==="
            
            echo -e "\n扩展后的磁盘空间:"
            df -h /
            
            echo -e "\n扩展后的LVM状态:"
            if command -v vgs &> /dev/null; then
                vgs --noheadings -o vg_name,vg_size,vg_free
            fi
            
            if command -v lvs &> /dev/null; then
                lvs --noheadings -o lv_path,lv_size
            fi
            
            echo -e "\n最终磁盘布局:"
            lsblk -o NAME,SIZE,FSTYPE,TYPE,MOUNTPOINT
            
            echo "磁盘扩展完成！"
        }

        # 主函数
        main() {
            echo "脚本开始时间: $(date)"
            
            # 检查是否以root运行
            if [ "$EUID" -ne 0 ]; then
                echo "请使用sudo运行此脚本"
                exit 1
            fi
            
            # 检查当前状态
            check_status
            
            # 确认继续
            echo -e "\n注意：此操作将在磁盘上执行以下步骤："
            echo "1. 扩展LVM物理卷分区"
            echo "2. 扩展物理卷(PV)"
            echo "3. 扩展逻辑卷(LV)"
            echo "4. 扩展文件系统"
            echo ""
            
            read -p "是否继续扩展磁盘？(y/N): " confirm
            if [[ ! $confirm =~ ^[Yy]$ ]]; then
                echo "操作取消"
                exit 0
            fi
            
            echo "开始扩展磁盘..."
            
            # 步骤1: 扩展分区
            if ! extend_partition; then
                echo "分区扩展失败，停止执行"
                exit 1
            fi
            
            # 步骤2: 扩展物理卷
            if ! extend_pv; then
                echo "物理卷扩展失败，停止执行"
                exit 1
            fi
            
            # 步骤3: 扩展逻辑卷
            if ! extend_lv; then
                echo "逻辑卷扩展失败，停止执行"
                exit 1
            fi
            
            # 步骤4: 扩展文件系统
            if ! extend_fs; then
                echo "文件系统扩展失败，停止执行"
                exit 1
            fi
            
            # 验证结果
            verify_result
            
            echo "所有操作完成！建议重启系统验证。"
            echo "重启命令: reboot"
            echo "脚本结束时间: $(date)"
        }

        # 运行主函数
        main "$@"
        ```

    2. 使用实例

        ```sh
        # 1. 保存脚本
        vi extend-rocky9-lvm-simple.sh

        # 2. 给予执行权限
        chmod +x extend-rocky9-lvm-simple.sh

        # 3. 运行脚本
        sudo ./extend-rocky9-lvm-simple.sh
        ```

7. 防火墙设置

    ```sh
    # 关闭防火墙
    systemctl stop firewalld
    # 停止开机自启
    systemctl disable firewalld
    # 检查防火墙是否运行
    systemctl status firewalld
    ```

8. 重启

    ```sh
    reboot
    ```