# 三、jenkins高级

## 3.1 容器化构建

### 3.1.1 容器化构建的几种方式

1. 外挂目录（数据卷方式）

	这种方式将应用数据（如配置文件、日志）保存在容器之外的主机目录，适合需要持久化数据或动态配置的场景。

	核心步骤：

	-   准备应用：确保应用 JAR 包就位。
	-   编写 Dockerfile：使用 VOLUME 指令指定容器内的挂载点。
	-   构建镜像：执行 docker build 命令。
	-   运行镜像：运行容器时使用 -v 参数将主机目录挂载到容器中。

2. JAR 包直接打包到镜像里

    这种方式将应用及其依赖全部封装进镜像，实现了应用环境的自包含和标准化，非常适合持续集成/持续部署（CI/CD）流程。

    核心步骤：

    - 准备应用：准备好最终的 JAR 包。
    - 编写 Dockerfile：使用 COPY 或 ADD 指令将 JAR 包复制到镜像内。
    - 构建镜像：执行 docker build 命令。
    - 运行镜像：直接运行容器，无需额外挂载。

3. 生成新镜像并推送到 Docker 私服

    1. 第一步：生成新镜像
        - 输入：Dockerfile + 应用 JAR 包/源代码
        - 工具：Docker 引擎
        - 过程：
            - 开发者编写 Dockerfile 定义镜像内容
            - Docker 根据 Dockerfile 构建新的应用镜像
            - 生成一个包含应用运行环境的完整镜像
        - 输出：一个新的 Docker 镜像（包含应用和所有依赖）
    2. 第二步：推送至私有仓库（Harbor）
        - 动作：镜像推送
        - 工具：Docker 客户端 + Harbor 私有仓库
        - 过程：
            - 将本地构建的镜像打上私有仓库的标签
            - 通过 docker push 命令将镜像推送至 Harbor
            - Harbor 存储并管理镜像版本
        - 输出：镜像存储在私有仓库，可供其他环境访问
    3. 第三步：Kubernetes 集群部署
        - 角色：Kubernetes 节点
        - 过程：
            - Kubernetes 集群通过配置文件或命令从 Harbor 拉取镜像
            - 集群中的每个节点（Node）使用自身的 Docker 引擎拉取镜像
            - 创建并运行包含该镜像的 Pod
        - 输出：应用在 Kubernetes 集群中运行
    4. 第四步：应用运行
        - 载体：Docker 容器
        - 位置：Kubernetes Pod 内
        - 状态：应用以容器化方式在集群中运行，提供服务

### 3.1.2 使用外部jar包完成docker镜像

1. 准备一台测试服务器 docker 环境
2. 准备支持 JDK 的镜像 [openjdk的docker地址](https://hub.docker.com/_/openjdk)
3. 把jar包打包到容器中（dockerfile）

	- 新增文件

		```
		vim Dockerfile
		```
	- 文件内容

		```shell
		# openJDK 已经已经被官方废弃
		FROM eclipse-temurin:17
		EXPOSE 8080
		WORKDIR /root
		ADD jarfile/java-demo*.jar /root/app.jar
		ENTRYPOINT ["java", "-jar", "/root/app.jar"]
		```
4. 打包镜像

	```sh
	# 使用 Dockerfile 构建一个叫做demo的镜像
	docker build -t demo .
	# 查看镜像
	docker ps
	```

5. 运行镜像

	```sh
	docker run -d -p 8888:8080 demo
	```

	![](/other/install/jenkins/106.png)

### 3.1.3 使用外挂目录形式去运行

1. 使用外挂目录去运行

	```sh
	# 启动命令
	docker run -d -p 8080:8080 --name demo-out -v /root/jarfile/java-demo-0.0.1.jar:/app.jar eclipse-temurin:17 java -jar app.jar
	# 检查docker容器
	docker ps
	```
2. 新增docker服务器连接

	![](/other/install/jenkins/107.png)

3. docker 前置清理

	- 前置清理
		
		![](/other/install/jenkins/108.png)

	- 启动docker
		
		![](/other/install/jenkins/109.png)

4. 运行结果

	![](/other/install/jenkins/110.png)


### 3.1.4 自动化构建Docker镜像运行jar

1. 在 idea 中新建 dockerfile 文件

	![](/other/install/jenkins/111.png)

2. 合并代码后

	![](/other/install/jenkins/112.png)

3. 项目操作配置

	- 前置清理

		![](/other/install/jenkins/113.png)
	- 构建后操作

		![](/other/install/jenkins/114.png)

		![](/other/install/jenkins/115.png)

4. 运行结果

	![](/other/install/jenkins/116.png)


## 3.2 Jenkins集群/并发构建

集群化构建可以有效提升构建效率，尤其是团队项目比较多或是子项目比较多的时候，可以并发在多台机器上执行构建。

1. 克隆jenkins主机

	Jenkins-Server02: 192.168.18.85
	Jenkins-Server03: 192.168.18.86

	![](/other/install/jenkins/117.png)

2. 节点管理

	- 进入节点管理

		![](/other/install/jenkins/118.png)
	- 选择创建节点

		![](/other/install/jenkins/119.png)
	- 创建节点名称

		![](/other/install/jenkins/120.png)
	- 节点配置（配置两个）

		![](/other/install/jenkins/121.png)

		![](/other/install/jenkins/122.png)
	- 配置信息

		![](/other/install/jenkins/123.png)
	- 在状态里-复制内容信息

		![](/other/install/jenkins/124.png)
	- 服务器中执行

		![](/other/install/jenkins/125.png)
	- 节点加载完成

		![](/other/install/jenkins/126.png)
3. 从节点启动命令改为开机自启

	- 新建脚本

		```sh
		# 新建脚本
		sudo vim agent-start.sh
		# 修改脚本权限
		sudo chmod 755 agent-start.sh
		```
	- 脚本文件

		```sh
		#!/bin/bash
		# 清理日志
		> /root/agent.log

		# 设置工作目录
		cd /root

		# 直接运行 Java 进程（不要用 nohup 和 &）
		exec java -jar agent.jar \
			-url http://192.168.18.82:8080/ \
			-secret e0f21e3d1398b2851cc37a143a5c9f1e548e02d3a94135bb7e03d4a242b550e2 \
			-name "jenkins-02" \
			-webSocket \
			-workDir "/root" \
			> agent.log 2>&1
			
		```
	- 加入开机自启

		```sh
		# 创建启动文件
		sudo vim /etc/systemd/system/jenkins-agent.service
		# 重新加载systemd配置
		sudo systemctl daemon-reload
		# 设置开机自启并启动服务与检查状态
		sudo systemctl start jenkins-agent
		sudo systemctl status jenkins-agent
		sudo systemctl enable jenkins-agent
		```

		```ini
		[Unit]
		Description=Jenkins-Agent Server
		After=network.target

		[Service]
		Type=simple
		User=root
		ExecStart=/root/agent-start.sh
		Restart=always
		RestartSec=10

		[Install]
		WantedBy=multi-user.target
		```
	- 遇到 SELinux 问题

		```sh
		sudo setenforce 0
		sudo chcon -t bin_t /root/agent-start.sh
		sudo setenforce 1
		sudo systemctl restart jenkins-agent.service
		```

4. 修改项目配置并多次构建

	- 进入项目中	

		![](/other/install/jenkins/127.png)
	- 选择 `必要时进行并发`

		![](/other/install/jenkins/128.png)
	- 多次构建

		![](/other/install/jenkins/129.png)
	- 构建结果

		![](/other/install/jenkins/130.png)

5. 一些状态的介绍

	- 从节点配置中的-构建任务量
		
		![](/other/install/jenkins/131.png)
	- 项目配置-限制节点的任务形式

		![](/other/install/jenkins/132.png)

## 3.3 流水线 pipeline 

流水线既能作为任务的本身，也能作为Jenkinsfile

使用流水线可以让我们的任务从ui手动操作，转换为代码化，像docker的dockerfile一样，从shel命令到配置文件，更适合大型项目，可以让团队其他开发者同时参与进来，同时也可以编辑开发Jenkinswebu不能完成的更复杂的构建逻辑，作为开发者可读性也更好。

### 3.3.1 语法

1. 5个必备的组成部分

	1. pipeline

		* **描述**：整条流水线
			
		* **作用**：定义整个流水线流程的顶层块
			
		* **位置**：Pipeline 脚本的起始标签
			

	2. agent

		* **描述**：指定执行器
			
		* **作用**：定义流水线在哪个 Jenkins 节点（Agent）上执行
			
		* **示例**：`agent any`（在任何可用节点运行）
			

	3. stages

		* **描述**：所有阶段
			
		* **作用**：包含一个或多个 `stage`的容器块
			
		* **位置**：`pipeline`块内的主要组成部分
			

	4. stage

		* **描述**：某一阶段，可以有多个
			
		* **作用**：定义流水线中的一个具体阶段（如构建、测试、部署）
			
		* **示例**：`stage('Build')`、`stage('Test')`
			

	5. steps

		* **描述**：阶段内的每一步，可执行命令
			
		* **作用**：在 `stage`块内定义具体的执行步骤
			
		* **示例**：`sh 'mvn clean package'`、`echo 'Hello'`
2. post 流水线完成后可执行的任务

	- always 无论流水线或者阶段的完成状态。
	- changed 只有当流水线或者阶段完成态与之前不同时。
	- failure 只有当流水线或者阶段状态为"failure"运行。
	- success 只有当流水线或者阶段状态为"success"运行。
	- unstable 只有当流水线或者阶段状态为"unstable"运行。例如:测试失败。
	- aborted 只有当流水线或者阶段状态为"aborted"运行。例如:手动取消。

3. agent 可以指定执行节点

	label 执行运行job的节点标签
	any 不指定，由jenkins分配

### 3.3.2 jenkins中使用pipline

1. 选择构建pipline项目

	![](/other/install/jenkins/133.png)

2. 构建的配置项

	![](/other/install/jenkins/134.png)

3. 脚本内容

	```Groovy
	pipeline {
		agent any
		
		stages {
			stage("拉取代码") {
				steps {
					echo "拉取成功"
				}
			}
			stage("执行构建") {
				steps {
					echo "构建完成"
				}
			}
		}
	}
	```

4. 赋予脚本权限

	![](/other/install/jenkins/135.png)
5. 执行pipline脚本

	![](/other/install/jenkins/136.png)
6. 脚本执行图

	![](/other/install/jenkins/137.png)

	![](/other/install/jenkins/138.png)

### 3.3.3 使用pipeline自动打包Docker镜像

#### 流水线总体的步骤

```Groovy
pipeline {
	agent any
	
	stages {
		stage("拉取代码") {
			steps {
				echo "拉取成功"
			}
		}
		stage("执行构建") {
			steps {
				echo "构建完成"
			}
		}
		stage("清理旧docker") {
			steps {
				echo "清理完成"
			}
		}
		stage("发送文件到服务器并运行") {
			steps {
				echo "docker已启动"
			}
		}
	}
}
```

#### 使用流水线语法git拉取

1. 添加流水线语法

	![](/other/install/jenkins/139.png)
2. 生成 git 脚本

	![](/other/install/jenkins/140.png)

	- git地址与main分支

		![](/other/install/jenkins/142.png)
	- 凭证

		![](/other/install/jenkins/141.png)
3. 生成的git脚本

	```Groovy
	git branch: 'main', credentialsId: 'gitlab', url: 'http://192.168.18.81/root/java-project.git'
	```
4. 构建结果

	![](/other/install/jenkins/150.png)
#### maven构建工具

1. 查询maven配置信息

	![](/other/install/jenkins/143.png)
2. mvn测试

	![](/other/install/jenkins/144.png)
3. maven 构建

	![](/other/install/jenkins/146.png)
4. 构建结果

	![](/other/install/jenkins/145.png)

#### 清理旧的docker

1. 流水线语法中前置执行

	![](/other/install/jenkins/147.png)
2. 生成的脚本

	![](/other/install/jenkins/148.png)

	**格式化后**

	```Groovy
	sshPublisher(publishers: [
		sshPublisherDesc(
			configName: 'Test-Server-Docker', 
			transfers: [
				sshTransfer(
					cleanRemote: false, 
					excludes: '', 
					execCommand: '''
						# 安全删除，如果目录为空也不报错
						rm -rf ./* 2>/dev/null || true
						
						# 安全停止和删除容器
						docker stop demo 2>/dev/null || echo "容器不存在或已停止"
						docker rm demo 2>/dev/null || echo "容器不存在或已删除"
						
						# 安全删除镜像
						docker rmi demo 2>/dev/null || echo "镜像不存在"
					''', 
					execTimeout: 120000, 
					flatten: false, 
					makeEmptyDirs: false, 
					noDefaultExcludes: false, 
					patternSeparator: '[, ]+', 
					remoteDirectory: '/root', 
					remoteDirectorySDF: false, 
					removePrefix: '', 
					sourceFiles: ''
				)
			], 
			usePromotionTimestamp: false, 
			useWorkspaceInPromotion: false, 
			verbose: false
		)
	])
	```
3. 添加到脚本中

	![](/other/install/jenkins/149.png)
4. 构建结果

	![](/other/install/jenkins/151.png)

#### 发送jar包与dockerfile文件后并启动

1. 流水线与法中的配置

	![](/other/install/jenkins/152.png)
2. 生成的脚本

	![](/other/install/jenkins/148.png)

	**格式化后**

	```Groovy
	steps {
		sshPublisher(
			publishers: [
				sshPublisherDesc(
					configName: 'Test-Server-Docker',  // SSH服务器配置名称
					transfers: [
						// 传输1：上传JAR文件
						sshTransfer(
							cleanRemote: false,        // 不清空远程目录
							excludes: '',              // 不排除任何文件
							execCommand: '',           // 无执行命令
							execTimeout: 120000,       // 执行超时120秒
							flatten: false,            // 不扁平化目录结构
							makeEmptyDirs: false,      // 不创建空目录
							noDefaultExcludes: false,  // 使用默认排除规则
							patternSeparator: '[, ]+', // 模式分隔符
							remoteDirectory: '/jarfile', // 远程目标目录
							remoteDirectorySDF: false, // 不使用时间戳目录
							removePrefix: 'target',    // 移除路径前缀
							sourceFiles: '**/java-demo*.jar' // 源文件匹配模式
						),
						// 传输2：上传Dockerfile并执行命令
						sshTransfer(
							cleanRemote: false,
							excludes: '',
							execCommand: '''
								docker build -t demo .
								docker run -d -p 8888:8080 --name demo demo
							''',                      // Docker构建和运行命令
							execTimeout: 120000,
							flatten: false,
							makeEmptyDirs: false,
							noDefaultExcludes: false,
							patternSeparator: '[, ]+',
							remoteDirectory: '/',      // 上传到根目录
							remoteDirectorySDF: false,
							removePrefix: 'docker',    // 移除'docker'前缀
							sourceFiles: 'docker/dockerfile' // Dockerfile文件
						)
					],
					usePromotionTimestamp: false,      // 不使用时间戳
					useWorkspaceInPromotion: false,    // 不使用工作空间
					verbose: false                     // 不显示详细信息
				)
			]
		)
	}
	```
3. 添加到脚本中

	![](/other/install/jenkins/154.png)
4. 构建结果
	![](/other/install/jenkins/155.png)

#### 执行完后系统docker

- 镜像与容器

	![](/other/install/jenkins/156.png)
- 执行结果

	![](/other/install/jenkins/157.png)

#### 最终脚本

```Groovy
pipeline {
	agent any
	
    tools {
        maven "maven3"
    }
	
	stages {
		stage("拉取代码") {
			steps {
			    git branch: 'main', credentialsId: 'gitlab', url: 'http://192.168.18.81/root/java-project.git'
				echo "拉取成功"
			}
		}
		stage("执行构建") {
            steps {
                sh 'mvn clean package'
                echo "构建完成"
			}
		}
		stage("清理旧docker") {
			steps {
			     sshPublisher(publishers: [
                    sshPublisherDesc(
                        configName: 'Test-Server-Docker', 
                        transfers: [
                            sshTransfer(
                                cleanRemote: false, 
                                excludes: '', 
                                execCommand: '''
                                    # 安全删除，如果目录为空也不报错
                                    rm -rf ./* 2>/dev/null || true
                                    
                                    # 安全停止和删除容器
                                    docker stop demo 2>/dev/null || echo "容器不存在或已停止"
                                    docker rm demo 2>/dev/null || echo "容器不存在或已删除"
                                    
                                    # 安全删除镜像
                                    docker rmi demo 2>/dev/null || echo "镜像不存在"
                                ''', 
                                execTimeout: 120000, 
                                flatten: false, 
                                makeEmptyDirs: false, 
                                noDefaultExcludes: false, 
                                patternSeparator: '[, ]+', 
                                remoteDirectory: '/root', 
                                remoteDirectorySDF: false, 
                                removePrefix: '', 
                                sourceFiles: ''
                            )
                        ], 
                        usePromotionTimestamp: false, 
                        useWorkspaceInPromotion: false, 
                        verbose: false
                    )
                ])
                echo "清理完成"
			}
		}
		stage("发送文件到服务器并运行") {
			steps {
			    sshPublisher(
                    publishers: [
                        sshPublisherDesc(
                            configName: 'Test-Server-Docker',  // SSH服务器配置名称
                            transfers: [
                                // 传输1：上传JAR文件
                                sshTransfer(
                                    cleanRemote: false,        // 不清空远程目录
                                    excludes: '',              // 不排除任何文件
                                    execCommand: '',           // 无执行命令
                                    execTimeout: 120000,       // 执行超时120秒
                                    flatten: false,            // 不扁平化目录结构
                                    makeEmptyDirs: false,      // 不创建空目录
                                    noDefaultExcludes: false,  // 使用默认排除规则
                                    patternSeparator: '[, ]+', // 模式分隔符
                                    remoteDirectory: '/jarfile', // 远程目标目录
                                    remoteDirectorySDF: false, // 不使用时间戳目录
                                    removePrefix: 'target',    // 移除路径前缀
                                    sourceFiles: '**/java-demo*.jar' // 源文件匹配模式
                                ),
                                // 传输2：上传Dockerfile并执行命令
                                sshTransfer(
                                    cleanRemote: false,
                                    excludes: '',
                                    execCommand: '''
                                        docker build -t demo .
                                        docker run -d -p 8888:8080 --name demo demo
                                    ''',                      // Docker构建和运行命令
                                    execTimeout: 120000,
                                    flatten: false,
                                    makeEmptyDirs: false,
                                    noDefaultExcludes: false,
                                    patternSeparator: '[, ]+',
                                    remoteDirectory: '/',      // 上传到根目录
                                    remoteDirectorySDF: false,
                                    removePrefix: 'docker',    // 移除'docker'前缀
                                    sourceFiles: 'docker/dockerfile' // Dockerfile文件
                                )
                            ],
                            usePromotionTimestamp: false,      // 不使用时间戳
                            useWorkspaceInPromotion: false,    // 不使用工作空间
                            verbose: false                     // 不显示详细信息
                        )
                    ]
                )
				echo "docker已启动"
			}
		}
	}
}
```


## 3.4 多分支流水线

### 3.4.1 创建jenkins任务

1. 新建多分支项目

	![](/other/install/jenkins/158.png)

2. 选择git源

	![](/other/install/jenkins/159.png)

	- git配置

		![](/other/install/jenkins/160.png)

3. 脚本所在位置

	![](/other/install/jenkins/161.png)
4. 分支保留数量

	![](/other/install/jenkins/162.png)

5. 上诉配置完成后，点击保存即可。

### 3.4.2 创建jenkinsfile

1. 项目中创建jenkinsfile文件

	在项目根目录下创建`by Jenkinsfile`时填写的名称，本示例中填写的是（jenkinsfile）

	![](/other/install/jenkins/163.png)

2. jenkinsfile文件内容

	```Groovy
	pipeline {
		agent any
		
		tools {
			maven "maven3"
		}
		
		environment {
			// 分支对应的环境变量
			ENV_DEV_PATH = "dev"
			ENV_TEST_PATH = "test"
			ENV_PRO_PATH = "pro"

			// 分支对应的端口
			DEV_PORT = "8080"
			TEST_PORT = "8081"
			PRO_PORT = "8082"

			// 应用名称
			APP_NAME = "demo"
		}

		stages {
			stage('Git Checkout') {
				steps {
					checkout scm
				}
			}

			stage('Build and Deploy') {
				steps {
					script {
						// 根据分支设置环境变量
						if (env.BRANCH_NAME == 'dev') {
							env.DEPLOY_PATH = env.ENV_DEV_PATH
							env.APP_PORT = env.DEV_PORT
							env.JAR_NAME = "demo-dev.jar"
						} else if (env.BRANCH_NAME == 'test') {
							env.DEPLOY_PATH = env.ENV_TEST_PATH
							env.APP_PORT = env.TEST_PORT
							env.JAR_NAME = "demo-test.jar"
						} else if (env.BRANCH_NAME == 'main') {
							env.DEPLOY_PATH = env.ENV_PRO_PATH
							env.APP_PORT = env.PRO_PORT
							env.JAR_NAME = "demo-pro.jar"
						} else {
							error("不支持的分支: ${env.BRANCH_NAME}")
						}
					}

					// Maven构建
					sh 'mvn clean package -DskipTests'

					// 重命名JAR包
					sh "cp target/*.jar target/${env.JAR_NAME}"

					// SSH部署到目标服务器
					sshPublisher(publishers: [
						sshPublisherDesc(
							configName: 'Test-Server',
							transfers: [
								// 第一步：确保目录存在，并杀死旧进程（可选）
								sshTransfer(
									execCommand: """
										# 确保目录存在
										mkdir -p ${DEPLOY_PATH}
										# 杀死旧进程（安全起见）
										lsof -ti:${APP_PORT} | xargs kill -9 2>/dev/null || true
										sleep 2
									""",
									execTimeout: 30000,
									sourceFiles: '', // 不传文件
									remoteDirectory: ''
								),

								// 第二步：上传 JAR 文件
								sshTransfer(
									sourceFiles: "target/${JAR_NAME}",
									removePrefix: 'target',
									remoteDirectory: DEPLOY_PATH,
									execCommand: """
										# 进入目录中
										cd ${DEPLOY_PATH}
										# 启动项目
										nohup java -jar ${JAR_NAME} --server.port=${APP_PORT} > app.log 2>&1 &
								""",
								),
							],
							usePromotionTimestamp: false,
							useWorkspaceInPromotion: false,
							verbose: false
						)
					])
				}
			}
		}

		post {
			always {
				cleanWs()
			}
			success {
				echo " ${env.BRANCH_NAME} 分支部署成功！"
				echo " 部署目录: ${env.DEPLOY_PATH}"
				echo " 服务端口: ${env.APP_PORT}"
			}
			failure {
				echo " ${env.BRANCH_NAME} 分支部署失败！"
			}
		}
	}
	```
### 3.4.3 扫描分支测试验证

1. 准备好所有分支

	![](/other/install/jenkins/164.png)

2. 扫描所有分支

	![](/other/install/jenkins/165.png)

3. 单独构建分支

	![](/other/install/jenkins/166.png)

4. 构建结果

	![](/other/install/jenkins/167.png)

5. 测试结果
		
	 - dev分支访问结果

		![](/other/install/jenkins/168.png)
	- test分支访问结果

	 	![](/other/install/jenkins/169.png)
	- pro分支访问结果

		![](/other/install/jenkins/170.png)

	 	