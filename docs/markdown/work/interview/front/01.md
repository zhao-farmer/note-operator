# 一、JavaScript

## 1.1 高频面试题

### 1. 什么是闭包？有什么作用和副作用？

- **回答**：

    闭包是指一个函数能够记住并访问其词法作用域，即使该函数在其作用域之外执行。简单说，函数内部定义的函数就是一个闭包。

- **代码示例**：

    ```javascript
    function outer() {
    const name = '前端'; // 外部函数的变量
    function inner() { // 内部函数，一个闭包
        console.log(name); // 访问了外部函数的变量
    }
    return inner;
    }

    const closureFn = outer();
    closureFn(); // 输出 "前端"，即使outer()已经执行完毕，inner仍能访问name
    ```

- **作用**：

    1.  **创建私有变量**：模拟私有方法，防止变量被全局污染。
        

        ```javascript
        function createCounter() {
        let count = 0; // 私有变量
        return {
            increment() { count++; },
            getValue() { return count; }
        };
        }
        const counter = createCounter();
        counter.increment();
        console.log(counter.getValue()); // 1
        // console.log(count); // 报错：count is not defined
        ```
        
    2.  **数据封装**：在函数式编程中常用。
        

- **副作用**：

    1.  **内存泄漏**：如果闭包引用了一个大的对象，且闭包本身长期存在（如被设置为全局变量或DOM事件回调），那么它引用的变量就无法被垃圾回收。
        

        ```javascript
        function leakMemory() {
        const bigData = new Array(1000000); // 一个大数组
        return function() { console.log('I have a closure'); };
        // 即使leakMemory执行完，bigData因为被返回的闭包引用而无法释放
        }
        ```
### 2. 解释 JavaScript 的事件循环（Event Loop）机制。

- **回答**：

    JavaScript 是单线程的，事件循环机制负责处理异步任务，避免阻塞。它的核心是**：执行同步代码 -> 清空微任务队列 -> 渲染（如需）-> 取一个宏任务执行 -> 重复**。

- **代码示例**：

    ```javascript
    console.log('1. 同步代码 start'); // 【宏任务1】

    setTimeout(() => {
        console.log('4. setTimeout - 宏任务'); // 【宏任务2】
    }, 0);

    Promise.resolve().then(() => {
        console.log('3. Promise - 微任务'); // 【微任务1】
    });

    console.log('2. 同步代码 end'); // 【宏任务1结束】

    // 输出顺序: 1 -> 2 -> 3 -> 4
    ```

- **流程**：

    1.  执行整体 script（第一个宏任务）。
        
    2.  遇到 `setTimeout`，将其回调放入**宏任务队列**。
        
    3.  遇到 `Promise.then`，将其回调放入**微任务队列**。
        
    4.  同步代码执行完毕，开始清空**微任务队列**，执行 `Promise`回调。
        
    5.  微任务清空后，进行可能的 DOM 渲染。
        
    6.  从**宏任务队列**中取出 `setTimeout`的回调执行。

### 3. `var`、`let`、`const`的区别是什么？

| 特性  | `var` | `let` | `const` |
| --- | --- | --- | --- |
| **作用域**​ | 函数作用域 | 块级作用域 (`{}`) | 块级作用域 (`{}`) |
| **变量提升**​ | 提升且初始化为 `undefined` | 提升但不初始化（暂时性死区） | 提升但不初始化（暂时性死区） |
| **重复声明**​ | 允许  | 不允许 | 不允许 |
| **值/引用可变性**​ | 可变  | 可变  | 声明的常量**指向的内存地址不得改动**​ |

- **代码示例**：

    ```javascript
    // 作用域
    if (true) {
        var a = 1;
        let b = 2;
        const c = 3;
    }
    console.log(a); // 1 (var是函数作用域，if块外也能访问)
    // console.log(b); // 报错: b is not defined
    // console.log(c); // 报错: c is not defined

    // 变量提升
    console.log(x); // undefined (var被提升)
    var x = 10;
    // console.log(y); // 报错: Cannot access 'y' before initialization
    let y = 20;

    // 重复声明
    var z = 1;
    var z = 2; // 允许
    // let z = 3; // 报错: Identifier 'z' has already been declared

    // const 的不可变性
    const PI = 3.14;
    // PI = 3.14159; // 报错: Assignment to constant variable

    const obj = { name: 'Alice' };
    obj.name = 'Bob'; // 允许，因为obj指向的内存地址没变，只是内容变了
    // obj = {}; // 报错: Assignment to constant variable (改变了内存地址)
    ```


### 4. `this`的绑定规则有哪些？

- **回答**：​ `this`的指向在函数被调用时确定，主要有4种规则（按优先级从低到高）：

1.  **默认绑定**：独立函数调用，`this`指向全局对象（浏览器中为 `window`，严格模式下为 `undefined`）。

    ```javascript
    function foo() { console.log(this); }
    foo(); // window (非严格模式)
    ```
    
2.  **隐式绑定**：函数作为对象的方法调用，`this`指向调用它的对象。
    
    ```javascript
    const obj = { name: 'Obj', foo: foo };
    obj.foo(); // obj
    ```
    
3.  **显式绑定**：使用 `call`, `apply`, `bind`强制指定 `this`。
    
    ```javascript
    foo.call(obj); // this 指向 obj
    const boundFoo = foo.bind(obj); // bind 返回一个永久绑定this的新函数
    boundFoo();
    ```
    
4.  **`new`绑定**：使用 `new`调用构造函数，`this`指向新创建的对象实例。
    
    ```javascript
    function Person(name) { this.name = name; }
    const p = new Person('Jack');
    console.log(p.name); // Jack
    ```
    
5.  **箭头函数**：箭头函数没有自己的 `this`，它继承自定义它时的外层作用域。
    
    ```javascript
    const arrowObj = {
      name: 'Arrow',
      foo: () => console.log(this.name), // this 继承自全局，不是arrowObj
      bar() {
        setTimeout(() => {
          console.log(this.name); // this 继承自bar函数的this，即arrowObj
        }, 100);
      }
    };
    arrowObj.foo(); // 输出空（或undefined）
    arrowObj.bar(); // 输出 'Arrow'
    ```

### 5. 如何实现深拷贝？有哪些方法及其局限性？

- **回答**：​ 深拷贝是创建一个新对象，完全复制原对象的所有属性（包括嵌套对象），使新旧对象完全独立。

- **方法1：`JSON.parse(JSON.stringify(obj))`（最常用，但有局限）**

    ```javascript
    const obj = { a: 1, b: { c: 2 } };
    const deepCopy = JSON.parse(JSON.stringify(obj));
    deepCopy.b.c = 20;
    console.log(obj.b.c); // 2 (原对象未被修改)
    ```

- **局限性**：

    * 忽略 `undefined`、`Symbol`、函数。
        
    * 不能处理循环引用（会报错）。
        
    * 会丢弃对象的 `constructor`，所有构造函数都指向 `Object`。
        
    * 不能正确处理特殊对象，如 `Date`（会变成字符串）、`RegExp`（会变成空对象）等。

- **方法2：手写递归实现（处理循环引用）**

    ```javascript
    function deepClone(target, map = new WeakMap()) {
      // 处理基本数据类型和函数
      if (target === null || typeof target !== 'object') return target;

      // 处理循环引用
      if (map.has(target)) return map.get(target);

      // 处理Date和RegExp
      if (target instanceof Date) return new Date(target);
      if (target instanceof RegExp) return new RegExp(target);

      // 创建新对象，并保存到map中
      const cloneObj = new target.constructor();
      map.set(target, cloneObj);

      // 递归拷贝所有属性（包括Symbol键）
      for (let key in target) {
        if (target.hasOwnProperty(key)) {
          cloneObj[key] = deepClone(target[key], map);
        }
      }

      // 处理Symbol类型的属性键
      const symKeys = Object.getOwnPropertySymbols(target);
      for (let symKey of symKeys) {
        cloneObj[symKey] = deepClone(target[symKey], map);
      }

      return cloneObj;
    }

    // 测试循环引用
    const objA = { name: 'A' };
    objA.self = objA;
    const clonedA = deepClone(objA);
    console.log(clonedA.name); // 'A'
    console.log(clonedA.self === clonedA); // true (解决了循环引用)
    ```

### 6. 什么是原型链？如何实现继承？

- **回答**：​ 每个对象都有一个内部属性 `[[Prototype]]`（可通过 `__proto__`访问），指向它的原型。当访问一个对象的属性时，如果自身没有，就会去它的原型上找，如果原型上也没有，就去原型的原型上找，这样一层层向上查找的链条就是原型链。顶端是 `Object.prototype`，其 `[[Prototype]]`为 `null`。

- **实现继承（ES5 寄生组合式继承 - 最理想）**

    ```javascript
    // 父类
    function Parent(name) {
      this.name = name;
      this.colors = ['red', 'blue'];
    }
    Parent.prototype.sayName = function() { console.log(this.name); };

    // 子类
    function Child(name, age) {
      Parent.call(this, name); // 1. 继承实例属性（构造函数窃取）
      this.age = age;
    }

    // 2. 继承原型方法（寄生式）
    // 创建一个以Parent.prototype为原型的新对象，作为Child的原型
    // 避免直接Child.prototype = Parent.prototype，导致修改子类原型影响父类
    Child.prototype = Object.create(Parent.prototype);
    // 修正constructor指向
    Child.prototype.constructor = Child;

    // 子类自己的方法
    Child.prototype.sayAge = function() { console.log(this.age); };

    // 测试
    const child1 = new Child('Tom', 5);
    child1.colors.push('green');
    child1.sayName(); // Tom
    child1.sayAge(); // 5

    const child2 = new Child('Jerry', 6);
    console.log(child2.colors); // ['red', 'blue'] (实例属性独立)
    ```

- **ES6 Class 继承（语法糖，底层仍是原型链）**

    ```javascript
    class Parent {
      constructor(name) {
        this.name = name;
      }
      sayName() {
        console.log(this.name);
      }
    }

    class Child extends Parent { // extends 实现原型继承
      constructor(name, age) {
        super(name); // super 相当于 Parent.call(this, name)
        this.age = age;
      }
      sayAge() {
        console.log(this.age);
      }
    }
    ```

### 7. `new`操作符的执行过程是怎样的？

- **回答**：

    1.  创建一个空的简单 JavaScript 对象（即 `{}`）。
        
    2.  为新对象的 `[[Prototype]]`（即 `__proto__`） 赋值为构造函数的 `prototype`属性。
        
    3.  将构造函数内部的 `this`绑定到这个新对象上。
        
    4.  执行构造函数内部的代码（为这个新对象添加属性）。
        
    5.  如果构造函数返回一个对象，则返回该对象；否则返回新创建的对象。
        

- **手写实现 `new`**：

    ```javascript
    function myNew(constructorFn, ...args) {
      // 1. 创建一个新对象，并将其原型指向构造函数的prototype
      const obj = Object.create(constructorFn.prototype);

      // 2. 执行构造函数，并将this绑定到新对象
      const result = constructorFn.apply(obj, args);

      // 3. 判断返回值：如果构造函数返回了一个对象，则返回该对象；否则返回新对象
      return result instanceof Object ? result : obj;
    }

    // 测试
    function Person(name) {
      this.name = name;
    }
    Person.prototype.sayHello = function() {
      console.log(`Hello, I'm ${this.name}`);
    };

    const p = myNew(Person, 'Alice');
    p.sayHello(); // Hello, I'm Alice
    ```

### 8. 防抖（debounce）和节流（throttle）的区别及实现？

- **回答**：

* **防抖**：在事件被触发 n 秒后再执行回调，如果在 n 秒内又被触发，则重新计时。**（等你不抖了再执行）**
    
    * **场景**：搜索框输入联想、窗口 `resize`。

* **节流**：在规定的时间间隔内，只执行一次回调。**（按规定频率执行）**
    
    * **场景**：滚动加载、按钮频繁点击。

- **代码实现**：

    - **防抖**：

        ```javascript
        function debounce(fn, delay) {
          let timer = null;
          return function (...args) {
            // 每次触发都清除之前的定时器，重新开始计时
            clearTimeout(timer);
            timer = setTimeout(() => {
              fn.apply(this, args);
            }, delay);
          };
        }

        // 使用
        const input = document.getElementById('search');
        input.addEventListener('input', debounce(function(e) {
          console.log('发送搜索请求:', e.target.value);
        }, 500));
        ```

    - **节流（时间戳版 - 立即执行）**：

        ```javascript
        function throttle(fn, delay) {
          let lastTime = 0;
          return function (...args) {
            const now = Date.now();
            // 如果距离上次执行的时间超过了delay，则执行
            if (now - lastTime > delay) {
              fn.apply(this, args);
              lastTime = now;
            }
          };
        }
        ```

    - **节流（定时器版 - 延迟执行）**：

        ```javascript
        function throttle(fn, delay) {
          let timer = null;
          return function (...args) {
            if (!timer) { // 定时器不存在，说明可以执行
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = null; // 执行完后清空定时器
              }, delay);
            }
          };
        }

        // 使用（结合版：头尾都执行）
        function betterThrottle(fn, delay) {
          let timer = null;
          let lastTime = 0;
          return function (...args) {
            const now = Date.now();
            const remaining = delay - (now - lastTime);

            clearTimeout(timer);
            if (remaining <= 0) {
              // 距离上次执行已超过delay，立即执行
              fn.apply(this, args);
              lastTime = now;
            } else {
              // 否则，设置一个定时器，在剩余时间后执行（保证尾执行）
              timer = setTimeout(() => {
                fn.apply(this, args);
                lastTime = Date.now();
              }, remaining);
            }
          };
        }
        ```

### 9. `Promise`有哪几种状态？如何处理错误？

- **回答**：

    Promise 有三种状态：

    * **pending（等待中）**：初始状态。
        
    * **fulfilled（已成功）**：操作成功完成。
        
    * **rejected（已失败）**：操作失败。
        

    状态一旦改变就不可逆（从 `pending`变为 `fulfilled`或 `rejected`）。

- **错误处理**：

    1.  **`.catch()`**：捕获链式中任何 `reject`或抛出的错误。是 `.then(null, onRejected)`的语法糖。
        
    2.  **`.then()`的第二个参数**：只能捕获它**之前**的 Promise 的错误。
        
    3.  **`try...catch`与 `async/await`**：以同步方式处理异步错误。
        

- **代码示例**：

    ```javascript
    const p = new Promise((resolve, reject) => {
      // 异步操作...
      if (/* 成功 */ true) {
        resolve('Success!');
      } else {
        reject('Failed!');
      }
    });

    p.then((value) => {
      console.log(value); // Success!
      throw new Error('Oops!'); // 在then中抛出错误
    }).catch((error) => { // catch 捕获前面所有错误（包括reject和throw）
      console.error('Caught in catch:', error); // Caught in catch: Error: Oops!
    });

    // 使用 async/await
    async function handlePromise() {
      try {
        const result = await p;
        console.log(result);
      } catch (error) {
        console.error('Caught in try-catch:', error);
      }
    }
    ```

### 10. 如何准确判断数据类型（如数组、日期、null 等）？

- **回答**：​ 使用 `Object.prototype.toString.call()`是最准确的方法。

- **代码示例**：

    ```javascript
    function getType(obj) {
      return Object.prototype.toString.call(obj).slice(8, -1).toLowerCase();
    }

    console.log(getType([])); // 'array'
    console.log(getType({})); // 'object'
    console.log(getType(null)); // 'null'
    console.log(getType(undefined)); // 'undefined'
    console.log(getType(new Date())); // 'date'
    console.log(getType(/abc/)); // 'regexp'
    console.log(getType(Symbol())); // 'symbol'

    // 其他方法的局限性
    console.log(typeof null); // 'object' (错误!)
    console.log(typeof []); // 'object' (不精确)
    console.log(Array.isArray([])); // true (仅适用于数组)
    ```


### 11. `==`和 `===`的区别？类型转换规则了解吗？

- **回答**：

    * `==`（宽松相等）：会进行类型转换后再比较值
        
    * `===`（严格相等）：不会进行类型转换，要求类型和值都相同
        
- **类型转换规则（隐式转换）**：

    1. **数字和字符串比较**：字符串转为数字
        
    2. **布尔值和其他类型**：布尔值转为数字（true→1, false→0）
        
    3. **对象和基本类型**：对象调用 `valueOf()`或 `toString()`转为基本类型
        
- **代码示例**：

    ```javascript
    // 经典面试题
    console.log(1 == '1');    // true (字符串'1'转为数字1)
    console.log(1 === '1');   // false (类型不同)

    console.log(0 == false);  // true (false转为0)
    console.log(0 === false); // false

    console.log('' == false); // true (两边都转为0)
    console.log('' == 0);     // true

    console.log(null == undefined); // true (特殊情况)
    console.log(null === undefined); // false

    console.log([] == 0);     // true ([]转为''再转为0)
    console.log([] == false); // true
    console.log([] == '');    // true

    // 对象比较
    console.log({} == {});    // false (比较的是引用地址)
    console.log({} === {});   // false

    // 推荐始终使用 === 避免意外类型转换
    ```

### 12. 什么是作用域和作用域链？

- **回答**：​ 作用域是变量和函数的可访问范围。作用域链是当访问一个变量时，JS引擎会从当前作用域开始查找，如果找不到就向父级作用域查找，直到全局作用域。

- **代码示例**：

    ```javascript
    var globalVar = 'global';

    function outer() {
        var outerVar = 'outer';

        function inner() {
            var innerVar = 'inner';
            console.log(innerVar);    // 'inner' - 当前作用域
            console.log(outerVar);    // 'outer' - 父级作用域
            console.log(globalVar);   // 'global' - 全局作用域
            // console.log(notExist); // 报错：作用域链上都找不到
        }

        inner();
    }

    outer();

    // 块级作用域 (let/const)
    if (true) {
        let blockScoped = 'inside block';
        var functionScoped = 'inside function';
    }
    // console.log(blockScoped); // 报错：块级作用域外无法访问
    console.log(functionScoped); // 'inside function' - var是函数作用域
    ```

### 13. 什么是变量提升（Hoisting）？

- **回答**：​ 变量和函数声明在代码执行前会被"提升"到所在作用域的顶部。

- **代码示例**：

    ```javascript
    // 变量提升 (var)
    console.log(a); // undefined (提升但未赋值)
    var a = 10;
    console.log(a); // 10

    // 实际执行顺序相当于：
    // var a;          // 声明提升
    // console.log(a); // undefined
    // a = 10;         // 赋值留在原地
    // console.log(a); // 10

    // 函数声明提升
    sayHello(); // "Hello" - 函数声明整体提升

    function sayHello() {
        console.log("Hello");
    }

    // 函数表达式不会整体提升
    // sayHi(); // 报错：sayHi is not a function
    var sayHi = function() {
        console.log("Hi");
    };

    // let/const 的暂时性死区
    // console.log(b); // 报错：Cannot access 'b' before initialization
    let b = 20;
    ```

### 14. ES5 中如何实现继承？（组合继承、寄生组合等）

**回答**：​ 主要有以下几种方式：

- 1. **原型链继承**

    ```javascript
    function Parent() {
        this.name = 'parent';
    }
    Parent.prototype.sayName = function() {
        console.log(this.name);
    };

    function Child() {}
    Child.prototype = new Parent(); // 原型链继承

    const child = new Child();
    child.sayName(); // 'parent'
    ```

    >**问题**：​ 所有实例共享引用属性，无法向父类传参。

- 2. **构造函数继承**

    ```javascript
    function Parent(name) {
        this.name = name;
        this.colors = ['red', 'blue'];
    }

    function Child(name, age) {
        Parent.call(this, name); // 构造函数继承
        this.age = age;
    }

    const child1 = new Child('Tom', 5);
    child1.colors.push('green');

    const child2 = new Child('Jerry', 6);
    console.log(child2.colors); // ['red', 'blue'] - 实例独立
    ```

    >**问题**：​ 无法继承父类原型上的方法。

- 3. **组合继承（最常用）**

    ```javascript
    function Parent(name) {
        this.name = name;
        this.colors = ['red', 'blue'];
    }
    Parent.prototype.sayName = function() {
        console.log(this.name);
    };

    function Child(name, age) {
        Parent.call(this, name); // 继承实例属性
        this.age = age;
    }
    Child.prototype = new Parent(); // 继承原型方法
    Child.prototype.constructor = Child; // 修复constructor
    Child.prototype.sayAge = function() {
        console.log(this.age);
    };

    const child = new Child('Tom', 5);
    child.sayName(); // 'Tom'
    child.sayAge();  // 5
    ```

- 4. **寄生组合式继承（最理想）**

    ```javascript
    function inheritPrototype(child, parent) {
        const prototype = Object.create(parent.prototype); // 创建父类原型的副本
        prototype.constructor = child; // 修复constructor
        child.prototype = prototype;   // 赋值给子类原型
    }

    function Parent(name) {
        this.name = name;
    }
    Parent.prototype.sayName = function() {
        console.log(this.name);
    };

    function Child(name, age) {
        Parent.call(this, name);
        this.age = age;
    }

    inheritPrototype(Child, Parent);

    Child.prototype.sayAge = function() {
        console.log(this.age);
    };
    ```

### 15. 什么是 IIFE？有什么用途？

- **回答**：​ IIFE（立即调用函数表达式）是定义后立即执行的函数。

- **代码示例**：

    ```javascript
    // 基本语法
    (function() {
        console.log('IIFE executed immediately');
    })();

    // 另一种写法
    (function() {
        console.log('Also an IIFE');
    }());

    // 带参数的IIFE
    (function(name) {
        console.log('Hello, ' + name);
    })('Alice');

    // 返回值的IIFE
    const result = (function(a, b) {
        return a + b;
    })(5, 3);
    console.log(result); // 8
    ```

- **主要用途**：

    1. **创建私有作用域**，避免变量污染全局

        ```javascript
        // 避免污染全局命名空间
        (function() {
            var privateVar = 'secret';
            function privateFunction() {
                console.log(privateVar);
            }
            // 只在IIFE内部可访问
            privateFunction();
        })();
        // console.log(privateVar); // 报错：privateVar is not defined
        ```

    2.  **模块模式**（在ES6之前）

        ```javascript
        const myModule = (function() {
            let privateCounter = 0;

            function privateFunction() {
                return 'private';
            }

            return {
                increment: function() {
                    privateCounter++;
                },
                getValue: function() {
                    return privateCounter;
                },
                publicMethod: function() {
                    return privateFunction() + ' but exposed';
                }
            };
        })();

        myModule.increment();
        console.log(myModule.getValue()); // 1
        console.log(myModule.publicMethod()); // "private but exposed"
        // myModule.privateFunction(); // 报错：不是公开方法
        ```

### 16. `map`、`filter`、`reduce`的使用场景和区别？

**回答**：​ 这三个都是数组的高阶函数，用于函数式编程。

1. **`map`\- 映射**：​ 对每个元素执行函数，返回新数组

    ```javascript
    const numbers = [1, 2, 3, 4, 5];

    // 每个元素乘以2
    const doubled = numbers.map(num => num * 2);
    console.log(doubled); // [2, 4, 6, 8, 10]

    // 提取对象特定属性
    const users = [
        { name: 'Alice', age: 25 },
        { name: 'Bob', age: 30 }
    ];
    const names = users.map(user => user.name);
    console.log(names); // ['Alice', 'Bob']
    ```

2. **`filter`\- 过滤**：​ 返回满足条件的元素组成的新数组

    ```javascript
    const numbers = [1, 2, 3, 4, 5, 6];

    // 过滤偶数
    const evens = numbers.filter(num => num % 2 === 0);
    console.log(evens); // [2, 4, 6]

    // 过滤对象数组
    const products = [
        { name: 'apple', price: 10 },
        { name: 'banana', price: 5 },
        { name: 'orange', price: 8 }
    ];
    const affordable = products.filter(product => product.price < 9);
    console.log(affordable); // [{name: 'banana', price: 5}, {name: 'orange', price: 8}]
    ```

3. **`reduce`\- 归约**：​ 将数组归约为单个值

    ```javascript
    const numbers = [1, 2, 3, 4, 5];

    // 求和
    const sum = numbers.reduce((accumulator, current) => accumulator + current, 0);
    console.log(sum); // 15

    // 求最大值
    const max = numbers.reduce((acc, curr) => Math.max(acc, curr), -Infinity);
    console.log(max); // 5

    // 复杂应用：统计字符出现次数
    const words = ['apple', 'banana', 'apple', 'orange', 'banana', 'apple'];
    const count = words.reduce((acc, word) => {
        acc[word] = (acc[word] || 0) + 1;
        return acc;
    }, {});
    console.log(count); // {apple: 3, banana: 2, orange: 1}

    // 链式调用示例
    const result = numbers
        .filter(num => num % 2 === 0)  // [2, 4]
        .map(num => num * 3)           // [6, 12]
        .reduce((acc, num) => acc + num, 0); // 18
    console.log(result); // 18
    ```

### 17. 如何阻止事件冒泡和默认行为？

- **回答**：

    * **阻止事件冒泡**：​ `event.stopPropagation()`
        
    * **阻止默认行为**：​ `event.preventDefault()`
        
- **代码示例**：

    ```html
    <div id="parent">
        父元素
        <button id="child">点击我</button>
    </div>

    <script>
    document.getElementById('parent').addEventListener('click', function(e) {
        console.log('父元素被点击');
    });

    document.getElementById('child').addEventListener('click', function(e) {
        console.log('子元素被点击');

        // 阻止事件冒泡到父元素
        e.stopPropagation();

        // 如果是链接，阻止默认跳转行为
        // e.preventDefault();
    });

    // 测试默认行为阻止
    document.getElementById('link').addEventListener('click', function(e) {
        e.preventDefault(); // 阻止链接跳转
        console.log('链接点击被阻止，但可以执行其他操作');
    });
    </script>

    <a href="https://example.com" id="link">测试链接</a>
    ```

- **事件流三个阶段**：

    1. **捕获阶段**：从window向下到目标元素
        
    2.  **目标阶段**：到达目标元素
        
    3.  **冒泡阶段**：从目标元素向上到window
        

    ```javascript
    // 事件监听器的第三个参数
    element.addEventListener('click', function() {
        console.log('冒泡阶段触发'); // 默认false
    }, false);

    element.addEventListener('click', function() {
        console.log('捕获阶段触发');
    }, true);
    ```

### 18. AJAX 原理及常见封装方式？

- **回答**：​ AJAX（Asynchronous JavaScript and XML）允许网页异步与服务器交换数据。

- **原生 XMLHttpRequest**：

    ```javascript
    function ajax(url, method = 'GET', data = null) {
        return new Promise((resolve, reject) => {
            const xhr = new XMLHttpRequest();

            xhr.open(method, url);
            xhr.setRequestHeader('Content-Type', 'application/json');

            xhr.onreadystatechange = function() {
                if (xhr.readyState === 4) {
                    if (xhr.status === 200) {
                        resolve(JSON.parse(xhr.responseText));
                    } else {
                        reject(new Error(`请求失败: ${xhr.status}`));
                    }
                }
            };

            xhr.onerror = function() {
                reject(new Error('网络错误'));
            };

            xhr.send(data ? JSON.stringify(data) : null);
        });
    }

    // 使用示例
    ajax('https://api.example.com/data')
        .then(data => console.log(data))
        .catch(error => console.error(error));
    ```

- **Fetch API（现代方式）**：

    ```javascript
    // 基本使用
    fetch('https://api.example.com/data')
        .then(response => {
            if (!response.ok) {
                throw new Error('网络响应不正常');
            }
            return response.json();
        })
        .then(data => console.log(data))
        .catch(error => console.error('错误:', error));

    // 带配置的Fetch
    async function fetchData(url, options = {}) {
        try {
            const defaultOptions = {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/json',
                },
                ...options
            };

            const response = await fetch(url, defaultOptions);

            if (!response.ok) {
                throw new Error(`HTTP错误! 状态码: ${response.status}`);
            }

            return await response.json();
        } catch (error) {
            console.error('请求失败:', error);
            throw error;
        }
    }

    // 使用示例
    const data = await fetchData('https://api.example.com/users', {
        method: 'POST',
        body: JSON.stringify({ name: 'John', age: 30 })
    });
    ```

- **axios 封装示例**：

    ```javascript
    // 如果使用axios（需要先引入）
    const api = axios.create({
        baseURL: 'https://api.example.com',
        timeout: 10000,
        headers: { 'Content-Type': 'application/json' }
    });

    // 请求拦截器
    api.interceptors.request.use(
        config => {
            const token = localStorage.getItem('token');
            if (token) {
                config.headers.Authorization = `Bearer ${token}`;
            }
            return config;
        },
        error => Promise.reject(error)
    );

    // 响应拦截器
    api.interceptors.response.use(
        response => response.data,
        error => {
            if (error.response?.status === 401) {
                // 处理未授权
                localStorage.removeItem('token');
                window.location.href = '/login';
            }
            return Promise.reject(error);
        }
    );

    // 使用
    api.get('/users')
        .then(data => console.log(data))
        .catch(error => console.error(error));
    ```

### 19. 什么是回调地狱？如何用 Promise 或 async/await 优化？

- **回答**：​ 回调地狱是多个嵌套回调导致的代码难以阅读和维护的问题。

- **回调地狱示例**：

    ```javascript
    // 回调地狱 - 难以阅读和维护
    function getUserData(userId, callback) {
        getUserInfo(userId, function(userInfo) {
            getuserPosts(userInfo.id, function(posts) {
                getPostComments(posts[0].id, function(comments) {
                    getCommentAuthor(comments[0].authorId, function(author) {
                        callback(author);
                    });
                });
            });
        });
    }
    ```

- **用 Promise 优化**：

    ```javascript
    function getUserData(userId) {
        return getUserInfo(userId)
            .then(userInfo => getuserPosts(userInfo.id))
            .then(posts => getPostComments(posts[0].id))
            .then(comments => getCommentAuthor(comments[0].authorId))
            .catch(error => console.error('错误:', error));
    }

    // 或者使用 Promise.all 处理并行请求
    function getUserDashboard(userId) {
        return Promise.all([
            getUserInfo(userId),
            getuserPosts(userId),
            getUserSettings(userId)
        ]).then(([userInfo, posts, settings]) => {
            return { userInfo, posts, settings };
        });
    }
    ```

- **用 async/await 优化（最推荐）**：

    ```javascript
    async function getUserData(userId) {
        try {
            const userInfo = await getUserInfo(userId);
            const posts = await getuserPosts(userInfo.id);
            const comments = await getPostComments(posts[0].id);
            const author = await getCommentAuthor(comments[0].authorId);
            return author;
        } catch (error) {
            console.error('获取用户数据失败:', error);
            throw error;
        }
    }

    // 并行请求优化
    async function getUserDashboard(userId) {
        try {
            const [userInfo, posts, settings] = await Promise.all([
                getUserInfo(userId),
                getuserPosts(userId),
                getUserSettings(userId)
            ]);

            return { userInfo, posts, settings };
        } catch (error) {
            console.error('获取仪表板失败:', error);
            throw error;
        }
    }
    ```

### 20. 数组去重有哪些方法？

**回答**：​ 多种去重方法，各有优缺点：

1. **Set（最简洁，ES6）**

    ```javascript
    const arr = [1, 2, 2, 3, 4, 4, 5];
    const unique = [...new Set(arr)];
    console.log(unique); // [1, 2, 3, 4, 5]

    // 字符串数组也适用
    const fruits = ['apple', 'banana', 'apple', 'orange'];
    const uniqueFruits = [...new Set(fruits)];
    console.log(uniqueFruits); // ['apple', 'banana', 'orange']
    ```

2. **filter + indexOf**

    ```javascript
    const arr = [1, 2, 2, 3, 4, 4, 5];
    const unique = arr.filter((item, index) => arr.indexOf(item) === index);
    console.log(unique); // [1, 2, 3, 4, 5]
    ```

3. **reduce**

    ```javascript
    const arr = [1, 2, 2, 3, 4, 4, 5];
    const unique = arr.reduce((acc, curr) => {
        if (!acc.includes(curr)) {
            acc.push(curr);
        }
        return acc;
    }, []);
    console.log(unique); // [1, 2, 3, 4, 5]
    ```

4. **对象属性去重（适用于复杂数据类型）**

    ```javascript
    function uniqueByKey(arr, key) {
        const seen = new Set();
        return arr.filter(item => {
            const keyValue = item[key];
            if (seen.has(keyValue)) {
                return false;
            }
            seen.add(keyValue);
            return true;
        });
    }

    const users = [
        { id: 1, name: 'Alice' },
        { id: 2, name: 'Bob' },
        { id: 1, name: 'Alice' }, // 重复
        { id: 3, name: 'Charlie' }
    ];

    const uniqueUsers = uniqueByKey(users, 'id');
    console.log(uniqueUsers);
    // [{id: 1, name: 'Alice'}, {id: 2, name: 'Bob'}, {id: 3, name: 'Charlie'}]
    ```

5. **对象数组完全去重**

    ```javascript
    function uniqueObjects(arr) {
        const seen = new Set();
        return arr.filter(obj => {
            const str = JSON.stringify(obj);
            if (seen.has(str)) {
                return false;
            }
            seen.add(str);
            return true;
        });
    }

    const data = [
        { id: 1, name: 'Alice' },
        { id: 2, name: 'Bob' },
        { id: 1, name: 'Alice' }, // 完全重复
        { id: 1, name: 'Alice' }  // 完全重复
    ];

    console.log(uniqueObjects(data));
    // [{id: 1, name: 'Alice'}, {id: 2, name: 'Bob'}]
    ```



### 21. `call`、`apply`、`bind`的区别及手写实现？

- **回答**：​ 这三个方法都用于改变函数执行时的 `this`指向。

- **区别总结**：

    * `call`：立即执行，参数逐个传递

    * `apply`：立即执行，参数通过数组传递

    * `bind`：返回新函数，不立即执行

- **代码示例**：

    ```javascript
    const person = {
        name: 'Alice',
        greet: function(greeting, punctuation) {
            console.log(`${greeting}, I'm ${this.name}${punctuation}`);
        }
    };

    const anotherPerson = { name: 'Bob' };

    // call - 参数逐个传递
    person.greet.call(anotherPerson, 'Hello', '!'); // Hello, I'm Bob!

    // apply - 参数数组传递
    person.greet.apply(anotherPerson, ['Hi', '!!']); // Hi, I'm Bob!!

    // bind - 返回新函数，稍后调用
    const boundGreet = person.greet.bind(anotherPerson, 'Hey');
    boundGreet('...'); // Hey, I'm Bob...
    ```

- **手写实现**：

    **手写 call**：

    ```javascript
    Function.prototype.myCall = function(context, ...args) {
        // 如果context为null或undefined，指向全局对象
        context = context || window;

        // 创建唯一key，避免属性冲突
        const fn = Symbol('fn');

        // 将当前函数作为context的方法
        context[fn] = this;

        // 执行函数
        const result = context[fn](...args);

        // 删除临时方法
        delete context[fn];

        return result;
    };

    // 测试
    person.greet.myCall(anotherPerson, 'Hello', '!');
    ```

    **手写 apply**：

    ```javascript
    Function.prototype.myApply = function(context, args = []) {
        context = context || window;
        const fn = Symbol('fn');
        context[fn] = this;

        const result = context[fn](...args);
        delete context[fn];

        return result;
    };

    // 测试
    person.greet.myApply(anotherPerson, ['Hi', '!!']);
    ```

    **手写 bind**：

    ```javascript
    Function.prototype.myBind = function(context, ...bindArgs) {
        const self = this;

        return function(...args) {
            return self.apply(context, bindArgs.concat(args));
        };
    };

    // 支持new操作符的完整版
    Function.prototype.myBindComplete = function(context, ...bindArgs) {
        const self = this;

        const bound = function(...args) {
            // 如果通过new调用，this指向新创建的对象
            const isNew = this instanceof bound;
            return self.apply(isNew ? this : context, bindArgs.concat(args));
        };

        // 维护原型关系
        if (self.prototype) {
            bound.prototype = Object.create(self.prototype);
        }

        return bound;
    };

    // 测试
    const bound = person.greet.myBind(anotherPerson, 'Hey');
    bound('...');
    ```

### 22. 什么是高阶函数？举例说明。

- **回答**：​ 高阶函数是接受函数作为参数或返回函数的函数。

- **代码示例**：

    ```javascript
    // 1. 接受函数作为参数（回调函数）
    function calculate(a, b, operation) {
        return operation(a, b);
    }

    const add = (x, y) => x + y;
    const multiply = (x, y) => x * y;

    console.log(calculate(5, 3, add));      // 8
    console.log(calculate(5, 3, multiply)); // 15

    // 2. 返回函数（函数工厂）
    function createMultiplier(multiplier) {
        return function(x) {
            return x * multiplier;
        };
    }

    const double = createMultiplier(2);
    const triple = createMultiplier(3);

    console.log(double(5)); // 10
    console.log(triple(5)); // 15

    // 3. 数组方法都是高阶函数
    const numbers = [1, 2, 3, 4, 5];

    const doubledEvens = numbers
        .filter(num => num % 2 === 0)        // 过滤偶数
        .map(num => num * 2)                 // 每个乘以2
        .reduce((sum, num) => sum + num, 0); // 求和

    console.log(doubledEvens); // 12

    // 4. 防抖函数（返回函数）
    function debounce(fn, delay) {
        let timer;
        return function(...args) {
            clearTimeout(timer);
            timer = setTimeout(() => fn.apply(this, args), delay);
        };
    }

    const debouncedSearch = debounce(function(query) {
        console.log(`搜索: ${query}`);
    }, 300);
    ```

### 23. 如何判断一个变量是数组？

- **回答**：​ 多种方法，推荐使用 `Array.isArray()`

- **代码示例**：

    ```javascript
    const arr = [1, 2, 3];
    const obj = {};

    // 1. Array.isArray() - 最推荐
    console.log(Array.isArray(arr)); // true
    console.log(Array.isArray(obj)); // false

    // 2. instanceof
    console.log(arr instanceof Array); // true
    console.log(obj instanceof Array); // false

    // 3. Object.prototype.toString.call() - 最准确
    console.log(Object.prototype.toString.call(arr) === '[object Array]'); // true
    console.log(Object.prototype.toString.call(obj) === '[object Array]'); // false

    // 4. constructor (不推荐，可被修改)
    console.log(arr.constructor === Array); // true
    arr.constructor = Object;
    console.log(arr.constructor === Array); // false

    // 5. 不推荐的方法
    console.log(typeof arr); // 'object' - 无法区分数组和对象

    // 综合判断函数
    function isArray(target) {
        return Array.isArray ? Array.isArray(target) : 
               Object.prototype.toString.call(target) === '[object Array]';
    }

    console.log(isArray([])); // true
    console.log(isArray({})); // false
    ```

### 24. 为什么 0.1 + 0.2 !== 0.3？如何解决精度问题？

- **回答**：​ 这是由于JavaScript使用IEEE 754双精度浮点数格式，某些小数无法精确表示。

- **代码示例**：

    ```javascript
    console.log(0.1 + 0.2); // 0.30000000000000004
    console.log(0.1 + 0.2 === 0.3); // false

    // 其他精度问题示例
    console.log(0.7 + 0.1); // 0.7999999999999999
    console.log(0.3 - 0.2); // 0.09999999999999998
    ```

**解决方案**：

1. **使用 toFixed() 格式化**

    ```javascript
    // 四舍五入到指定位数
    const sum = 0.1 + 0.2;
    console.log(sum.toFixed(2)); // "0.30"
    console.log(parseFloat(sum.toFixed(10))); // 0.3

    // 比较时使用容差
    function numbersEqual(a, b, tolerance = 1e-10) {
        return Math.abs(a - b) < tolerance;
    }

    console.log(numbersEqual(0.1 + 0.2, 0.3)); // true
    ```

2. **转换为整数计算**

    ```javascript
    function addDecimals(a, b) {
        const multiplier = Math.pow(10, Math.max(
            a.toString().split('.')[1]?.length || 0,
            b.toString().split('.')[1]?.length || 0
        ));

        return (a * multiplier + b * multiplier) / multiplier;
    }

    console.log(addDecimals(0.1, 0.2)); // 0.3
    console.log(addDecimals(0.7, 0.1)); // 0.8
    ```

3. **使用第三方库**

    ```javascript
    // 使用 decimal.js 或其他数学库
    // npm install decimal.js
    import Decimal from 'decimal.js';

    const result = new Decimal(0.1).plus(0.2);
    console.log(result.toNumber()); // 0.3
    console.log(result.equals(0.3)); // true
    ```

4. **ES6 Number.EPSILON**

    ```javascript
    function isEqual(a, b) {
        return Math.abs(a - b) < Number.EPSILON;
    }

    console.log(isEqual(0.1 + 0.2, 0.3)); // true
    ```

### 25. `for...in`和 `for...of`的区别？

- **回答**：​ 两者都用于循环，但用途完全不同。

    **for...in**：​ 遍历对象的可枚举属性（包括原型链）

    **for...of**：​ 遍历可迭代对象的值（Array, Map, Set, String等）

- **代码示例**：

    ```javascript
    const arr = ['a', 'b', 'c'];
    arr.customProp = '我是自定义属性';

    // for...in - 遍历索引/键名 (包括自定义属性)
    console.log('for...in:');
    for (let index in arr) {
        console.log(index, arr[index]); 
    }
    // 输出: 
    // 0 a
    // 1 b  
    // 2 c
    // customProp 我是自定义属性

    // for...of - 遍历值 (只遍历数组元素)
    console.log('for...of:');
    for (let value of arr) {
        console.log(value);
    }
    // 输出:
    // a
    // b
    // c

    // 对象遍历
    const obj = { a: 1, b: 2, c: 3 };

    console.log('对象 for...in:');
    for (let key in obj) {
        console.log(key, obj[key]);
    }
    // 输出:
    // a 1
    // b 2  
    // c 3

    // 对象不能直接用 for...of
    // for (let value of obj) { } // 报错

    // 但可以遍历对象的键、值、条目
    for (let key of Object.keys(obj)) {
        console.log(key);
    }

    for (let value of Object.values(obj)) {
        console.log(value);
    }

    for (let [key, value] of Object.entries(obj)) {
        console.log(key, value);
    }

    // 字符串遍历
    const str = 'hello';
    for (let char of str) {
        console.log(char); // h, e, l, l, o
    }
    ```

### 26. 什么是纯函数？函数式编程的核心思想？

- **回答**：​ 纯函数是相同的输入永远得到相同的输出，而且没有任何可观察的副作用。

- **纯函数特点**：

    1. 不修改参数
        
    2. 不修改外部状态
        
    3. 不依赖外部状态
        
    4. 没有副作用（网络请求、DOM操作等）
        

- **代码示例**：

    ```javascript
    // 纯函数
    function add(a, b) {
        return a + b;
    }

    function squareAll(numbers) {
        return numbers.map(num => num * num);
    }

    // 非纯函数
    let counter = 0;
    function increment() {
        counter++; // 修改外部状态
        return counter;
    }

    function getRandom() {
        return Math.random(); // 相同输入，不同输出
    }

    function updateDOM(element, content) {
        element.textContent = content; // DOM操作（副作用）
    }
    ```

- **函数式编程核心思想**：

    ```javascript
    // 1. 纯函数和不可变性
    const numbers = [1, 2, 3, 4, 5];

    // 不修改原数组，返回新数组
    const doubled = numbers.map(n => n * 2);
    const evens = numbers.filter(n => n % 2 === 0);

    // 2. 函数组合
    const compose = (...fns) => x => fns.reduceRight((acc, fn) => fn(acc), x);

    const toUpperCase = str => str.toUpperCase();
    const exclaim = str => str + '!';
    const emphasize = compose(exclaim, toUpperCase);

    console.log(emphasize('hello')); // HELLO!

    // 3. 高阶函数
    const curry = (fn) => {
        return function curried(...args) {
            if (args.length >= fn.length) {
                return fn.apply(this, args);
            } else {
                return function(...moreArgs) {
                    return curried.apply(this, args.concat(moreArgs));
                };
            }
        };
    };

    const multiply = (a, b) => a * b;
    const curriedMultiply = curry(multiply);
    const double = curriedMultiply(2);

    console.log(double(5)); // 10
    ```

### 27. JavaScript 的垃圾回收机制是怎样的？

- **回答**：​ JavaScript自动管理内存，主要使用标记清除算法。

- **垃圾回收算法**：

    1. **标记清除（主要算法）**

        ```javascript
        function createData() {
            const bigData = new Array(1000000).fill('data');
            return function process() {
                // 使用bigData
                return bigData.length;
            };
        }

        const processor = createData();
        // createData执行完毕，但bigData不会被回收，因为被闭包processor引用

        processor = null; // 解除引用，bigData变得不可达，下次GC时被回收
        ```

    2. **引用计数（已淘汰，但需要了解）**

        ```javascript
        // 循环引用问题（引用计数无法处理）
        function createCycle() {
            const objA = { name: 'A' };
            const objB = { name: 'B' };

            objA.ref = objB; // objA引用objB
            objB.ref = objA; // objB引用objA（循环引用）

            return 'cycle created';
        }

        createCycle();
        // 函数执行完，objA和objB互相引用，引用计数不为0，但实际已不可达
        // 标记清除可以处理这种情况：从根对象出发，标记所有可达对象，清除未标记的
        ```

- **内存管理最佳实践**：

    ```javascript
    // 1. 及时解除引用
    let largeData = new Array(1000000).fill('data');
    // 使用完后...
    largeData = null; // 帮助GC回收

    // 2. 避免意外的全局变量
    function leakMemory() {
        leakedVar = new Array(1000000); // 意外的全局变量！
    }
    leakMemory();
    // 需要手动清除：leakedVar = null;

    // 3. 谨慎使用闭包
    function createClosure() {
        const data = new Array(1000000);
        return function() {
            // 如果不需要data，不要引用它
            return 'some result';
        };
    }

    // 4. 清理事件监听器
    class Component {
        constructor() {
            this.handler = this.handleClick.bind(this);
            document.addEventListener('click', this.handler);
        }

        destroy() {
            document.removeEventListener('click', this.handler); // 重要！
        }
    }
    ```

### 28. 常见的内存泄漏原因有哪些？如何排查？

**常见内存泄漏原因**：

1. **意外的全局变量**

    ```javascript
    function createLeak() {
        leak = new Array(1000000); // 忘记写var/let/const
        this.accidentalGlobal = 'oops'; // 严格模式下this为undefined
    }

    createLeak();
    ```

2. **遗忘的定时器和回调**

    ```javascript
    // 定时器未清理
    const intervalId = setInterval(() => {
        const data = new Array(1000); // 每次执行都创建新数据
    }, 1000);

    // 需要清理：clearInterval(intervalId);

    // DOM事件未移除
    function setupListener() {
        const button = document.getElementById('myButton');
        button.addEventListener('click', () => {
            console.log('clicked');
        });
        // 如果button被移除，但监听器还在，相关DOM无法被回收
    }
    ```

3. **DOM引用**

    ```javascript
    const elements = {
        button: document.getElementById('myButton')
    };

    // 即使从DOM移除，由于elements仍引用，button不会被GC
    document.body.removeChild(elements.button);

    // 需要：elements.button = null;
    ```

4. **闭包**

    ```javascript
    function createClosureLeak() {
        const bigData = new Array(1000000);

        return function() {
            // 即使不使用bigData，只要闭包存在，bigData就不会被回收
            return 'useless';
        };
    }

    const leakyClosure = createClosureLeak();
    ```

**排查方法**：

1. **Chrome DevTools**

    ```javascript
    // 使用Performance和Memory面板
    // 1. 录制性能时间线，观察内存使用情况
    // 2. 使用Heap Snapshot比较内存快照
    // 3. 使用Allocation instrumentation记录内存分配

    // 示例：强制垃圾回收并记录快照
    function analyzeMemory() {
        // 在DevTools中点击垃圾回收图标
        // 然后记录堆快照
    }

    // 在代码中标记，便于识别
    window.__leak__ = new Array(1000000);
    ```

2. **性能监控**

    ```javascript
    // 监控内存使用
    setInterval(() => {
        const memory = performance.memory;
        console.log(`Used: ${memory.usedJSHeapSize} bytes`);

        if (memory.usedJSHeapSize > 100000000) { // 超过100MB
            console.warn('内存使用过高！');
        }
    }, 5000);
    ```

### 29. 如何实现函数柯里化（Currying）？

- **回答**：​ 柯里化是将多参数函数转换为一系列单参数函数的过程。

- **基础实现**：

    ```javascript
    function curry(fn) {
        return function curried(...args) {
            // 如果参数数量足够，直接执行
            if (args.length >= fn.length) {
                return fn.apply(this, args);
            } else {
                // 参数不够，返回新函数继续收集参数
                return function(...moreArgs) {
                    return curried.apply(this, args.concat(moreArgs));
                };
            }
        };
    }

    // 使用示例
    function add(a, b, c) {
        return a + b + c;
    }

    const curriedAdd = curry(add);

    console.log(curriedAdd(1)(2)(3)); // 6
    console.log(curriedAdd(1, 2)(3)); // 6
    console.log(curriedAdd(1)(2, 3)); // 6

    // 实用示例
    function log(level, message, timestamp) {
        return `[${level}] ${timestamp}: ${message}`;
    }

    const curriedLog = curry(log);
    const infoLog = curriedLog('INFO');
    const errorLog = curriedLog('ERROR');

    const todayInfo = infoLog(new Date().toISOString());
    console.log(todayInfo('系统启动')); // [INFO] 2024-01-01T10:00:00.000Z: 系统启动
    ```

- **占位符功能增强版**：

    ```javascript
    function curryWithPlaceholder(fn) {
        return function curried(...args) {
            // 过滤掉占位符，检查有效参数数量
            const validArgs = args.filter(arg => arg !== curryWithPlaceholder._);
            
            if (validArgs.length >= fn.length && !args.includes(curryWithPlaceholder._)) {
                return fn.apply(this, args);
            } else {
                return function(...moreArgs) {
                    // 合并参数，处理占位符
                    const combined = [];
                    let i = 0, j = 0;
                    
                    while (i < args.length || j < moreArgs.length) {
                        if (i < args.length && args[i] === curryWithPlaceholder._ && j < moreArgs.length) {
                            combined.push(moreArgs[j++]);
                            i++;
                        } else if (i < args.length) {
                            combined.push(args[i++]);
                        } else {
                            combined.push(moreArgs[j++]);
                        }
                    }
                    
                    return curried.apply(this, combined);
                };
            }
        };
    }

    curryWithPlaceholder._ = Symbol('placeholder');

    // 使用占位符
    function format(name, age, city) {
        return `${name} (${age}) - ${city}`;
    }

    const curriedFormat = curryWithPlaceholder(format);
    const formatWithCity = curriedFormat(curryWithPlaceholder._, curryWithPlaceholder._, '北京');

    console.log(formatWithCity('张三', 25)); // 张三 (25) - 北京
    ```

### 30. 手写一个简单的发布-订阅模式（EventEmitter）。

- **基础实现**：

    ```javascript
    class EventEmitter {
        constructor() {
            this.events = new Map();
        }

        // 订阅事件
        on(event, listener) {
            if (!this.events.has(event)) {
                this.events.set(event, new Set());
            }
            this.events.get(event).add(listener);
            return this; // 支持链式调用
        }

        // 一次性订阅
        once(event, listener) {
            const onceWrapper = (...args) => {
                this.off(event, onceWrapper);
                listener.apply(this, args);
            };
            onceWrapper.listener = listener; // 保存原监听器引用
            return this.on(event, onceWrapper);
        }

        // 发布事件
        emit(event, ...args) {
            if (!this.events.has(event)) return false;

            const listeners = this.events.get(event);
            listeners.forEach(listener => {
                try {
                    listener.apply(this, args);
                } catch (error) {
                    console.error(`事件 ${event} 监听器执行错误:`, error);
                }
            });
            return true;
        }

        // 取消订阅
        off(event, listener) {
            if (!this.events.has(event)) return this;

            const listeners = this.events.get(event);

            if (listener) {
                // 移除特定监听器
                for (let l of listeners) {
                    if (l === listener || l.listener === listener) {
                        listeners.delete(l);
                        break;
                    }
                }
            } else {
                // 移除所有监听器
                listeners.clear();
            }

            // 如果没有监听器了，删除事件
            if (listeners.size === 0) {
                this.events.delete(event);
            }

            return this;
        }

        // 获取所有事件名
        eventNames() {
            return Array.from(this.events.keys());
        }

        // 获取事件监听器数量
        listenerCount(event) {
            return this.events.has(event) ? this.events.get(event).size : 0;
        }

        // 移除所有监听器
        removeAllListeners(event) {
            if (event) {
                this.events.delete(event);
            } else {
                this.events.clear();
            }
            return this;
        }
    }
    ```

- **使用示例**：

    ```javascript
    // 创建事件发射器
    const emitter = new EventEmitter();

    // 订阅事件
    emitter.on('message', (msg, from) => {
        console.log(`收到来自 ${from} 的消息: ${msg}`);
    });

    emitter.on('message', (msg) => {
        console.log(`另一个监听器: ${msg}`);
    });

    // 一次性订阅
    emitter.once('welcome', (name) => {
        console.log(`欢迎 ${name}！此消息只显示一次`);
    });

    // 发布事件
    emitter.emit('message', 'Hello World', 'System');
    emitter.emit('welcome', 'Alice');
    emitter.emit('welcome', 'Bob'); // 不会触发

    // 取消订阅
    function specificListener(msg) {
        console.log(`特定监听器: ${msg}`);
    }

    emitter.on('test', specificListener);
    emitter.off('test', specificListener);

    // 异步事件处理
    emitter.on('async-event', async (data) => {
        await new Promise(resolve => setTimeout(resolve, 1000));
        console.log('异步处理完成:', data);
    });

    emitter.emit('async-event', '异步数据');
    ```


### 31. `instanceof`的原理？如何手动实现？

- **回答**：​ `instanceof`用于检查构造函数的 `prototype`属性是否出现在对象的原型链上。

- **原理**：​ 沿着对象的 `__proto__`链向上查找，如果找到构造函数的 `prototype`就返回 `true`，直到原型链尽头（`null`）返回 `false`。

- **代码示例**：

    ```javascript
    // 原生 instanceof 使用
    console.log([] instanceof Array); // true
    console.log([] instanceof Object); // true
    console.log({} instanceof Array); // false

    function Person(name) {
        this.name = name;
    }
    const person = new Person('Alice');
    console.log(person instanceof Person); // true
    console.log(person instanceof Object); // true
    ```

- **手写实现**：

    ```javascript
    function myInstanceof(instance, constructor) {
        // 基本数据类型直接返回false
        if (instance === null || (typeof instance !== 'object' && typeof instance !==   'function')) {
            return false;
        }

        // 获取对象的原型
        let proto = Object.getPrototypeOf(instance);
        // 获取构造函数的prototype
        const prototype = constructor.prototype;

        // 沿着原型链向上查找
        while (proto !== null) {
            // 如果找到构造函数的prototype
            if (proto === prototype) {
                return true;
            }
            // 继续向上查找
            proto = Object.getPrototypeOf(proto);
        }

        return false;
    }

    // 测试
    console.log(myInstanceof([], Array)); // true
    console.log(myInstanceof([], Object)); // true
    console.log(myInstanceof([], Function)); // false
    console.log(myInstanceof(123, Number)); // false (基本类型)
    console.log(myInstanceof(new Number(123), Number)); // true (对象类型)

    // 边界情况测试
    console.log(myInstanceof(null, Object)); // false
    console.log(myInstanceof(undefined, Object)); // false

    // 函数也是对象
    console.log(myInstanceof(function() {}, Function)); // true
    console.log(myInstanceof(function() {}, Object)); // true
    ```

- **增强版（处理基本包装类型）**：

    ```javascript
    function enhancedInstanceof(instance, constructor) {
        // 处理基本数据类型
        if (instance == null) return false;

        // 如果是基本类型，转换为对应的包装对象
        if (typeof instance !== 'object' && typeof instance !== 'function') {
            instance = Object(instance);
        }

        let proto = Object.getPrototypeOf(instance);
        const prototype = constructor.prototype;

        while (proto !== null) {
            if (proto === prototype) {
                return true;
            }
            proto = Object.getPrototypeOf(proto);
        }

        return false;
    }

    // 测试基本类型
    console.log(enhancedInstanceof(123, Number)); // true
    console.log(enhancedInstanceof('hello', String)); // true
    console.log(enhancedInstanceof(true, Boolean)); // true
    ```

### 32. 如何监听对象属性的变化？（Object.defineProperty）

- **回答**：​ 使用 `Object.defineProperty()`可以监听对象属性的读取和设置。

- **基础实现**：

    ```javascript
    function defineReactive(obj, key, val) {
        // 递归处理嵌套对象
        if (typeof val === 'object' && val !== null) {
            observe(val);
        }

        Object.defineProperty(obj, key, {
            enumerable: true,
            configurable: true,
            get() {
                console.log(`获取属性 ${key}: ${val}`);
                return val;
            },
            set(newVal) {
                if (newVal === val) return;

                console.log(`设置属性 ${key}: ${val} -> ${newVal}`);

                // 如果新值是对象，继续监听
                if (typeof newVal === 'object' && newVal !== null) {
                    observe(newVal);
                }

                val = newVal;
            }
        });
    }

    function observe(obj) {
        if (typeof obj !== 'object' || obj === null) {
            return;
        }

        Object.keys(obj).forEach(key => {
            defineReactive(obj, key, obj[key]);
        });
    }

    // 使用示例
    const data = {
        name: 'Alice',
        age: 25,
        address: {
            city: 'Beijing',
            street: 'Main St'
        }
    };

    observe(data);

    // 测试
    console.log(data.name); // 获取属性 name: Alice
    data.age = 26; // 设置属性 age: 25 -> 26
    data.address.city = 'Shanghai'; // 获取属性 address -> 设置属性 city: Beijing -> Shanghai
    ```

- **完整实现（类似Vue2的响应式系统）**：

    ```javascript
    class Observer {
        constructor(data) {
            this.walk(data);
        }

        walk(data) {
            if (typeof data !== 'object' || data === null) return;

            Object.keys(data).forEach(key => {
                this.defineReactive(data, key, data[key]);
            });
        }

        defineReactive(obj, key, val) {
            const dep = new Dep();

            // 递归处理嵌套对象
            this.walk(val);

            Object.defineProperty(obj, key, {
                enumerable: true,
                configurable: true,
                get() {
                    // 依赖收集
                    if (Dep.target) {
                        dep.addSub(Dep.target);
                    }
                    return val;
                },
                set(newVal) {
                    if (newVal === val) return;

                    val = newVal;
                    // 新值是对象时继续监听
                    this.walk(newVal);
                    // 通知更新
                    dep.notify();
                }
            });
        }
    }

    // 简单的依赖收集类
    class Dep {
        constructor() {
            this.subs = [];
        }

        addSub(sub) {
            this.subs.push(sub);
        }

        notify() {
            this.subs.forEach(sub => sub.update());
        }
    }

    Dep.target = null;

    // 使用
    const reactiveData = { count: 0, user: { name: 'Alice' } };
    new Observer(reactiveData);
    ```

- **Proxy实现（ES6更强大的方式）**：

    ```javascript
    function createReactive(obj) {
        const handler = {
            get(target, key, receiver) {
                console.log(`获取属性 ${String(key)}`);
                const result = Reflect.get(target, key, receiver);

                // 如果是对象，返回代理版本
                if (result && typeof result === 'object') {
                    return createReactive(result);
                }

                return result;
            },
            set(target, key, value, receiver) {
                console.log(`设置属性 ${String(key)}: ${target[key]} -> ${value}`);
                return Reflect.set(target, key, value, receiver);
            },
            deleteProperty(target, key) {
                console.log(`删除属性 ${String(key)}`);
                return Reflect.deleteProperty(target, key);
            }
        };

        return new Proxy(obj, handler);
    }

    // 使用Proxy
    const proxyData = createReactive({
        name: 'Bob',
        scores: [90, 85, 95]
    });

    proxyData.name; // 获取属性 name
    proxyData.name = 'Charlie'; // 设置属性 name: Bob -> Charlie
    proxyData.scores.push(100); // 会触发多次get/set操作
    delete proxyData.name; // 删除属性 name
    ```

### 33. 什么是跨域？常见的解决方案有哪些？

- **回答**：​ 跨域是由于浏览器的同源策略限制，阻止不同源（协议、域名、端口任一不同）的请求。

- **同源策略示例**：

    ```js
    // 同源：http://example.com/app 和 http://example.com/api 
    // 不同源（跨域）： 
        // - http vs https (协议不同) 
        // - example.com vs api.example.com (域名不同)   
        // - localhost:3000 vs localhost:8080 (端口不同)
    ```

**常见解决方案**：  

1. **CORS（跨域资源共享） - 最推荐**    

    ```javascript
    // 服务端设置响应头
    app.use((req, res, next) => {
        // 允许的源
        res.setHeader('Access-Control-Allow-Origin', 'http://localhost:3000');
        // 允许的请求方法
        res.setHeader('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');
        // 允许的请求头
        res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization');
        // 允许携带cookie
        res.setHeader('Access-Control-Allow-Credentials', 'true');

        // 预检请求处理
        if (req.method === 'OPTIONS') {
            return res.sendStatus(200);
        }

        next();
    }); 

    // 前端正常请求
    fetch('http://api.example.com/data', {
        method: 'GET',
        credentials: 'include' // 如果需要携带cookie
    })
    .then(response => response.json())
    .then(data => console.log(data));
    ``` 

2. **JSONP（只支持GET请求）**   

    ```javascript
    // 前端实现
    function jsonp(url, callbackName) {
        return new Promise((resolve, reject) => {
            // 创建script标签
            const script = document.createElement('script');
            script.src = `${url}?callback=${callbackName}`;

            // 定义全局回调函数
            window[callbackName] = (data) => {
                resolve(data);
                document.body.removeChild(script);
                delete window[callbackName];
            };

            script.onerror = () => {
                reject(new Error('JSONP request failed'));
                document.body.removeChild(script);
                delete window[callbackName];
            };

            document.body.appendChild(script);
        });
    }   

    // 使用
    jsonp('http://api.example.com/data', 'handleData')
        .then(data => console.log(data))
        .catch(error => console.error(error));  

    // 服务端返回：handleData({ "name": "Alice", "age": 25 })
    ``` 

3. **代理服务器（开发环境常用）**   

    ```javascript
    // webpack-dev-server 配置
    module.exports = {
        devServer: {
            proxy: {
                '/api': {
                    target: 'http://api.example.com',
                    changeOrigin: true,
                    pathRewrite: {
                        '^/api': ''
                    }
                }
            }
        }
    };  

    // 前端请求（相对路径，不会跨域）
    fetch('/api/data')
        .then(response => response.json())
        .then(data => console.log(data));   

    // Nginx 配置
    // location /api/ {
    //     proxy_pass http://api.example.com/;
    //     proxy_set_header Host $host;
    //     proxy_set_header X-Real-IP $remote_addr;
    // }
    ``` 

4. **WebSocket（不受同源策略限制）**    

    ```javascript
    const socket = new WebSocket('wss://api.example.com/ws');   

    socket.onopen = () => {
        console.log('WebSocket连接已建立');
        socket.send(JSON.stringify({ type: 'message', data: 'Hello' }));
    };  

    socket.onmessage = (event) => {
        const data = JSON.parse(event.data);
        console.log('收到消息:', data);
    };  

    socket.onclose = () => {
        console.log('WebSocket连接已关闭');
    };
    ``` 

5. **postMessage（窗口间通信）**    

    ```javascript
    // 父窗口 (http://parent.com)
    const iframe = document.getElementById('myIframe');
    iframe.contentWindow.postMessage({ type: 'getUserData' }, 'http://child.com');  

    // 子窗口 (http://child.com)
    window.addEventListener('message', (event) => {
        // 验证来源
        if (event.origin !== 'http://parent.com') return;

        if (event.data.type === 'getUserData') {
            // 发送数据回父窗口
            event.source.postMessage({ 
                type: 'userData', 
                data: { name: 'Alice', age: 25 } 
            }, event.origin);
        }
    }); 

    // 父窗口接收消息
    window.addEventListener('message', (event) => {
        if (event.origin !== 'http://child.com') return;

        if (event.data.type === 'userData') {
            console.log('收到用户数据:', event.data.data);
        }
    });
    ``` 

6. **图像ping（简单单向通信）** 

    ```javascript
    function imagePing(url) {
        return new Promise((resolve, reject) => {
            const img = new Image();
            img.onload = () => resolve('成功');
            img.onerror = () => reject('失败');
            img.src = url;
        });
    }   

    // 使用（只能发送GET请求，无法获取响应数据）
    imagePing('http://api.example.com/track?action=click');
    ``` 

    **现代浏览器解决方案**：    

    ```javascript
    // 使用 Fetch API 的 mode 选项
    fetch('http://api.example.com/data', {
        method: 'GET',
        mode: 'cors', // 默认就是cors
        credentials: 'include'
    })
    .then(response => {
        if (!response.ok) throw new Error('Network response was not ok');
        return response.json();
    })
    .then(data => console.log(data))
    .catch(error => console.error('Error:', error));    

    // 使用 async/await
    async function fetchData() {
        try {
            const response = await fetch('http://api.example.com/data', {
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': 'Bearer ' + token
                }
            });

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            const data = await response.json();
            return data;
        } catch (error) {
            console.error('Fetch failed:', error);
            throw error;
        }
    }
    ```

## 1.2 自己面试总结题

### 1. js执行上下文

JavaScript 中有 **三种执行上下文（Execution Context）**，它们是 JavaScript 引擎在代码执行过程中用来管理变量、函数和作用域的抽象概念。

---

1. **全局执行上下文（Global Execution Context）**
    - **创建时机**：当 JS 脚本首次加载时创建，**整个程序只有一个**。
    - **作用**：
        - 创建全局对象（浏览器中是 `window`，Node.js 中是 `global`）
        - 将 `this` 指向全局对象（非严格模式下）
        - 初始化全局变量和函数声明（变量提升）

    ```js
    var a = 1;
    console.log(this.a); // 1（浏览器中 this === window）
    ```

    >在严格模式下，全局上下文中的 `this` 是 `undefined`。


2. **函数执行上下文（Function Execution Context）**
    - **创建时机**：每次调用一个函数时创建。
    - **特点**：
        - 每次函数调用都会创建一个新的执行上下文
        - 包含函数参数、局部变量、`arguments` 对象、`this` 绑定等
        - 函数执行完毕后，该上下文通常被销毁（除非形成闭包）

    ```js
    function foo(x) {
        var y = 2;
        console.log(x + y);
    }
    foo(3); // 创建一个新的函数执行上下文
    ```

---

3. **Eval 执行上下文（Eval Execution Context）**
    - **创建时机**：当使用 `eval()` 函数执行代码字符串时创建。
    - **特点**：
    - 很少使用，**不推荐**（安全风险、性能差、破坏作用域）
    - 在非严格模式下，`eval` 中的变量会污染当前作用域

    ```js
    var a = 1;
    eval('var b = 2; console.log(a + b);'); // 3
    console.log(b); // 2（变量泄漏到当前作用域！）
    ```

    > 在严格模式下，`eval` 有自己独立的作用域，不会污染外部。

