
# 十二、jQuery 面试题大全（附详细解答）

## 12.1 核心概念面试题

### 1. jQuery 是什么？它的主要特点是什么？

**答案：**

jQuery 是一个快速、简洁的 JavaScript 库，简化了 HTML 文档遍历、事件处理、动画和 Ajax 交互。主要特点：

1. **链式调用**​ - 可以通过点号连接多个操作
    
2. **CSS 选择器**​ - 使用与 CSS 类似的选择器语法
    
3. **跨浏览器兼容**​ - 解决不同浏览器的兼容性问题
    
4. **插件丰富**​ - 拥有大量可扩展的插件
    
5. **轻量级**​ - 压缩后约 30KB 左右
    
6. **简化 Ajax**​ - 提供简单的 Ajax 接口
    

```javascript
// 示例：jQuery 的简洁语法
$('#element').addClass('active').fadeIn().html('Hello World');
```

### 2. jQuery 中的 $ 符号是什么？

**答案：**

`$`符号是 jQuery 的别名，是 `jQuery`函数的简写形式。它是一个全局变量，代表 jQuery 函数。

```javascript
// 两者完全等价
$(document).ready(function() {});
jQuery(document).ready(function() {});

// 可以避免与其他库冲突
jQuery.noConflict();
var jq = jQuery; // 使用 jq 代替 $
```

### 3. $(document).ready() 和 window.onload 的区别？

**答案：**

| 特性  | $(document).ready() | window.onload |
| --- | --- | --- |
| **执行时机**​ | DOM 树加载完成时 | 页面所有资源（图片、CSS等）加载完成后 |
| **多次使用**​ | 可以多次调用，都会执行 | 只能定义一次，后定义的会覆盖前者 |
| **jQuery 方法**​ | 是 jQuery 的方法 | 是原生 JavaScript 事件 |
| **性能**​ | 更快，不等待图片等资源 | 较慢，等待所有资源 |

```javascript
// jQuery 方式
$(document).ready(function() {
    // DOM 就绪时执行
});

// 简写
$(function() {
    // 同上
});

// window.onload
window.onload = function() {
    // 所有资源加载完成后执行
};
```

* * *

## 12.2 选择器面试题

### 4. jQuery 有哪些基本选择器？

**答案：**

```javascript
// 1. ID 选择器
$('#myId')

// 2. 类选择器
$('.myClass')

// 3. 元素选择器
$('div'), $('p'), $('input')

// 4. 通配符选择器
$('*')

// 5. 层级选择器
$('ul > li')     // 子元素
$('ul li')       // 后代元素
$('h2 + p')      // 相邻兄弟
$('h2 ~ p')      // 所有兄弟

// 6. 属性选择器
$('input[type="text"]')
$('a[href^="https"]')  // href 以 https 开头
$('img[src$=".jpg"]')  // src 以 .jpg 结尾
$('div[class*="box"]') // class 包含 box
```

### 5. jQuery 有哪些过滤选择器？

**答案：**

```javascript
// 基本过滤
$('li:first')      // 第一个
$('li:last')       // 最后一个
$('li:eq(2)')      // 索引为2的元素
$('li:gt(2)')      // 索引大于2
$('li:lt(2)')      // 索引小于2
$('li:even')       // 偶数索引
$('li:odd')        // 奇数索引
$('li:not(.active)') // 不包含 .active 类

// 内容过滤
$('div:contains("Hello")')  // 包含文本
$('div:has(p)')             // 包含 p 元素
$('div:empty')              // 空元素
$('div:parent')             // 非空元素

// 可见性过滤
$('div:hidden')    // 隐藏元素
$('div:visible')   // 可见元素

// 表单过滤
$('input:text')     // 文本框
$('input:password') // 密码框
$('input:checkbox') // 复选框
$('input:checked')  // 选中的
$('input:disabled') // 禁用的
$('input:enabled')  // 启用的
```

* * *

## 12.3 DOM 操作面试题

### 6. jQuery 中如何创建、添加、删除元素？

**答案：**

```javascript
// 1. 创建元素
var $newDiv = $('<div>', {
    id: 'newDiv',
    class: 'box',
    text: 'Hello World',
    css: {color: 'red'}
});

// 2. 添加元素
// 内部添加
$('#parent').append($newDiv);      // 末尾
$('#parent').prepend($newDiv);     // 开头
$('#child').appendTo('#parent');   // 添加到末尾
$('#child').prependTo('#parent');  // 添加到开头

// 外部添加
$('#element').after($newDiv);      // 之后
$('#element').before($newDiv);     // 之前
$('#child').insertAfter('#element'); // 插入到之后
$('#child').insertBefore('#element');// 插入到之前

// 3. 删除元素
$('#element').remove();     // 删除元素及其数据和事件
$('#element').detach();     // 删除元素但保留数据和事件
$('#element').empty();      // 清空元素内容
$('#element').unwrap();     // 移除父元素
```

### 7. jQuery 中有哪些遍历方法？

**答案：**

```javascript
// 向上遍历
$('li').parent()           // 直接父元素
$('li').parents()          // 所有祖先元素
$('li').parentsUntil('div') // 到 div 为止的祖先
$('li').closest('div')     // 最近的匹配祖先

// 向下遍历
$('ul').children()         // 直接子元素
$('ul').find('li')         // 所有后代 li

// 同级遍历
$('li').siblings()         // 所有兄弟
$('li').next()             // 下一个兄弟
$('li').nextAll()          // 后面的所有兄弟
$('li').nextUntil('.end')  // 到 .end 前的兄弟
$('li').prev()             // 前一个兄弟
$('li').prevAll()          // 前面的所有兄弟
$('li').prevUntil('.start')// 到 .start 前的兄弟

// 过滤遍历
$('li').first()            // 第一个
$('li').last()             // 最后一个
$('li').eq(2)              // 索引为2
$('li').filter('.active')  // 过滤
$('li').not('.inactive')   // 排除
$('li').has('span')        // 包含 span 的元素
```

* * *

## 12.4 事件处理面试题

### 8. jQuery 的事件绑定有哪些方法？区别是什么？

**答案：**

```javascript
// 1. bind() - 旧版方法，已弃用
$('#btn').bind('click', handler);

// 2. on() - 推荐使用，功能最全
$('#btn').on('click', handler);
$('#container').on('click', '.item', handler); // 事件委托

// 3. click() - 快捷方法
$('#btn').click(handler);

// 4. live() - 已弃用
$('#btn').live('click', handler);

// 5. delegate() - 旧版事件委托
$('#container').delegate('.item', 'click', handler);

// 区别：
// 1. on() 可以替代 bind(), live(), delegate()
// 2. 事件委托推荐使用 on() 的第二个参数
// 3. 快捷方法如 click() 内部调用 on()
```

### 9. 什么是事件委托？如何实现？

**答案：**

事件委托是利用事件冒泡机制，将事件处理器绑定在父元素上，通过事件目标判断来执行相应操作。

**优点：**

1. 提高性能（减少事件处理器数量）
    
2. 动态元素自动绑定
    
3. 内存占用更少
    

```javascript
// 传统绑定（每个按钮都要绑定）
$('.item').on('click', function() {
    console.log($(this).text());
});

// 事件委托（只需绑定一次）
$('#container').on('click', '.item', function() {
    console.log($(this).text());
});

// 对于动态添加的元素
$('#container').append('<button class="item">New</button>');
// 传统绑定对新元素无效，事件委托有效
```

### 10. 如何阻止事件冒泡和默认行为？

**答案：**

```javascript
$('#link').on('click', function(event) {
    // 1. 阻止事件冒泡
    event.stopPropagation();
    // 或
    return false; // 同时阻止冒泡和默认行为
    
    // 2. 阻止默认行为
    event.preventDefault();
    
    // 3. 阻止事件冒泡到父元素
    event.stopImmediatePropagation();
    
    console.log('事件处理完成');
});

// 示例：表单提交
$('form').on('submit', function(e) {
    e.preventDefault(); // 阻止表单提交
    // 进行验证
    if (valid) {
        this.submit(); // 手动提交
    }
});
```

* * *

## 12.5 Ajax 面试题

### 11. jQuery 的 Ajax 方法有哪些？

**答案：**

```javascript
// 1. $.ajax() - 基础方法
$.ajax({
    url: '/api/data',
    type: 'GET',  // 或 'POST', 'PUT', 'DELETE'
    data: { id: 1 },
    dataType: 'json',
    contentType: 'application/json',
    headers: { 'Authorization': 'token' },
    beforeSend: function() {
        // 发送前
    },
    success: function(data) {
        // 成功回调
    },
    error: function(xhr, status, error) {
        // 失败回调
    },
    complete: function() {
        // 完成回调（无论成功失败）
    }
});

// 2. 快捷方法
$.get('/api/data', {id: 1}, function(data) {
    console.log(data);
}, 'json');

$.post('/api/save', {name: 'John'}, function(data) {
    console.log(data);
});

$.getJSON('/api/data.json', function(data) {
    console.log(data);
});

$.getScript('/js/plugin.js', function() {
    console.log('脚本加载完成');
});

// 3. 全局 Ajax 事件
$(document).ajaxStart(function() {
    // 显示加载指示器
    $('#loading').show();
});

$(document).ajaxStop(function() {
    // 隐藏加载指示器
    $('#loading').hide();
});

$(document).ajaxError(function(event, xhr, settings, error) {
    // 全局错误处理
    console.error('Ajax 错误:', error);
});
```

### 12. 什么是 Promise 和 Deferred？jQuery 中如何使用？

**答案：**

Deferred 是 jQuery 实现 Promise 模式的 API，用于处理异步操作。

```javascript
// 1. 创建 Deferred 对象
var deferred = $.Deferred();

// 2. 使用 Promise
function asyncTask() {
    var dfd = $.Deferred();
    
    setTimeout(function() {
        var success = Math.random() > 0.5;
        if (success) {
            dfd.resolve('成功!');
        } else {
            dfd.reject('失败!');
        }
    }, 1000);
    
    return dfd.promise();
}

// 3. 使用 Promise
asyncTask()
    .done(function(result) {
        console.log('成功:', result);
    })
    .fail(function(error) {
        console.log('失败:', error);
    })
    .always(function() {
        console.log('总是执行');
    });

// 4. $.when() 处理多个异步
$.when($.ajax('/api1'), $.ajax('/api2'))
    .done(function(resp1, resp2) {
        console.log('两个请求都成功');
    })
    .fail(function() {
        console.log('至少一个请求失败');
    });

// 5. Ajax 返回的就是 Promise
$.ajax('/api/data')
    .then(function(data) {
        console.log('成功:', data);
        return $.ajax('/api/next');
    })
    .then(function(data) {
        console.log('链式调用:', data);
    })
    .catch(function(error) {
        console.log('错误:', error);
    });
```

* * *

## 12.6 效果和动画面试题

### 13. jQuery 有哪些动画效果方法？

**答案：**

```javascript
// 1. 基本效果
$('#elem').show();      // 显示
$('#elem').hide();      // 隐藏
$('#elem').toggle();    // 切换

// 2. 滑动效果
$('#elem').slideDown();   // 向下滑动显示
$('#elem').slideUp();     // 向上滑动隐藏
$('#elem').slideToggle(); // 滑动切换

// 3. 淡入淡出
$('#elem').fadeIn();      // 淡入
$('#elem').fadeOut();     // 淡出
$('#elem').fadeToggle();  // 淡入淡出切换
$('#elem').fadeTo(500, 0.5); // 淡入到指定透明度

// 4. 自定义动画
$('#elem').animate({
    left: '+=100px',
    opacity: 0.5,
    height: 'toggle'
}, 1000, 'swing', function() {
    // 动画完成回调
});

// 5. 队列控制
$('#elem')
    .animate({left: 100}, 1000)
    .delay(500)  // 延迟
    .animate({top: 100}, 1000)
    .queue(function(next) {  // 队列操作
        $(this).css('background', 'red');
        next();  // 继续队列
    })
    .animate({width: 200}, 1000);

// 6. 停止动画
$('#elem').stop();      // 停止当前动画
$('#elem').stop(true);  // 停止所有动画
$('#elem').finish();    // 完成所有动画
$('#elem').clearQueue(); // 清空队列
```

### 14. jQuery 动画队列是什么？如何控制？

**答案：**

jQuery 为每个元素维护一个动画队列（fx 队列），可以控制动画的执行顺序。

```javascript
// 1. 动画队列示例
$('#box')
    .animate({left: 100}, 1000)  // 第一个进入队列
    .animate({top: 100}, 1000)   // 第二个进入队列
    .animate({width: 200}, 1000); // 第三个进入队列
// 按顺序执行

// 2. 查看队列
var queue = $('#box').queue();  // 获取队列数组
console.log(queue.length);       // 队列长度

// 3. 操作队列
$('#box')
    .queue(function(next) {
        // 自定义函数进入队列
        console.log('在队列中执行');
        next();  // 必须调用 next() 继续队列
    })
    .animate({height: 100}, 500);

// 4. 队列控制
$('#box')
    .clearQueue()  // 清空未执行的队列
    .stop(true)    // 停止当前动画并清空队列
    .finish();     // 立即完成所有动画

// 5. 延迟
$('#box')
    .slideUp(1000)
    .delay(2000)    // 延迟2秒
    .slideDown(1000);
```

* * *

## 12.7 工具方法面试题

### 15. jQuery 有哪些实用的工具方法？

**答案：**

```javascript
// 1. 数组/对象操作
$.each([1,2,3], function(index, value) {
    console.log(index + ': ' + value);
});

$.extend(target, obj1, obj2);  // 对象合并
$.isEmptyObject({});           // 是否空对象
$.isPlainObject({});           // 是否纯对象

// 2. 类型判断
$.type('hello');               // "string"
$.isArray([]);                 // true
$.isFunction(function(){});    // true
$.isNumeric('123');           // true
$.isEmptyObject({});          // true
$.isWindow(window);           // true

// 3. 字符串/数组操作
$.trim('  hello  ');           // 去除空格
$.grep([1,2,3,4], function(n) {
    return n > 2;              // 返回 [3,4]
});
$.map([1,2,3], function(n) {
    return n * 2;              // 返回 [2,4,6]
});
$.unique(array);               // 去重（DOM元素）
$.merge([1,2], [3,4]);        // 合并数组
$.inArray(3, [1,2,3]);        // 返回索引 2

// 4. DOM 工具
$.contains(container, contained);  // 是否包含
$.parseHTML('<div>test</div>');    // 解析 HTML
$.parseJSON('{"name":"John"}');    // 解析 JSON
$.parseXML('<root><item/></root>'); // 解析 XML

// 5. 函数工具
$.proxy(function, context);    // 绑定上下文
$.noop();                      // 空函数
$.now();                       // 当前时间戳
```

### 16. 什么是 .extend()和.fn.extend()？区别是什么？

**答案：**

```javascript
// 1. $.extend() - 扩展 jQuery 工具方法
$.extend({
    sayHello: function(name) {
        return 'Hello ' + (name || 'World');
    },
    calculate: function(a, b) {
        return a + b;
    }
});

// 使用
console.log($.sayHello('John'));  // "Hello John"
console.log($.calculate(2, 3));    // 5

// 2. $.fn.extend() - 扩展 jQuery 实例方法
$.fn.extend({
    highlight: function(color) {
        return this.css('background-color', color || 'yellow');
    },
    disable: function() {
        return this.prop('disabled', true);
    }
});

// 使用
$('button').highlight('red').disable();

// 3. 实现插件模式
(function($) {
    $.fn.myPlugin = function(options) {
        // 默认配置
        var settings = $.extend({
            color: 'red',
            text: 'Hello'
        }, options);
        
        return this.each(function() {
            $(this).css('color', settings.color)
                   .text(settings.text);
        });
    };
})(jQuery);

// 使用插件
$('#elem').myPlugin({color: 'blue', text: 'World'});
```

* * *

## 12.8 高级面试题

### 17. jQuery 中的链式调用是如何实现的？

**答案：**

链式调用是通过在每个方法执行后返回 `this`（jQuery 对象）实现的。

```javascript
// 简化实现示例
(function(window) {
    var $ = function(selector) {
        return new $.init(selector);
    };
    
    $.init = function(selector) {
        this.elements = document.querySelectorAll(selector);
    };
    
    $.init.prototype = {
        // 每个方法都返回 this
        addClass: function(className) {
            Array.prototype.forEach.call(this.elements, function(el) {
                el.classList.add(className);
            });
            return this;  // 关键：返回 this
        },
        
        removeClass: function(className) {
            Array.prototype.forEach.call(this.elements, function(el) {
                el.classList.remove(className);
            });
            return this;  // 关键：返回 this
        },
        
        css: function(property, value) {
            Array.prototype.forEach.call(this.elements, function(el) {
                el.style[property] = value;
            });
            return this;  // 关键：返回 this
        }
    };
    
    window.$ = $;
})(window);

// 使用
$('div').addClass('active').css('color', 'red').removeClass('inactive');
```

### 18. jQuery 中的 data() 方法和 attr() 方法有什么区别？

**答案：**

| 特性  | .data() | .attr() |
| --- | --- | --- |
| **存储位置**​ | jQuery 内部缓存对象 | DOM 元素属性 |
| **数据类型**​ | 任意 JavaScript 类型 | 总是字符串 |
| **性能**​ | 更高效（内存存储） | 较低（操作 DOM） |
| **数据可见**​ | 不可见（不在 HTML 中） | 可见（在 HTML 属性中） |
| **命名规范**​ | 驼峰命名 | 小写横线分隔 |
| **值变化**​ | 不会触发事件 | 可能触发事件 |

```javascript
// 示例
var $div = $('#myDiv');

// attr() - 操作 HTML 属性
$div.attr('data-id', '123');        // 设置属性
var id = $div.attr('data-id');      // 获取属性
console.log($div[0].outerHTML);     // 属性在 HTML 中可见

// data() - 操作数据缓存
$div.data('user', {id: 1, name: 'John'});  // 设置数据对象
var user = $div.data('user');              // 获取数据对象
$div.data('count', 100);                   // 设置数字
var count = $div.data('count');            // 获取数字（非字符串）

// HTML5 data-* 属性自动读取
// <div id="myDiv" data-role="admin" data-user-id="123"></div>
var role = $div.data('role');      // "admin" (自动从 data-role 读取)
var userId = $div.data('userId');  // 123 (自动从 data-user-id 转换)
```

### 19. jQuery 如何实现插件开发？有哪些最佳实践？

**答案：**

```javascript
// jQuery 插件开发模板
(function($, window, document, undefined) {
    'use strict';
    
    // 默认配置
    var defaults = {
        text: 'Hello World',
        color: '#333',
        speed: 400
    };
    
    // 插件构造函数
    var Plugin = function(element, options) {
        this.element = element;
        this.$element = $(element);
        this.settings = $.extend({}, defaults, options);
        this._defaults = defaults;
        this._name = 'myPlugin';
        this.init();
    };
    
    // 插件方法
    Plugin.prototype = {
        init: function() {
            // 初始化代码
            this.$element.text(this.settings.text)
                          .css('color', this.settings.color);
            this.bindEvents();
        },
        
        bindEvents: function() {
            var _this = this;
            this.$element.on('click.' + this._name, function() {
                _this.doSomething();
            });
        },
        
        doSomething: function() {
            this.$element.fadeOut(this.settings.speed)
                          .fadeIn(this.settings.speed);
        },
        
        updateText: function(newText) {
            this.settings.text = newText;
            this.$element.text(newText);
        },
        
        destroy: function() {
            this.$element.off('.' + this._name);
            this.$element.removeData(this._name);
        }
    };
    
    // 添加到 jQuery 原型
    $.fn.myPlugin = function(options) {
        return this.each(function() {
            if (!$.data(this, 'plugin_' + defaults._name)) {
                $.data(this, 'plugin_' + defaults._name, 
                      new Plugin(this, options));
            }
        });
    };
    
    // 允许外部访问配置
    $.fn.myPlugin.defaults = defaults;
    
})(jQuery, window, document);

// 使用插件
$('.element').myPlugin({
    text: 'Custom Text',
    color: 'red',
    speed: 1000
});

// 调用插件方法
$('.element').data('plugin_myPlugin').updateText('New Text');
```

**最佳实践：**

1. 使用立即执行函数避免污染全局作用域
    
2. 在插件名前加前缀避免冲突
    
3. 支持链式调用（返回 this）
    
4. 提供默认配置和选项
    
5. 提供公共方法供外部调用
    
6. 提供销毁方法清理资源
    
7. 使用命名空间管理事件
    
8. 缓存 jQuery 对象提高性能
    

### 20. 什么是 Sizzle 选择器引擎？

**答案：**

Sizzle 是 jQuery 的选择器引擎，从 jQuery 1.3 开始集成。它负责解析 CSS 选择器并返回匹配的 DOM 元素。

**特点：**

1. 从右到左的解析顺序
    
2. 支持 CSS 1-3 的大部分选择器
    
3. 可扩展的选择器
    
4. 高效的 DOM 查询
    

```javascript
// Sizzle 选择器示例
// 内部工作原理
$('div.container > p:first-child')

// 分解步骤：
// 1. 从右到左解析：:first-child
// 2. 然后是：p
// 3. 然后是：> 
// 4. 最后是：div.container
// 5. 返回匹配元素

// 性能比较：
$('div p a')           // 慢：后代选择器
$('div > p > a')       // 快：子选择器
$('#id .class')        // 快：ID 限制范围
$('.class', '#container') // 快：上下文限制

// 自定义选择器
$.expr[':'].newSelector = function(elem) {
    return $(elem).hasClass('special');
};
// 使用
$('div:newSelector');
```

* * *

## 12.9 性能优化面试题

### 21. jQuery 性能优化有哪些技巧？

**答案：**

```javascript
// 1. 选择器优化
// 差
$('.class')                     // 遍历整个文档
$('div .class')                 // 后代选择器

// 好
$('#id .class')                 // ID 限定范围
$('div > .class')               // 子选择器
$('.class', '#container')       // 上下文选择器

// 2. 缓存 jQuery 对象
// 差
$('#elem').show();
$('#elem').addClass('active');
$('#elem').css('color', 'red');

// 好
var $elem = $('#elem');
$elem.show().addClass('active').css('color', 'red');

// 3. 使用 find() 替代复杂选择器
// 差
$('#container .item .title');

// 好
$('#container').find('.item').find('.title');

// 4. 事件委托替代多个绑定
// 差
$('.item').on('click', handler);

// 好
$('#container').on('click', '.item', handler);

// 5. 批量 DOM 操作
// 差
for (var i = 0; i < 100; i++) {
    $('#list').append('<li>Item ' + i + '</li>');
}

// 好
var items = [];
for (var i = 0; i < 100; i++) {
    items.push('<li>Item ' + i + '</li>');
}
$('#list').append(items.join(''));

// 6. 使用 detach() 进行批量修改
var $list = $('#list').detach();
// 进行大量修改...
$('#container').append($list);

// 7. 使用简单选择器
// 差
$('input[type="text"][name="email"]:visible:enabled');

// 好
$('input:text[name="email"]').filter(':visible:enabled');
```

### 22. jQuery 和现代前端框架（Vue/React）如何结合使用？

**答案：**

```javascript
// 1. 不推荐的混用方式
// 在 Vue/React 中直接操作 DOM
mounted() {
    // 不推荐
    $('#app').hide();
    $(this.$el).addClass('active');
}

// 2. 推荐的结合方式
// 使用 jQuery 插件封装
Vue.component('jquery-plugin-wrapper', {
    template: '<div ref="container"></div>',
    props: ['options'],
    mounted() {
        // 在 Vue 生命周期中初始化 jQuery 插件
        this.$plugin = $(this.$refs.container)
            .myPlugin(this.options);
    },
    watch: {
        options: {
            deep: true,
            handler(newOptions) {
                this.$plugin.myPlugin('update', newOptions);
            }
        }
    },
    beforeDestroy() {
        // 清理
        this.$plugin.myPlugin('destroy');
    }
});

// 3. 使用 refs 而不是选择器
methods: {
    showModal() {
        // 不推荐
        // $('#modal').show();
        
        // 推荐
        this.$refs.modal.show();
    }
}

// 4. 使用自定义指令封装 jQuery
Vue.directive('tooltip', {
    bind(el, binding) {
        $(el).tooltip({
            title: binding.value,
            placement: 'top'
        });
    },
    unbind(el) {
        $(el).tooltip('destroy');
    }
});

// 使用
// <div v-tooltip="'提示信息'">Hover me</div>
```

**最佳实践：**

1. 避免在 Vue/React 中直接使用 jQuery 选择器操作 DOM
    
2. 将 jQuery 插件封装为 Vue/React 组件
    
3. 在适当的生命周期中初始化和销毁
    
4. 通过 props 传递数据，通过事件通信
    
5. 使用 refs 而不是全局选择器
    
6. 优先使用 Vue/React 的响应式系统
    
7. 将 jQuery 用于特定插件或动画效果
    

* * *

## 12.10 实际编程题

### 23. 实现一个简单的选项卡组件

```javascript
// jQuery 选项卡实现
(function($) {
    $.fn.tabs = function(options) {
        var settings = $.extend({
            activeClass: 'active',
            event: 'click',
            autoHeight: true
        }, options);
        
        return this.each(function() {
            var $container = $(this);
            var $tabs = $container.find('.tab-header > li');
            var $panels = $container.find('.tab-panel');
            
            // 显示第一个选项卡
            $tabs.first().addClass(settings.activeClass);
            $panels.first().show();
            
            // 绑定事件
            $tabs.on(settings.event, function(e) {
                e.preventDefault();
                
                var $tab = $(this);
                var index = $tab.index();
                
                // 更新选项卡
                $tabs.removeClass(settings.activeClass);
                $tab.addClass(settings.activeClass);
                
                // 更新内容
                $panels.hide();
                $panels.eq(index).show();
                
                // 自动高度
                if (settings.autoHeight) {
                    $container.height($panels.eq(index).outerHeight());
                }
            });
        });
    };
})(jQuery);

// 使用
$('#myTabs').tabs({
    event: 'mouseenter',
    activeClass: 'selected'
});
```

### 24. 实现一个 AJAX 表单提交

```javascript
// 表单提交插件
(function($) {
    $.fn.ajaxForm = function(options) {
        var settings = $.extend({
            url: '',
            method: 'POST',
            dataType: 'json',
            beforeSend: null,
            success: null,
            error: null,
            complete: null
        }, options);
        
        return this.each(function() {
            var $form = $(this);
            
            $form.on('submit', function(e) {
                e.preventDefault();
                
                var formData = $form.serialize();
                
                // 验证
                if (settings.beforeSend && 
                    settings.beforeSend.call($form, formData) === false) {
                    return false;
                }
                
                // 显示加载状态
                $form.addClass('loading');
                
                $.ajax({
                    url: settings.url || $form.attr('action'),
                    type: settings.method || $form.attr('method'),
                    data: formData,
                    dataType: settings.dataType
                })
                .done(function(response) {
                    if (settings.success) {
                        settings.success.call($form, response);
                    } else {
                        alert('提交成功！');
                    }
                })
                .fail(function(xhr, status, error) {
                    if (settings.error) {
                        settings.error.call($form, xhr, status, error);
                    } else {
                        alert('提交失败：' + error);
                    }
                })
                .always(function() {
                    $form.removeClass('loading');
                    if (settings.complete) {
                        settings.complete.call($form);
                    }
                });
            });
        });
    };
})(jQuery);

// 使用
$('#myForm').ajaxForm({
    url: '/api/submit',
    beforeSend: function(data) {
        // 验证
        if (!$('#agree').is(':checked')) {
            alert('请同意条款');
            return false;
        }
        return true;
    },
    success: function(response) {
        if (response.code === 0) {
            window.location.href = '/success';
        } else {
            alert(response.message);
        }
    }
});
```