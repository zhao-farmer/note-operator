# 九、JS场景题


## 9.1 面试题1

### 1.优化自己的面试

- 被问到场景题，怎么应对，SOP（流程化 -- SOP）

    1. 交代背景
    2. 调研方案（要有多个）
    3. 方案落地
    4. 反思，追求最优解

- 举例:当面试官问到：1000w 行表格如何渲染？

    维格表、飞书表格、钉钉表格、在线表格最求大数据量

    ```md
    1. 数据足够大，大数据公司，需要在前端展示大量数据，以往防卡顿，所以我们想要通过更好方案实现

    2. 我作为责任人，调研这部分方案

        1. dom
        2. 虚拟表格
        3. canvas table
        4. 可视区绘制算法优化
        5. canvas 结合 Webassembly 技术实现 （skia + Webassembly）

    3. 我封装了画布表格引擎，解决了上述问题，并且实现 1000W 数据加载流畅交互

    4. 在这个过程中遇到了哪些问题，我是怎么解决问题的
    ```
### 2.js 超过Number 最大值的数怎么处理？

- `Number.MAX_VALUE` 可以打印出数据

- 用到的方向：

    1. 大数据的计算：由前端计算数据得到
    2. 格式展示：后端传到前端的数据
    3. 用户输入：表格输入组件（像input输入框）

- 大数据处理
    - 金融 （数据敏感）
    - 科学计算 （小数乘小数）
    - 数据分析 （小数超出32位）

- 解决方案
    - BigInt

        ```js
        const bigNum = BigInt("1515513155151513151515151515151515")

        bigNum + bigNum
        ```
    - decimal.js

        ```js
        const decimal = new Decimal("1e+308")
        ```
    - big.js

- 比如我们用户输入场景需要限制大小
- 总结：
    1. bigint 处理大数据
    2. decimal 来处理
    3. 格式化，格式化成用户好读的格式 1000000000, 1亿
    4. 表达校验，不允许用户输入超过多少位的数字

### 3.大文件上传

背景作为佐证，不像是网上抄来的。
我之前是做AI 产品方面的，我们会涉及到用户自定义**模型**（1G 以上）

- 经常遇到一些问题：
    
    - 网络断开之后，之前传的没了
    - 传着传着，网络波动了，结果啥都没了
    - 关机了，想接着传，做不到
- 专业术语：

    - 断点续传
    - 断开重连重传
    - 切片上传

- 方案：

    - 前端切片 chunk 1024M(1048576K)，500K, const size = 1048576/500
    - 将切片传递给后端，切的片要取名： hash,index
    - 后端组合切片
- 给面试官加料

    - 前端切片：主进程卡顿，web-worker 多线程切片，处理完成后交给主进程发送
    - 切完后，将 blob ，存储到 IndexedDB，下次用户进来之后，嗅探以下是否存在未完成上传的切片，有就常识继续上传
    - websocket,实时通知，和请求序列的控制 wss
    - 整体说一下是我主导这个大文件上传器整体设计

        - 组件设计
        - props、事件、状态
        - 拖拽上传、多文件选择
        - 通用化不同文件的上传，上传统一协议

- 代码落地

    ```js
    const CHUNK_SIZE = 5 * 1024 * 1024;// 每块大小为5MB
    function uploadFile(){
        const file = document.getElementById("fileInput").files[0];
        if(!file){
            flert("请选择文件");
            return;
        }

        const totalChunk = Math.ceil(file.size/ChUNK_SIZE);
        let currentChunk = 0;
        function uploadChunk(){
            if(currentChunk >= totalCHunks){
                console.log("Upload complete");
                return;
            }

            const start = currentChunk * CHUNK_SIZE;
            const end = Math.min(start + CHUNK_SIZE,file.size);
            const chunk = file.slice(start,end)

            const formData = new FormData();
            formData.append("file",chunk);
            formData.append("chunkNumber",currentChunk + 1);
            formData.append("totalChunks",totaolChunks);

            fetch("/upload",{
                method:"POST",
                body: formData
            }).then(reponse =>{
                if(response.ok){
                    currentChunk++;
                    uploadCHunk(); // 递归调用上传下一块
                } else{
                    console.error("Chunk upload failed");
                }
            }).catch(error =>{
                console.error("Upload error",error)
            });
        }

        uploadChunk();
    }
    ```

### 4.在前端怎么实现页面截图

- 背景

    - 飞书文档，内容在列表页想要查看
    - 内容导出为 png
    - 射击类软件，出图

- 以内容导出为 png 来详解

    - 医疗，医疗单子
    - 文档，导出文档
- 方案

    - 截图
        - canvas
        - puppeteer (无头headless 浏览器)、无头表格、无头UI
        - html2canvas (canvas)
    - 上传CDN

- 落地

    - 截图工具的时候，需要考虑通用性， `selector` body(全页面截图)，.header(局部截图)、dom
    - 设计具体协议
        - 函数式、组件式
        - 隐藏canvas
    - 代码编写

        - 安装插件

            ```bash
            pnpm i html2canvas
            ```
        - 使用函数

            ```js
            function takeScreenshot(){
                const element = document.getElementById('screenshot-target');
                html2canvas(element).then(canvas =>{
                    const img = canvas.toDataURL("image/png")
                    const link = document.createElement("a");
                    link.href = img;
                    link.download = 'screenshot.png';
                    link.click();
                })
            }
            ```
### 5.H5 移动端适配问题如何解决

- 背景：项目想支持 PC、移动端
- 方案

    - 根据端来开发不同页面（成本最高）
    - 根据不同端加载不同 css 样式（可取）
    - 根据响应式，来运行不同的样式规则（**常用**）
    - style 预处理器来做

- 考虑的问题：
    1. 设置视窗，通过元信息配置 meta

        ```html
        <meta name="viewport" content="width=device-width,initial-scale=1.0">
        ```
    2. 掌握媒体查询

        ```css
        body{
            font-size:16px;
        }

        /* 在某一些设备尺寸下，这个 size 是要更改的 */
        /* 当我的尺寸 大于 xxx 小于 xxx 的时候，需要什么样式？ */
        @media(min-width:780px) and (max-width:1024px){
            body{
                font-size:18px;
            }
        }
        ```
    3. 弹性布局（flex 布局）
        - 主轴方向：flex-derection
        - 对齐方式：justify-content,align-items
        - 弹性属性：flex
    
    4. 图片响应式

        ```html
        <picture>
            <source srcset="image-large.jpg" media="(min-width:800px)">
            <source srcset="image-medium.jpg" media="(min-width:400px)">
            <img src="image-small.jpg" alt="Responsive Image">
        <picture>
        ```
    5. rem

        rem 单位的基础值 有 html 的font-size 决定

        ```css
        html{
            font-size:16px;
        }
        /* 1rem 现在等于多少 */
        .header{
            font-size:1rem; 
        }
        ```
    6. em单位

        ```css
        html{
            font-size:16px;
        }
        /* 1rem 现在等于多少 */
        .header_title{
            font-size: 0.8em 
        }
        ```
### 6.如何修改第三方的包

1. 背景

    难言之隐，来自于设计、产品、老板boss
2. 方案

    - 稳定版，直接拔下来，node_modules,直接修改
    - patch 方案

        - `patch-package`

            ```sh
            pnpm i patch-package postinstall
            ```     

        - npm 有很多钩子

            - prepare
            - postinstall
            - publish
            - ... npm hook

        - package.json

            ```json
            {
                "scripts":{
                    "postinstall":"patch-package"
                }
            }
            ```
        - 创建补丁

            ```bash
            npx patch-package rspack
            ```

            这个时候会在项目生成 `patches/rspack+1.0.0.patch`

    - fork package（自己来维护）

        直接改源码。源码改完之后，构建，发布到 npm 私服（verdaccio、阿里云效制品库）

        修改的一些内容，如果想共享给社区，给原来的作者提 PR、code review、test、合并了，你的代码就贡献给社区，提升知名度

### 7. 使用同一个连接，如何实现 PC 打开是 web应用、手机打开是一个 H5应用

1. 背景

    为了不增加ip，一个链家访问页面，想同时适配 PC、Mobile.

2. 方案

    区分 PC、Mobile，抓不要矛盾，二元对立，判断

    - 先识别端

        1. js 识别，userAgent

            ```js
            console.log(navigator.useAgent)
            // 判断
            // 正则

            function isMobile(){
                return /Mobi|Andriod/.test(navigator.useAgent)
            }
            if(isMobile()){

            }
            ```
            - react
                ```jsx
                <DeviceProvider value={{type:isMobile()}}></DeviceProvider>

                // 子组件使用
                function Header(){
                    const {type} = useContext(DeviceProvider)
                }
                ```
            - vue

                ```js
                // 非常重要的api
                provide("deviceType",isMObile())

                // 子组件使用
                const devicetype = inject("deviceType")
                ```
    - 端内容渲染器（内容加载器）

        - 媒体查询，flex布局

            ```js
            const App=()=>{
                const isDesktop= useMediaQuery({ minWidth: 1024 });
                const isMobile= useMediaQuery({ maxWidth: 1024 });
                return (

                    <div>
                        {isDesktop && (
                            <div>
                                <h1>Desktop Web Application</h1>
                                <p>This content is displayed on desktop devices.</p>
                            </div>
                        )}
                        {isMobile && (
                            <div>
                                <h1>Mobile H5 Application</h1>
                                <p>This content is displayed on mobile devices.</p>
                            </div>
                        )}
                    </div>      
                );
            }
            export default App;
            ```

### 8. 当QPS 达到峰值时，改如何处理

1. 背景

    当前端应用的QPS (每秒查询次数) 达到峰值时，会对服务器和应用的性能造成很大的压力，甚至可能导致系统崩溃，为了解决这个问题，我们需要采取一系列措施来优化和管理高并发请求

2. 方案

    - 请求限流

        全栈岗位，nodejs 为例，限流。

         <!-- rate-limit -->
         ```js
         const ratelimit = require("express-rate-limit");

         const limiter = rateLimit({
            windowMs:60 * 1000,
            max: 100,
            message: "你搞的太多了，省省，待会儿再来"
         })
         ```
    - 请求合并

        短时间内的请求进行合并，一次降低服务端压力

        - debounce
        - throttle

        ```js
        function debounce(func,delay){
            let timout;
            return function(...args){
                clearTimeout(timeout);
                timeout = setTimeout(()=>func.apply(this,args),delay)
            }
        }

        const fetchData = debounce(()=>{
            fetch("api/data")
                .then(response => response.json())
                .then(data =>{
                    console.log(data);
                })
                .catch(error =>{
                    console.error("Fetch error:",error)
                })
        })

        document.getElementById("fetchButton").addEventListener("click",fetchData);
        ```
    - 请求缓存

        react、vue

        **swr** 里面针对于请求的内容缓存
        请求参数、请求方法、请求逻辑依赖的内容没有花生变化，直接命中缓存

    - 任务队列

        针对于请求，我们设计一个任务队列，通过滑动窗口

        任务 job,视频转码 后端请求 使用 `bull`

        ```js
        const Bull = require("bull")
        const tackQueue = new Bull("task queue");

        app.post("/api/startTask",(req,res)=>{
            const taskId = Date.now().toString();
            taskQueue.add({taskId})
            res.send({taskId});
        })

        app.get("/api/taskStatus/:taskId",(req,res)=>{
            const taskId = req.params.taskId;
            // 检查任务章台并返回
            taskQueue.getJob(taskId).then(job => {
                if(job){
                    res.send({status:job.finished()?"completed":"pending"});
                }else{
                    res.send({status:"not found"})
                }
            })
        })

        /// 处理队列中的任务
        taskQueue.process((job,done)=>{
            // 模拟耗时操作
            setTimout(()=>{
                done();
            },10000); //10秒钟
        })
        ```

### 9. 如何实现网页加载进度条

怎么拿到进度
- 方法兼容性
- fetch、ajax
怎么绘制进度
- dom
- svg

1. 背景

    为了提升整站用户加载等待提亚，考虑使用加载进度条反馈给用户加载工程

2. 方案

    - Ajax 拿到进度，svg/dom 绘制进度

        ```html
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>Loading Progress Bar Example</title>
            <style>
                #progress-bar{
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 4px;
                    background-color: #29d;
                    transition: width 0.4s ease;
                    z-index: 9999;
                }
            </style>
        </head>
        <body>
            <div id="progress-bar"></div>

            </div>
            <script>
                function loadResource(url){
                    const xhr=new XMLHttpRequest();
                    xhr.open('GET',url,true);
                    xhr.onprogress=function(event){
                        if(event.lengthComputable){
                            const percentComplete=(event.loaded/event.total)*100;
                            document.getElementById('progress-bar').style.width=percentComplete+'%';
                        }
                    };
                    xhr.onload = function() {
                        if(xhr.status === 200){
                            document.getElementById('progress-bar').style.width='100%';
                            setTimeout(() => {
                                document.getElementById('progress-bar').style.width='0%';
                            }, 500);
                        }
                    };
                    xhr.send();
                }

                window.addEventListener('load',function(){
                    loadResource('https://jsonplaceholder.typicode.com/posts');
                });
            </script>
        </body>
        </html>
        ```

        fetch 可不可以，不可以

    - 框架页面加载

        - React 页面加载过度进度条

            ```jsx
            import React,{useEffect} from 'react';
            import { BrowerRouter as Router,Route,Switch,useHistory} from "react-router-dom";
            import NProgress from "nprogress"
            import "nprogress/nprogress.css"

            const Home = () => <div>Home</div>;
            const About = () => <div>About</div> ；

            const App = () =>{
                const history = useHistory();

                useEffect(()=>{
                    NProgress.configure({ showSpinner:false });

                    const handleStart = () =>{
                        NProgress.start()
                    };
                    const handleStop = () => {
                        NProgress.done()
                    }

                    history.listen(()=>{
                        handleStart();
                        handleStop();
                    })

                    return () =>{
                        history.listen().cancle()
                    }

                },[history])

                return (
                    <Router>
                        <Switch>
                            <Route path="/" exact component = {Home}>
                            <Route path="/about" exact component = {About}>
                        </Switch>
                    </Router>
                )
            }
            ```
        - Vue 

            通过借助导航守卫

            ```js
            const router = createRouter() // vue-router

            // 全局导航守卫
            router.beforeEach()
            ```

### 10. 了解过前端水印功能

1. 背景

    为了保证用户隐私，数据相对安全，实现水印，飞书（名字）WaterMark
    - 文档保护
    - 图片保护
    - 视频保护

2. 方案

    - 明水印(肉眼可见的水印)

        1. 背景水印

            ```html
            <!DOCTYPE html>
            <html lang="en">
            <head>
                <meta charset="UTF-8">
                <meta name="viewport" content="width=device-width, initial-scale=1.0">
                <title>Page Watermark</title>
                <style>
                    body{
                        background-image:url('data:image/svg+xml;base64,<BASE64_ENCODED_SVG>');
                        background-repeat:repeat;
                        opacity: 0.1;
                    }
                </style>
            </head>
            <body>
                <h1>Watermark Content</h1>
                <p>This page has a watermark background.</p>
            </body>
            </html>
            ```

            内容生成，`svg`

            ```js
            function createWatermarkSVG(text){
                const svg = `
                   <svg xmlns="http://www.w3.org/2000/svg" width="200" height="200" viewBox="0 0 200 200">
                        <text x="50%" y="50%" dy=".35em" text-anchor="middle" fill="rgba(0,0,0,0.1)" font-size="30" tranform="rotate(-45, 100, 100)">
                            ${text}
                        </text>
                    </svg>
                `
                return `data:image/svg+xml;base64,${btoa(svg)}`
            }

            const watermarkText = "知识库"
            document.body.style.background = `url('${createWatermarkSVG(watermarkText)}')`
            ```
        2. 图片水印

            ```html
            <!DOCTYPE html>
            <html lang="en">
            <head>
                <meta charset="UTF-8">
                <meta name="viewport" content="width=device-width, initial-scale=1.0">
                <title>Image Watermark</title>
            </head>
            <body>
                <canvas id="canvas" style="display: none;"></canvas>
                <img id="sourceImage" src="source-image.jpg" alt="Source">
                <img id="watermarkedImag" alt="Watermarked Image">

                <script>
                    function addWatermark(imageSrc, watermarkText) {
                        const canvas = document.getElementById('canvas')
                        const ctx = canvas.getContext('2d')
                        const image = new Image()   
                        image.src = imageSrc
                        image.onload = () => {  
                            canvas.width = image.width
                            canvas.height = image.height
                            ctx.drawImage(image, 0, 0)
                            ctx.font = '48px serif'
                            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)'
                            ctx.fillText(watermarkText, 20, image.height - 60)
                            const watermarkedImage = document.getElementById('watermarkedImag')
                            watermarkedImage.src = canvas.toDataURL()
                        }
                    }

                    const imageSrc = document.getElementById('sourceImage').src;
                    addWatermark(imageSrc, 'Sample Watermark');
                </script>
            </body>
            </html>
            ```
    - 暗水印 (肉眼不可见的)

        黑科技，将信息写入刀文件二进制代码里面

        二进制的编辑处理，保证文件不变化，暗水印服务

### 11. web 应用中如何对静态资源加载失败的场景做降级处理

1. 场景

    - 图片
    - css 文件
    - javascript 文件
    - CDN
    - 字体文件
    - 服务端渲染失败

2. 解决方案

    - 图片处理
        - 占位符，alt 来描述图片
        - 重试机制 (404、无权限)
        - 上报
            ```html
            <img src="image.jpg" alt="Example Image" onerror="handleImageError(this)">
            ```

            ```js
            function handleImageError(image){
                image.onerror = null; // 方式死循环
                image.src = `placeholder.jpg`; // 使用占位图
            }
            ```
    - css 文件处理

        资源没加载到

        1. 关键性样式，通过内联
        2. 备用样式
        3. 上报

        ```html
        <head>
            <style>
                /* 内联关键样式 */
                body {
                    font-family:Arial,sans-serif;
                }
            </style>
            <link rel="stylesheet" href="styles.css" onerror="handleCssError()">
        </head>
        ```

        ```js
        function handleCssError(){
            // 加载备用样式
            const fallbackCss = document.createElement("link");
            fallbackCss.rel = 'stylesheet';
            fallbackCss.href = "fallback-styles.css";
            document.head.appendChild(fallbackCss)
        }
        ```
    - javascript 文件处理

        网络异常，导致资源没加载

        1. 内联脚本
        2. 备用脚本处理
        3. 上报

    - CDN 处理
        1. 本地备份，如果 cdn 出错了，就使用本地备份
        2. 动态切换，切到另一个有用的 cdn 服务

        ```html
        <head>
            <script src="https://cdn.example.com/library.js" onerror="handleCdnError()"></script>
        </head>
        ```

        ```js
        handleCdnError(){
            // 加载本地备份
            const fallbackScript = document.createElement('script');
            fallbackScript.scr = 'local-library.js';
            document.head.appendChild(fallbackScript);

            // 或者动态切换到另一个CDN
            // const alternativeCdn = doucument.createElement("script");
            // alternativeCdn.src = "https://cdn.alternative.com/library.js";
            // document.head.appendChild(alternativeCdn);
        }
        ```

    - 字体

        1. 使用降级字体 apple、微软雅黑
        2. webfont 处理字体问题

            ```css
            @font-face{
                font-family: 'CustomFont';
                src: url("customfont.woff2") format('woff2');
                font-display:swap; /* 使用 swap策略 */
            }

            body{
                font-family:'CustomFont',Arial,sans-serif;
            }
            ```
    - ssr 方面

        1. 降级的 html 用作渲染
        2. 切换为 CSR

### 12. 怎样实际一个全栈请求好事统计工具

1. 背景

    通过这个统计工具，可以更清晰看到整个站点性能情况，首屏加载时间（FP/FCP）,

    1. 监控请求耗时：HTTP、中间件，axios
    2. 前端监控：监控整个请求，记录耗时数据
    3. 后端监控：后端记录
    4. 数据汇总：数据清洗加工，数据可视化，可视化图表

2. 方案

    ```js
    (function(){
        const originalXhrOpen = XMLHttpRequest.prototype.open;
        XMLHttpRequest.prototype.open = function(...args){
            this._startTime = performance.now();
            this.addEventListener("load",function(){
                const duration = performance.now() - this._startTime;
                console.log(`XHR ${args[1]} took ${duration}ms`);
                reportRequestDuration(args[1],duration,"XHR");
            })
            originalXhrOpen.apply(this,args);
        };
        
        const originalFetch = window.fetch;
        window.fetch = async function(...args){
            const startTime = performance.now();
            const reponse = await oraiginalFetch.apply(this,args);
            const duration = performance.now() - startTime;
            console.log(`Fetch ${args[0]} took ${duration}ms`)
            reportRequestDuration(args[0],duration,"Fetch");
        }

        // 通过fetch 上报
        function reportRequestDurution(url, durution, type){
            // Report to backend or log it loaclly
            fetch('/api/report-request-duration'.{
                method: "POST",
                headers: {"Content-Type": 'application/json'},
                body: JSON.stringify({url,duration,type})
            })
        }

        // 通过图片进行上报
        const img = document.createElement('img')
        img.src = "/getRequetInfo"
    })();
    ```

### 13. 请说说你对函数式编程思想的理解

函数式编程，基本概念

1. 基本概念

    - 函数为一等公民，函数封装的方式解决问题
    - 函数概念
        1. 纯函数，没有任何副作用，相同输入（参数）得到相同输出（返回值）

            ```js
            // 纯函数示例
            function add(a,b){
                return a + b;
            }
        2. 不可变性
        3. 高阶函数，函数柯里化

            ```js
            // 高阶函数示例
            function withLogging(fn){
                return function(...args){
                    console.log('Arguments:',args);
                    const result = fn(...args);
                    console.log("Result:",result);
                    return result;
                }
            }

            const addWithLoggging = withLogging(add);
            addWithLoggging(1,2); // logs: Argunments: [1,2], Result: 3
            ```
        4. 函数组合，类似于面向对象继承

            ```js
            // 函数组合示例
            const compose = (...fns) => (x) => fns.reduceRight((v,fn)=>fn(v),x);

            const double = x => x * 2;
            const square = x => x * x;

            const doubleAndSquare = componse(square,double);
            console.log(doubleAndSquare(3)) //36
            ```

            ```js
            const useName = () => 'heyi'
            const useAge = () => 18

            const usePerson = () =>{
                const name = useName()
                const age = useAge()

                return {
                    name,
                    age
                }
            }
            ```

2. 总结优点

    1. 可测试性，更好写单元测试
    2. 可维护性
    3. 并发
    4. 简洁


## 9.2 自己总结的场景题

### 1. 如何优化首屏加载速度

### 2. 微前端

### 3. 微任务与宏任务