# 五、Vue

## 5.1 vue基础题

### 1. 组件间的通信方式

1. 通信方式分为四大类
    1. 父子组件通信：最直接、最常用。
    2. 跨代/兄弟组件通信：需要“绕开”组件层级。
    3. 全局状态管理：适用于大型应用，集中管理状态。
    4. 组件实例访问（通常不推荐用于通信）：作为应急方案。

2. 第一类：父子组件通信

    1. props (父 -> 子)

        - **作用**：父组件向子组件传递数据
        - **特点**：单项数据流、父组件的数据更新会流向子组件，但子组件不能直接修改 props 。 如果需要修改，应由子组件触发事件，由父组件来修改。
        - **用法**：

            ```vue
            <!-- 父组件 -->
            <ChildComponent :message="parentMessage" />

            <!-- 子组件 -->
            <script>
                export default {
                props: ['message'] // 或使用对象形式定义类型
            }
            </script>
            ```

    2. $emit 事件 (子 -> 父)

        - **作用**：子组件向父组件传递数据或触发动作。
        - **特点**：子组件触发事件，父组件监听并处理。
        - **作用**：

            ```vue
            <!-- 子组件 -->
            <button @click="$emit('some-event', eventData)">点击</button>
            <!-- 或者在方法中 -->
            <script>
            export default {
                methods: {
                    sendData() {
                        this.$emit('custom-event', this.someData);
                    }
                }
            }
            </script>

            <!-- 父组件 -->
            <ChildComponent @custom-event="handleCustomEvent" />
            ```

    3. $attrs 属性穿透

        - **作用**：实现“属性透传”。当父组件传递了 props 或事件，但子组件没有显式声明时，这些属性和事件会保存在 $attrs和 $listeners中，可以手动绑定到更深层的子组件上。
        - **场景**：创建高阶组件或封装第三方组件时非常有用。
        - **vue3用法**：

            ```vue
            <!-- 父组件 -->
            <BaseInput label="用户名" v-model="username" required @focus="onFocus" />

            <!-- 子组件 BaseInput.vue -->
            <template>
                <label>
                    {{ label }}
                    <input v-bind="$attrs" :value="modelValue" @input="$emit('update:modelValue', $event.target.value)" />
                </label>
            </template>
            <script>
            export default {
                props: ['label', 'modelValue'], // 声明了的 props 不会进入 $attrs
                emits: ['update:modelValue']
            }
            </script>
            ```
            >上例中，required和 @focus会自动透传到内层的 `<input>`元素上。

2. 第二类：跨代/兄弟组件通信（间接）

    1. Event Bus（事件总线）

        - **作用**：创建一个全局的 Vue 实例，作为中央事件总线，允许任何组件监听和触发事件。
        - **特点**：简单快捷，适用于小型应用。但在中大型应用中，事件流会变得难以维护。
        - **用法**：

            ```js
            // eventBus.js
            import Vue from 'vue';
            export const EventBus = new Vue();
            ```

            ```vue
            <!-- 组件 A （触发事件） -->
            <script>
            import { EventBus } from './eventBus.js';
            export default {
                methods: {
                    sendMessage() {
                        EventBus.$emit('message-sent', this.message);
                    }
                }
            }
            </script>

            <!-- 组件 B （监听事件） -->
            <script>
            import { EventBus } from './eventBus.js';
            export default {
                created() {
                    EventBus.$on('message-sent', (message) => {
                        console.log('收到消息：', message);
                    });
                },
                // 重要：在组件销毁前移除监听，避免内存泄漏
                beforeUnmount() { // Vue 3, Vue 2 中用 beforeDestroy
                    EventBus.$off('message-sent');
                }
            }
            </script>
            ```
    2. provide/ inject（提供/注入）

        - **作用**：祖先组件向其所有后代组件注入一个依赖，无论层级多深。
        - **特点**：主要用于开发高阶组件/插件，日常业务中应谨慎使用，因为数据源不明确，降低了组件的可复用性。
        - **用法**：

            ```vue
            <!-- 祖先组件 -->
            <script>
            export default {
                provide() {
                    return {
                        theme: this.themeData, // 提供非响应式数据
                        user: Vue.computed(() => this.currentUser) // Vue 3 提供响应式数据
                    };
                },
                data() {
                    return {
                        themeData: 'dark',
                        currentUser: 'Alice'
                    };
                }
            }
            </script>

            <!-- 任意后代组件 -->
            <script>
            export default {
                inject: ['theme', 'user'],
                mounted() {
                    console.log(this.theme); // 'dark'
                    console.log(this.user); // 'Alice'
                }
            }
            </script>
            ```
3. 第三类：全局状态管理

    Vuex(vue2官方推荐)/Pinia(vue3官方推荐)

    - **作用**：集中式存储管理应用的所有组件的状态。
    - **特点**：适用于中大型应用。有明确的规则来追踪状态的变化，使得代码更易维护和调试。

    - **核心概念（Vuex）**:
        - State: 驱动应用的数据源。
        - Getters: 基于State的计算属性。
        - Mutations: 唯一更改State的方法，同步。
        - Actions: 提交Mutations,可以包含任意异步操作。
    - **用法**：

        ```js
        // store/index.js
        import { createStore } from 'vuex';
        export default createStore({
            state: {
                count: 0
            },
            mutations: {
                increment (state) {
                    state.count++
                }
            },
            actions: {
                incrementAsync ({ commit }) {
                    setTimeout(() => {
                        commit('increment')
                    }, 1000)
                }
            }
        });
        ```

        ```vue
        <!-- 任意组件 -->
        <script>
        export default {
            computed: {
                count() {
                    return this.$store.state.count;
                }
            },
            methods: {
                increment() {
                    this.$store.commit('increment');
                },
                incrementAsync() {
                    this.$store.dispatch('incrementAsync');
                }
            }
        }
        </script>
        ```
    - vuex与pinia的区别

        - vuex基于选项式API设计;Pinia基于组合式API设计，同时支持选项式
        - vuex有 State、Getters、Mutations、Actions 核心;Pinia有State、Getter、Actions
        - vuex通过mutation修改 state,pinia直接在actions中修改state
        - vuex对typescript支持一般;Pinia 支持非常好，有完整的类型推断
        - vuex区分多个store需要命名空间，pinia的多个store天然分离
        - vuex 体积相对较大，pinia更轻量级约1k

    
4. 第四类：组件示例访问（应急方案，不建议用于常规通信）

    直接访问组件示例，破坏了组件的封装性，使代码难以理解和维护。

    1. `$parent`/`$children`/`$root`

        - $parent: 访问父组件实例
        - $children: 访问子组件实例（数组，顺序不保证）
        - $root: 访问根实例

    2. ref
        - **作用**：给子组件或DOM元素注册引用信息，从而直接操作子组件或DOM.
        - **场景**：主要用于直接操作DOM(如聚焦输入框)或调用子组件内的方法，不应用于组件间的数据传递。

### 2. 组件的声明周期

声明周期分为四个主要阶段：创建、挂载、更新、销毁。

1. 阶段一：创建

    这个阶段主要初始化Vue实例，处理数据观测和事件/侦听器的配置。

    1. new Vue()

        - 描述：开始初始化事件和声明周期。此时，实例刚刚被创建，数据观测和事件/侦听器都还未设置。
    2. beforeCreate
        - **描述**：在实例初始化之后、数据观测和event/watcher事件配置之前被同步调用
        - **此时**：data、methods、computed等都还无法访问。
        - **常用场景**：很少使用，可以用一些不依赖数据的初始化，例如加载动画。
    3. created
        - **描述**：在实例创建完成后被同步调用。此时，数据观测、属性和方法的运算，一级watch/event事件回调已完成设置。
        - **此时**：可以访问到data中的数据，可以调用methods中的方法。但挂载阶段还未开始，$el属性（即模板对应的DOM）目前尚不可用
        - **常用场景**：非常重要！常用于发起异步请求，获取数据（例如从API获取数据）。因为此时能访问到数据，并且能最早发起请求，减少用户等待时间。

2. 阶段二：挂载

    1. beforeMount

        - **描述**：在挂载开始之前被调用。相关的render函数首次被调用，编译模板已完成，但尚未将模板渲染成真实的DOM并替换el指定的元素
        - **此时**：模板一再内除编译好，但页面上还看不到内容。
        - **常用场景**：较少使用
    2. mounted
        - **描述**：实例被挂载后调用。此时，el被新创建的vm.$el替换。DOM已经生成并插入到页面中。
        - **此时**：可以访问和操作DOM元素，注意：如果数据是异步获取的，不能保证子组件也被挂载，如果需要操作子元素，可以使用this.$nextTick.
        - **常用场景**：非常常用！用于需要操作DOM的库的初始化，例如初始化图表（Echats）、地图，或监听DOM事件。

3. 阶段三：更新
    当响应式数据（如data中的属性）发生变化时，会触发更新流程

    1. beforeUpdate

        - **描述**：在数据发生改变后、虚拟DOM重新渲染和打补丁之前调用。
        - **此时**：数据已经是新的了，但页面（视图）还是旧的。页面数据和data中的数据尚未保持同步。
        - **常用场景**：可以在现有DOM将要被更新之前访问它，例如，手动一处已添加的事件监听器。
    2. updated
        - **描述**：在数据更改导致的虚拟DOM重新渲染和打补丁之后调用。
        - **此时**：组件DOM已经更新，可以执行依赖于新DOM的操作。注意：在此钩子里修改状态可能会导致无限的更新循环！
        - **常用场景**：当数据更新后需要操作新DOM时使用。同样，要操作子组件最好使用this.$nextTick.

4. **阶段四：销毁**

    当调用vm.$destory()或路由切换时，组件实例会被销毁

    1. beforeUnmount(vue2 beforeDestory)
        - **描述**：在实例销毁之前调用。此时，实例仍然完全可用。
        - **常用场景**：非常重要！用于执行清理任务，例如清除定时器，取消未完成的网络请求、解绑自定义的全局事件监听器，防止内存泄露。

    2. unmounted(vue2 detroyed)

        - **描述**：在实例销毁后调用。Vue实例的所有指定都被解绑，所有事件监听器被一处，所有子实例也都被销毁。
        - **此时**：实例的所有东西都已解除绑定，无法使用。
        - **常用场景**：可用于通知其他组件当前组件已销毁，或进行一些最终的清理工作。

| 钩子            | 阶段  | 常用用途                       |
|---------------|-----|----------------------------|
| created       | 创建后 | 发起 AJAX/fetch 请求，初始化非响应式数据 |
| mounted       | 挂载后 | 操作 DOM，初始化第三方库（如图表、地图）     |
| updated       | 更新后 | 数据变化后操作 DOM（慎用，避免循环）       |
| beforeUnmount | 销毁前 | 清理工作（定时器、请求、事件监听器），防止内存泄漏  |

### 3. vue2与vue3的区别

1. 加载与代码组织方式

    1. vue2 的 Options API

        代码通过不同的选项（如 data,methods,computed,watch）来组织，功能逻辑被拆分到不同的部分

        缺点：当一个组件的功能很复杂时，与同一个功能线管的代码（数据、方法、计算属性等）会分散在各个选项中，导致代码难以阅读和维护。这就是所谓“碎片化”问题。

    2. vue3 的composition API

        代码通过逻辑功能来组织，所有与某个功能相关的代码（响应式数据、方法、计算属性、声明周期等）都可以封装在一个函数（如 useCounter） 或几种卸载setup函数中。

        Composition API的优势：

        - 根号的逻辑服用与封装：可以将功能提取为可重用的组合式函数
        - 更灵活的代码组织：相关功能的代码聚集在一起，易于维护。
        - 更好的 TypeScript 支持：源于其函数式的风格，类型推断更友好
        - 更小的生产包：得益于Tree-shaking,未使用的AOU不会被最终打包

2. 响应式系统：Object.defineProperty vs Proxy

    1. vue2 的 Object.defineProperty

        - 原理：递归遍历data对象的所有属性，使用Object.defineProperty将他们转换为 getter/setter
        - 局限性：
            1. 无法监测对象属性的添加或删除：必须使用Vue.set 或 Vue.delete.
            2. 无法监测数组索引和长度的直接设置：例如 `vm.items[index] = newValue` 或 `vm.items.length = newLength` 不是响应式的。需要用到数组的编译方法 （如：push,pop,splice） 或 Vue.set.
            3. 初始化性能：对于深层嵌套的对象，递归转换会造成性能开销。
    2. Vue3 的 Proxy
        - 原理：直接代理整个对象，不需要遍历属性。它是元编程级别对对象进行拦截。
        - 优势：
            1. 全面：可以监测属性的添加、删除，一级数组索引和长度的变化
            2. 性能更好：惰性代理，只在访问时才会递归转换嵌套对象。
            3. 支持Map、Set等：可以响应式地代理更多数据类型。

3. 性能优化

    1. 虚拟DOM重新与优化：
        - 编译时优化：编译器会生成更好地虚拟DOM代码，在编译时标记静态节点，并在Diff过程中跳过它们。
        - Block Tree 和 Patch Flag：动态节点被标记，Diff算法只比较可能变化地节点，大幅提升更新性能
    2. Tree-shaking：如果你不使用某些功能（v-model指定、transition组件间）。他们最终不会打包到生产环境中，使得项目体积更小
    3. Fragment(片段)：组件模板不再需要单个根元素，可以减少不必要地包装DOM节点。

4. 其他重要区别

    1. vue2一个组件上只有一个v-model vue3可以绑定多个v-model 如 v-model:title,v-model:content
    2. vue3不再支持 @keyup.数字类型，推荐使用 kebab-case名称，如：keyup.enter
    3. vue3不再支持事件总线
    4. vue3不再支持过滤器



## 5.2 vue组件相关

### 1. v-if v-for 优先级

```vue
<!-- vue2可以运行，vue3会报错 -->
<li v-for="todo in todos" v-if="!todo.isComplete">{{todo.name}}
</li>

<!-- 将循环放到外层 -->
<template v-for="todo in todos">
    <li v-if="!todo.isComplete">{{todo.name}}</li>
</template>
```

vue2: v-for > v-if

vue3: v-for < v-if

### 2. 双向绑定原理和使用

1. v-model 双向绑定指令  @input(用于表单上)

2. 双向绑定地原理

    vue地双向绑定基于响应式系统实现地。其核心可以概括为三大组成部分

    1. 数据劫持/响应式化：追踪数据地变化
    2. 依赖收集：知道哪些视图或计算依赖于这些数据
    3. 发布-订阅：数据发生变化时，通知所有依赖进行更新
3. v-model 修饰符

    - .lazy 将input事件改为change事件（在失去焦点或按回车后更新）
    - .number：将用户输入自动转换为数字
    - .trim：自动过滤用户输入地首尾空白字符


### 3. watch与computed

1. coumputed 计算属性
    - 设计目的：用于声明式地定义依赖其他状态地派生状态
    - 核心特定：
        - 缓存机制：只有当依赖地响应式数据发生变化时，才会重新计算。
        - 惰性求值：只有被访问时才会计算（如果依赖没变，直接返回缓存值）
        - 同步返回：必须返回一个值
2. watch 侦听器
    - 设计目的：用于在状态变化时执行副作用，如异步操作、DOM操作等
    - 核心特性：
        - 惰性执行：默认不会立即执行，已有依赖变化时才执行
        - 获取新旧值：可以拿到变化前和变化后地值
        - 支持异步：回调函数中可以执行异步操作
        - 精细控制：可以控制执行时机


### 4. Vue.nextTick

Vue.nextTick是一个全局 API，用于在 下一次 DOM 更新周期之后执行延迟回调。通俗地说，它让你在 Vue 完成 DOM 更新后执行一些代码。


Vue 是异步指定DOM更新

1. 修改响应式数据后，DOM不会立即更新。所有更新操作都会放入任务队列，并在下一个时间循环中批量执行（就是数据）。
2. 原因：在同一个函数下，当变量数据修改后，再次修改这个变量，为了避免重复渲染，第一次修改地变量不应该加载到dom上。
3. 所有同步任务都在主线程执行,同步任务执行完成后 执行queue

### 5. Teleport

将任意组件地DOM插入到其他执行地组件层 model message

- to 属性
- disabled 是否瞬移到目标上

```vue
<template>
    <teleport to="#target">
        <div>123</div>
    </teleport>
</template>

<!-- 将数据传入到这个id为target上-->
<body>
    <div id="target"></div>
</body>
```

## 5.2 vue其他题

### 1. Vue模板渲染原理

Vue模板渲染过程分为三个核心步骤：编译、渲染、挂载\更新

1. 模板编译

    vue的模板本身只是一些字符串，浏览器无法直接理解。编译器的任务是将这些模板字符串转换可执行的 javascript 代码，即渲染函数

    1. 解析：将模板字符串解析成一个**抽象语法树（AST）**

        过程：编译器像读取文章一样，逐词分析模板中的HTML变迁、属性、文本和Vue指令。他会理解模板的结构，并生成一个用javascript对象描述的属性结构（AST）。这个对象定义了每个节点的类型、属性、子节点等信息。
    2. 转换：对AST进行优化和处理。

        处理指令：编译器将Vue的特定语法 如：v-if,v-for 变换为对应javascript逻辑
    3. 代码生成：将处理好对的AST转换字符串形式的渲染函数代码

        结果：生成一个或多个render函数
2. 渲染与虚拟DOM

    渲染函数被执行，会生成一个描述DOM的虚拟DOM节点。

3. 挂载与更相信

    将新旧DOM树进行对比，然后更高效地更新DOM


### 2. vue中地 template 与 jsx

1. vue模板 一种基于HTML地声明式语法，加入了Vue特有地指令如 v-if v-for @click等，使用的插件是 vue-loader、vue-template-compiler

2. jsx文件 一种javascript地语法扩展，允许在JS代码中直接编写类似HTML地结构 jsx-> @babel-plugin-tansform-vue-jsx

### 3. SSR

CSR 时浏览器渲染，DOM节点只包含id是app的div（`<div id="app"></div>`）。SSR 是服务端渲染（包含所有地DOM节点）

SSR地好处
1. SEO 能够让搜索引擎去爬虫，获取页面信息，匹配搜索。
2. 白屏时间更短，HTML DOM CSS 都已加载，只要获取数据就可以




1. SSR面试模拟对话
    - 面试官：先简单介绍一下你对SSR的理解
    - 求职者：SSR就是服务端渲染，与传统客户端渲染不同，它是在服务器端生成完整的HTML页面，然后直接发送给浏览器。这样能显著提升首屏加载速度，改善SEO效果，特别适合内容型网站。

    - 面试官：能说说SSR和CSR的主要区别吗？
    - 求职者：好的，主要区别体现在几个方面：

        - CSR (客户端渲染)：渲染位置在浏览器端，首屏时间慢，需下载JS后渲染
        - SSR (服务端渲染):渲染位置在服务器端，直接显示HTML，首屏时间较快，SEO友好,服务器压力会比较大

    - 面试官：SSR具体能带来哪些性能提升？
    - 求职者：主要体现在三个关键指标上：
        - FP（首次绘制）：从2-3秒缩短到0.5-1秒
        - FCP（首次内容绘制）：用户能更快看到主要内容
        - TTI（可交互时间）：虽然可能稍晚，但感知性能更好
       

### 4. MVVM

- 面试官：谈谈你对MVVM的理解
- 求职者：我对MVVM的理解是：它是一种架构模式，将应用分为Model、View、ViewModel三层。

    Model负责数据和业务逻辑，View负责UI展示，ViewModel作为桥梁，通过数据绑定实现View和Model的自动同步。这种模式最大的优势是解耦和可维护性。

- 面试官：能具体说说数据绑定是如何工作的吗？
- 求职者：好的。数据绑定的核心是响应式系统。以Vue.js为例，它通过Object.defineProperty或Proxy来劫持数据对象的属性。
    
    当ViewModel中的数据发生变化时，会通知所有依赖这个数据的视图组件进行更新。反过来，当用户在View中输入时，通过v-model等指令自动更新ViewModel中的数据。这就实现了双向数据绑定。
