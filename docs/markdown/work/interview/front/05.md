# 五、HTML


## 5.1 基础与语义化

### 1. HTML5 新增语义化标签及其意义

**回答**：  
HTML5新增的语义化标签让文档结构更清晰，有助于SEO和无障碍访问。

**代码示例**：

```html
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>语义化示例</title>
</head>
<body>
    <!-- 页眉 -->
    <header>
        <h1>网站标题</h1>
        <nav>
            <ul>
                <li><a href="#home">首页</a></li>
                <li><a href="#about">关于</a></li>
            </ul>
        </nav>
    </header>

    <!-- 主要内容 -->
    <main>
        <article>
            <header>
                <h2>文章标题</h2>
                <time datetime="2024-01-15">2024年1月15日</time>
            </header>
            <section>
                <h3>章节标题</h3>
                <p>文章内容...</p>
                <figure>
                    <img src="image.jpg" alt="描述图片">
                    <figcaption>图片说明</figcaption>
                </figure>
            </section>
        </article>

        <aside>
            <h3>相关链接</h3>
            <ul>
                <li><a href="#related">相关内容</a></li>
            </ul>
        </aside>
    </main>

    <!-- 页脚 -->
    <footer>
        <address>
            联系地址：<a href="mailto:contact@example.com">contact@example.com</a>
        </address>
        <small>&copy; 2024 公司名称</small>
    </footer>
</body>
</html>
```

### 2. HTML 语义化的意义

**回答**：

*   **SEO优化**：帮助搜索引擎理解内容结构
    
*   **无障碍访问**：屏幕阅读器能更好理解页面
    
*   **代码可维护性**：结构清晰，易于维护
    
*   **设备兼容**：在不同设备上正确渲染
    

### 3. HTML 文档流理解

**代码示例**：

```html
<style>
    .block { 
        display: block; 
        background: lightblue; 
        margin: 10px 0;
    }
    .inline { 
        display: inline; 
        background: lightgreen; 
        padding: 0 5px;
    }
</style>

<div class="block">块级元素1 - 独占一行</div>
<div class="block">块级元素2 - 从上到下排列</div>

<span class="inline">行内元素1</span>
<span class="inline">行内元素2</span>
<span class="inline">行内元素3 - 从左到右排列，超出换行</span>
```

### 4. HTML5 相比 HTML4 的主要改进

**改进点**：

1.  新增语义化标签
    
2.  增强表单功能
    
3.  多媒体支持（audio、video）
    
4.  本地存储API
    
5.  Canvas绘图
    
6.  Web Workers多线程
    
7.  Geolocation定位
    

### 5. DOCTYPE 的作用和写法

**代码示例**：

```html
<!-- HTML5 DOCTYPE -->
<!DOCTYPE html>
<!-- HTML4.01 Strict -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<!-- XHTML 1.0 Strict -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
```

**作用**：声明文档类型，告诉浏览器用何种规范解析文档。

### 6. HTML 和 XHTML 的区别

**对比**：

| 特性  | HTML | XHTML |
| --- | --- | --- |
| 语法  | 宽松  | 严格XML语法 |
| 标签闭合 | 可不闭合 | 必须闭合 |
| 属性值引号 | 可不加引号 | 必须加引号 |
| 大小写 | 不敏感 | 必须小写 |
| MIME类型 | text/html | application/xhtml+xml |

### 7. 行内元素和块级元素

**代码示例**：

```html
<style>
    .block-demo, .inline-demo {
        border: 1px solid #ccc;
        padding: 10px;
        margin: 5px;
    }
</style>

<!-- 块级元素：独占一行，可设置宽高 -->
<div class="block-demo">div - 块级</div>
<p class="block-demo">p - 块级</p>
<h1 class="block-demo">h1 - 块级</h1>
<ul class="block-demo">ul - 块级</ul>

<!-- 行内元素：不独占一行，不可设置宽高 -->
<span class="inline-demo">span - 行内</span>
<a href="#" class="inline-demo">a - 行内</a>
<strong class="inline-demo">strong - 行内</strong>
<img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTAiIGhlaWdodD0iNTAiPjwvc3ZnPg==" alt="img - 替换元素" class="inline-demo">
```

### 8. 空元素（void elements）

**代码示例**：

```html
<!-- 自闭合标签，没有结束标签 -->
<img src="image.jpg" alt="图片">
<input type="text" placeholder="输入框">
<br>
<hr>
<meta charset="UTF-8">
<link rel="stylesheet" href="styles.css">
<area shape="circle" coords="75,75,50" href="click.html">
<colgroup>
    <col span="2" style="background-color:red">
    <col style="background-color:yellow">
</colgroup>
<param name="autoplay" value="true">
<source src="video.mp4" type="video/mp4">
<track src="subtitles_en.vtt" kind="subtitles" srclang="en">
```

### 9. src 和 href 的区别

**代码示例**：

```html
<!-- src (source) 用于替换当前元素内容 -->
<img src="image.jpg" alt="图片">
<script src="script.js"></script>
<iframe src="page.html"></iframe>

<!-- href (hypertext reference) 用于建立链接 -->
<a href="page.html">链接</a>
<link href="styles.css" rel="stylesheet">
<base href="https://example.com/">
```

### 10. data-\* 属性的作用

**代码示例**：

```html
<div id="product" 
     data-id="12345" 
     data-name="产品名称" 
     data-price="99.99"
     data-category="电子产品"
     data-available="true">
    商品信息
</div>

<script>
    // JavaScript 访问 data-* 属性
    const product = document.getElementById('product');
    console.log(product.dataset.id);        // "12345"
    console.log(product.dataset.name);      // "产品名称"
    console.log(product.dataset.price);     // "99.99"
    console.log(product.dataset.category);  // "电子产品"
    console.log(product.dataset.available); // "true"
    
    // 修改 data-* 属性
    product.dataset.price = "89.99";
    product.dataset.discount = "10%";  // 新增 data-discount 属性
</script>

<style>
    /* CSS 使用 data-* 属性 */
    [data-category="电子产品"] {
        border: 2px solid blue;
    }
    
    [data-available="false"] {
        opacity: 0.5;
    }
    
    /* 配合 ::before/::after 使用 */
    [data-price]:before {
        content: "¥" attr(data-price);
        color: red;
        font-weight: bold;
    }
</style>
```

## 5.2 表单与输入

### 1. HTML5 新增 input 类型

**代码示例**：

```html
<form>
    <!-- 邮箱 -->
    <label>邮箱：<input type="email" required></label>
    
    <!-- URL -->
    <label>网址：<input type="url" placeholder="https://example.com"></label>
    
    <!-- 数字 -->
    <label>数量：<input type="number" min="1" max="10" step="1" value="5"></label>
    
    <!-- 范围 -->
    <label>音量：<input type="range" min="0" max="100" value="50"></label>
    
    <!-- 日期 -->
    <label>日期：<input type="date"></label>
    
    <!-- 时间 -->
    <label>时间：<input type="time"></label>
    
    <!-- 颜色 -->
    <label>颜色：<input type="color" value="#ff0000"></label>
    
    <!-- 搜索 -->
    <label>搜索：<input type="search" placeholder="搜索..."></label>
    
    <!-- 电话 -->
    <label>电话：<input type="tel" pattern="[0-9]{11}"></label>
    
    <!-- 月份 -->
    <label>月份：<input type="month"></label>
    
    <!-- 周 -->
    <label>周数：<input type="week"></label>
    
    <button type="submit">提交</button>
</form>
```

### 2. 文件上传实现

**代码示例**：

```html
<form id="uploadForm" enctype="multipart/form-data">
    <!-- 单文件上传 -->
    <label>
        选择文件：
        <input type="file" name="singleFile" accept=".jpg,.png,.pdf">
    </label>
    
    <!-- 多文件上传 -->
    <label>
        选择多个文件：
        <input type="file" name="multipleFiles" multiple accept="image/*">
    </label>
    
    <!-- 文件类型限制 -->
    <label>
        图片文件：
        <input type="file" accept="image/jpeg,image/png">
    </label>
    
    <!-- 拖拽上传 -->
    <div id="dropZone" 
         style="border: 2px dashed #ccc; padding: 50px; text-align: center;">
        拖拽文件到此处或点击上传
        <input type="file" id="fileInput" hidden>
    </div>
    
    <!-- 显示预览 -->
    <div id="preview"></div>
    
    <button type="submit">上传</button>
</form>

<script>
    // 拖拽上传功能
    const dropZone = document.getElementById('dropZone');
    const fileInput = document.getElementById('fileInput');
    const preview = document.getElementById('preview');
    
    dropZone.addEventListener('click', () => fileInput.click());
    
    dropZone.addEventListener('dragover', (e) => {
        e.preventDefault();
        dropZone.style.borderColor = 'blue';
    });
    
    dropZone.addEventListener('dragleave', () => {
        dropZone.style.borderColor = '#ccc';
    });
    
    dropZone.addEventListener('drop', (e) => {
        e.preventDefault();
        dropZone.style.borderColor = '#ccc';
        
        const files = e.dataTransfer.files;
        handleFiles(files);
    });
    
    // 文件选择变化
    fileInput.addEventListener('change', (e) => {
        handleFiles(e.target.files);
    });
    
    // 处理文件
    function handleFiles(files) {
        preview.innerHTML = '';
        
        Array.from(files).forEach(file => {
            // 文件大小检查（限制5MB）
            if (file.size > 5 * 1024 * 1024) {
                alert(`${file.name} 文件太大，请选择小于5MB的文件`);
                return;
            }
            
            // 创建预览
            const reader = new FileReader();
            reader.onload = function(e) {
                const div = document.createElement('div');
                div.style.display = 'inline-block';
                div.style.margin = '10px';
                
                if (file.type.startsWith('image/')) {
                    const img = document.createElement('img');
                    img.src = e.target.result;
                    img.style.maxWidth = '100px';
                    img.style.maxHeight = '100px';
                    div.appendChild(img);
                }
                
                const info = document.createElement('div');
                info.textContent = `${file.name} (${(file.size/1024).toFixed(2)}KB)`;
                div.appendChild(info);
                
                preview.appendChild(div);
            };
            
            if (file.type.startsWith('image/')) {
                reader.readAsDataURL(file);
            } else {
                reader.readAsText(file);
            }
        });
    }
</script>
```

### 3. GET 和 POST 的区别

**代码示例**：

```html
<!-- GET 请求 -->
<form action="/search" method="get">
    <input type="text" name="q" placeholder="搜索关键词">
    <input type="submit" value="搜索">
    <!-- URL示例：/search?q=keyword -->
</form>

<!-- POST 请求 -->
<form action="/submit" method="post">
    <input type="text" name="username" placeholder="用户名">
    <input type="password" name="password" placeholder="密码">
    <input type="submit" value="登录">
    <!-- 数据在请求体中，不在URL中 -->
</form>
```

**区别**：

| 特性  | GET | POST |
| --- | --- | --- |
| 数据位置 | URL查询字符串 | 请求体 |
| 安全性 | 较低（URL可见） | 较高  |
| 数据大小 | 有限制（约2048字符） | 无限制 |
| 缓存  | 可缓存 | 不可缓存 |
| 幂等性 | 幂等（多次请求相同结果） | 非幂等 |
| 用途  | 获取数据 | 提交/修改数据 |

### 4. 表单验证实现

**代码示例**：

```html
<form id="validateForm" novalidate>
    <!-- 必填字段 -->
    <label>
        用户名：
        <input type="text" name="username" required 
               minlength="3" maxlength="20"
               pattern="[A-Za-z0-9_]+"
               placeholder="3-20位字母数字">
        <span class="error" id="usernameError"></span>
    </label>
    
    <!-- 邮箱验证 -->
    <label>
        邮箱：
        <input type="email" name="email" required
               placeholder="example@domain.com">
        <span class="error" id="emailError"></span>
    </label>
    
    <!-- 密码验证 -->
    <label>
        密码：
        <input type="password" name="password" required
               minlength="8"
               pattern="^(?=.*[A-Za-z])(?=.*\d)[A-Za-z\d@$!%*#?&]{8,}$"
               placeholder="至少8位，包含字母和数字">
        <span class="error" id="passwordError"></span>
    </label>
    
    <!-- 确认密码 -->
    <label>
        确认密码：
        <input type="password" name="confirmPassword" required>
        <span class="error" id="confirmError"></span>
    </label>
    
    <!-- 自定义验证 -->
    <label>
        年龄：
        <input type="number" name="age" min="18" max="100" value="18">
        <span class="error" id="ageError"></span>
    </label>
    
    <!-- URL验证 -->
    <label>
        个人网站：
        <input type="url" name="website"
               placeholder="https://example.com">
    </label>
    
    <!-- 日期验证 -->
    <label>
        生日：
        <input type="date" name="birthday" 
               max="2023-12-31">
    </label>
    
    <button type="submit">注册</button>
</form>

<script>
    const form = document.getElementById('validateForm');
    const password = form.password;
    const confirmPassword = form.confirmPassword;
    
    // 实时验证密码匹配
    confirmPassword.addEventListener('input', () => {
        if (password.value !== confirmPassword.value) {
            confirmPassword.setCustomValidity('密码不匹配');
            document.getElementById('confirmError').textContent = '密码不匹配';
        } else {
            confirmPassword.setCustomValidity('');
            document.getElementById('confirmError').textContent = '';
        }
    });
    
    // 自定义验证函数
    form.username.addEventListener('input', (e) => {
        const value = e.target.value;
        if (value.length < 3) {
            e.target.setCustomValidity('用户名至少3位');
        } else if (value.length > 20) {
            e.target.setCustomValidity('用户名不能超过20位');
        } else if (!/^[A-Za-z0-9_]+$/.test(value)) {
            e.target.setCustomValidity('只能包含字母、数字和下划线');
        } else {
            e.target.setCustomValidity('');
        }
    });
    
    // 表单提交验证
    form.addEventListener('submit', (e) => {
        e.preventDefault();
        
        if (!form.checkValidity()) {
            // 显示所有错误信息
            const inputs = form.querySelectorAll('input');
            inputs.forEach(input => {
                const errorId = input.name + 'Error';
                const errorElement = document.getElementById(errorId);
                if (errorElement) {
                    errorElement.textContent = input.validationMessage;
                }
            });
            return;
        }
        
        // 表单验证通过
        alert('表单验证成功！');
        // form.submit(); // 实际提交
    });
</script>

<style>
    .error {
        color: red;
        font-size: 12px;
        display: block;
        margin-top: 5px;
    }
    
    input:invalid {
        border-color: red;
    }
    
    input:valid {
        border-color: green;
    }
</style>
```

### 5. label 标签的作用

**代码示例**：

```html
<!-- 隐式关联 -->
<label>
    用户名：
    <input type="text" name="username">
</label>

<!-- 显式关联（使用for属性） -->
<label for="emailInput">邮箱：</label>
<input type="email" id="emailInput" name="email">

<!-- 实际应用：美化复选框 -->
<label class="checkbox-label">
    <input type="checkbox" name="agree" hidden>
    <span class="checkbox-custom"></span>
    我同意服务条款
</label>

<style>
    .checkbox-label {
        display: flex;
        align-items: center;
        cursor: pointer;
    }
    
    .checkbox-custom {
        width: 20px;
        height: 20px;
        border: 2px solid #ccc;
        border-radius: 3px;
        margin-right: 10px;
        position: relative;
    }
    
    input:checked + .checkbox-custom::after {
        content: "✓";
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: green;
        font-weight: bold;
    }
</style>
```

### 6. fieldset 和 legend 标签

**代码示例**：

```html
<form>
    <fieldset>
        <legend>个人信息</legend>
        
        <div>
            <label>
                姓名：
                <input type="text" name="name">
            </label>
        </div>
        
        <div>
            <label>
                邮箱：
                <input type="email" name="email">
            </label>
        </div>
    </fieldset>
    
    <fieldset>
        <legend>收货地址</legend>
        
        <fieldset>
            <legend>主要地址</legend>
            <input type="text" name="address1" placeholder="详细地址">
        </fieldset>
        
        <fieldset>
            <legend>备用地址</legend>
            <input type="text" name="address2" placeholder="备用地址">
        </fieldset>
    </fieldset>
    
    <fieldset>
        <legend>支付方式</legend>
        
        <label>
            <input type="radio" name="payment" value="alipay" checked>
            支付宝
        </label>
        
        <label>
            <input type="radio" name="payment" value="wechat">
            微信支付
        </label>
        
        <label>
            <input type="radio" name="payment" value="card">
            银行卡
        </label>
    </fieldset>
</form>

<style>
    fieldset {
        border: 1px solid #ddd;
        border-radius: 5px;
        padding: 15px;
        margin-bottom: 15px;
    }
    
    legend {
        font-weight: bold;
        padding: 0 10px;
        color: #333;
    }
    
    fieldset fieldset {
        margin-top: 10px;
        border-color: #eee;
    }
    
    fieldset fieldset legend {
        font-size: 14px;
        color: #666;
    }
</style>
```

## 5.3 多媒体与图形

### 1. 响应式图片实现

**代码示例**：

```html
<!-- 1. srcset + sizes 属性 -->
<img src="image-400.jpg"
     srcset="image-400.jpg 400w,
             image-800.jpg 800w,
             image-1200.jpg 1200w"
     sizes="(max-width: 600px) 100vw,
            (max-width: 1200px) 50vw,
            400px"
     alt="响应式图片"
     loading="lazy">

<!-- 2. picture 元素（艺术指导） -->
<picture>
    <!-- 小屏幕：方形图片 -->
    <source media="(max-width: 600px)"
            srcset="square-400.jpg 1x,
                    square-800.jpg 2x">
    
    <!-- 中屏幕：宽屏图片 -->
    <source media="(max-width: 1200px)"
            srcset="wide-800.jpg 1x,
                    wide-1600.jpg 2x">
    
    <!-- 大屏幕：原图 -->
    <source srcset="original-1200.jpg 1x,
                    original-2400.jpg 2x">
    
    <!-- 默认显示 -->
    <img src="fallback.jpg" alt="响应式图片示例">
</picture>

<!-- 3. 不同格式支持 -->
<picture>
    <!-- 优先使用WebP格式（体积更小） -->
    <source type="image/webp" srcset="image.webp">
    
    <!-- 回退方案 -->
    <source type="image/jpeg" srcset="image.jpg">
    
    <img src="image.jpg" alt="不同格式图片">
</picture>

<!-- 4. 背景图片响应式 -->
<div class="responsive-bg">
    背景图片响应式
</div>

<style>
    .responsive-bg {
        width: 100%;
        height: 300px;
        background-image: url('bg-400.jpg');
        background-size: cover;
        background-position: center;
        
        /* 高分辨率屏幕 */
        @media (-webkit-min-device-pixel-ratio: 2), 
               (min-resolution: 192dpi) {
            background-image: url('bg-800.jpg');
        }
        
        /* 大屏幕 */
        @media (min-width: 768px) {
            background-image: url('bg-1200.jpg');
            height: 500px;
        }
    }
</style>
```

### 2. picture vs img srcset

**代码示例**：

```html
<!-- img srcset：仅分辨率切换 -->
<img src="default.jpg"
     srcset="small.jpg 320w,
             medium.jpg 640w,
             large.jpg 1024w"
     sizes="100vw"
     alt="分辨率切换示例">

<!-- picture：艺术指导 + 格式切换 -->
<picture>
    <!-- 移动端：竖屏图片 -->
    <source media="(max-width: 768px)"
            srcset="portrait-small.jpg 320w,
                    portrait-large.jpg 640w"
            sizes="100vw">
    
    <!-- 桌面端：横屏图片 -->
    <source media="(min-width: 769px)"
            srcset="landscape-small.jpg 1024w,
                    landscape-large.jpg 2048w"
            sizes="50vw">
    
    <!-- WebP格式优先 -->
    <source type="image/webp" 
            srcset="image.webp">
    
    <!-- 默认回退 -->
    <img src="fallback.jpg" 
         alt="艺术指导示例">
</picture>
```

### 3. canvas 和 SVG 的区别

**代码示例**：

```html
<!-- Canvas：位图，适合复杂动画、游戏 -->
<canvas id="myCanvas" width="400" height="200"></canvas>

<script>
    const canvas = document.getElementById('myCanvas');
    const ctx = canvas.getContext('2d');
    
    // 绘制矩形
    ctx.fillStyle = 'red';
    ctx.fillRect(10, 10, 100, 50);
    
    // 绘制文本
    ctx.font = '20px Arial';
    ctx.fillStyle = 'black';
    ctx.fillText('Canvas示例', 120, 50);
    
    // 绘制圆形
    ctx.beginPath();
    ctx.arc(200, 100, 30, 0, Math.PI * 2);
    ctx.fillStyle = 'blue';
    ctx.fill();
</script>

<!-- SVG：矢量图，适合图标、图表 -->
<svg width="400" height="200">
    <!-- 矩形 -->
    <rect x="10" y="10" width="100" height="50" fill="red"/>
    
    <!-- 文本 -->
    <text x="120" y="50" font-family="Arial" font-size="20">SVG示例</text>
    
    <!-- 圆形 -->
    <circle cx="200" cy="100" r="30" fill="blue"/>
    
    <!-- 路径（复杂形状） -->
    <path d="M250,150 L300,50 L350,150 Z" fill="green"/>
    
    <!-- 可交互元素 -->
    <circle cx="300" cy="150" r="20" fill="orange"
            onclick="alert('SVG元素被点击！')"/>
</svg>

<!-- SVG 嵌入外部文件 -->
<svg width="100" height="100">
    <use href="#icon-home" x="0" y="0" width="100%" height="100%"/>
</svg>

<!-- SVG精灵图 -->
<svg style="display: none;">
    <symbol id="icon-home" viewBox="0 0 24 24">
        <path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/>
    </symbol>
</svg>
```

**区别对比**：

| 特性  | Canvas | SVG |
| --- | --- | --- |
| 类型  | 位图（像素） | 矢量图（XML） |
| 缩放  | 会失真 | 无损缩放 |
| 交互  | 需额外处理 | 原生支持 |
| 性能  | 适合复杂动画 | 适合静态图形 |
| SEO | 不可搜索 | 可搜索、可访问 |

### 4. video 和 audio 标签

**代码示例**：

```html
<!-- Video 视频 -->
<video id="myVideo" 
       width="600" 
       controls
       autoplay
       loop
       muted
       poster="thumbnail.jpg"
       preload="metadata">
    <!-- 多个源，浏览器选择支持的格式 -->
    <source src="video.mp4" type="video/mp4">
    <source src="video.webm" type="video/webm">
    <source src="video.ogv" type="video/ogg">
    
    <!-- 字幕 -->
    <track src="subtitles_en.vtt" kind="subtitles" srclang="en" label="English">
    <track src="subtitles_zh.vtt" kind="subtitles" srclang="zh" label="中文" default>
    
    <!-- 不支持视频的提示 -->
    您的浏览器不支持HTML5视频，请
    <a href="video.mp4">下载视频</a>。
</video>

<!-- Audio 音频 -->
<audio id="myAudio" controls loop preload="auto">
    <source src="audio.mp3" type="audio/mpeg">
    <source src="audio.ogg" type="audio/ogg">
    <source src="audio.wav" type="audio/wav">
    
    <!-- 不支持音频的提示 -->
    您的浏览器不支持HTML5音频。
</audio>

<!-- 自定义播放器控件 -->
<div class="custom-player">
    <video id="customVideo" src="video.mp4"></video>
    <div class="controls">
        <button onclick="togglePlay()">播放/暂停</button>
        <input type="range" id="volume" min="0" max="1" step="0.1" value="1">
        <button onclick="toggleMute()">静音</button>
        <span id="timeDisplay">00:00 / 00:00</span>
    </div>
</div>

<script>
    const video = document.getElementById('myVideo');
    const audio = document.getElementById('myAudio');
    
    // 视频控制
    video.playbackRate = 1.5; // 1.5倍速播放
    video.currentTime = 30;   // 跳到30秒
    
    // 事件监听
    video.addEventListener('loadedmetadata', () => {
        console.log(`视频时长: ${video.duration}秒`);
        console.log(`视频尺寸: ${video.videoWidth}x${video.videoHeight}`);
    });
    
    video.addEventListener('timeupdate', () => {
        const progress = (video.currentTime / video.duration) * 100;
        console.log(`播放进度: ${progress.toFixed(2)}%`);
    });
    
    // 自定义播放器功能
    function togglePlay() {
        const vid = document.getElementById('customVideo');
        vid.paused ? vid.play() : vid.pause();
    }
    
    function toggleMute() {
        const vid = document.getElementById('customVideo');
        vid.muted = !vid.muted;
    }
</script>

<style>
    .custom-player {
        width: 600px;
        background: #000;
        color: white;
    }
    
    .custom-player video {
        width: 100%;
        display: block;
    }
    
    .custom-player .controls {
        padding: 10px;
        display: flex;
        align-items: center;
        gap: 10px;
    }
    
    .custom-player button {
        background: #444;
        color: white;
        border: none;
        padding: 5px 10px;
        cursor: pointer;
    }
</style>
```

### 5. 音视频预加载和自动播放

**代码示例**：

```html
<!-- 1. 预加载 -->
<video preload="metadata" controls>
    <!-- metadata: 只加载元数据（推荐） -->
    <!-- auto: 自动加载整个文件 -->
    <!-- none: 不预加载 -->
    <source src="video.mp4" type="video/mp4">
</video>

<!-- 2. 自动播放策略 -->
<video autoplay muted playsinline>
    <!-- Chrome要求muted才能自动播放 -->
    <source src="video.mp4" type="video/mp4">
</video>

<!-- 3. JS控制自动播放 -->
<video id="autoplayVideo" controls>
    <source src="video.mp4" type="video/mp4">
</video>

<script>
    const video = document.getElementById('autoplayVideo');
    
    // 检查自动播放支持
    async function checkAutoplay() {
        try {
            await video.play();
            console.log('自动播放成功');
        } catch (err) {
            console.log('自动播放被阻止:', err);
            
            // 显示播放按钮
            const playButton = document.createElement('button');
            playButton.textContent = '点击播放';
            playButton.onclick = () => {
                video.play();
                playButton.remove();
            };
            video.parentNode.appendChild(playButton);
        }
    }
    
    // 页面可见时播放
    document.addEventListener('visibilitychange', () => {
        if (!document.hidden && video.paused) {
            video.play().catch(() => {});
        }
    });
    
    // 用户交互后自动播放
    document.addEventListener('click', async () => {
        await video.play().catch(() => {});
    }, { once: true });
    
    // 预加载重要部分
    video.addEventListener('loadedmetadata', () => {
        // 预加载前10秒
        for (let i = 0; i < 10; i++) {
            video.currentTime = i;
            setTimeout(() => video.currentTime = 0, 100);
        }
    });
</script>

<!-- 4. 懒加载视频 -->
<video controls 
       preload="none"
       poster="thumbnail.jpg"
       data-src="video.mp4">
    您的浏览器不支持视频标签
</video>

<script>
    // 懒加载视频
    const lazyVideos = document.querySelectorAll('video[data-src]');
    
    const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
            if (entry.isIntersecting) {
                const video = entry.target;
                video.src = video.dataset.src;
                video.removeAttribute('data-src');
                observer.unobserve(video);
            }
        });
    });
    
    lazyVideos.forEach(video => observer.observe(video));
</script>
```

## 5.4 性能与优化

### 1. script async 和 defer 区别

**代码示例**：

```html
<!DOCTYPE html>
<html>
<head>
    <!-- 1. 正常脚本（阻塞渲染） -->
    <script src="normal.js"></script>
    
    <!-- 2. async：异步加载，加载完立即执行 -->
    <script async src="async.js"></script>
    
    <!-- 3. defer：延迟执行，在DOM解析后、DOMContentLoaded前执行 -->
    <script defer src="defer.js"></script>
    
    <!-- 4. 模块脚本（默认defer） -->
    <script type="module" src="module.js"></script>
</head>
<body>
    <h1>脚本加载测试</h1>
    
    <!-- 内联脚本 -->
    <script>
        console.log('内联脚本执行');
        document.addEventListener('DOMContentLoaded', () => {
            console.log('DOMContentLoaded');
        });
    </script>
</body>
</html>
```

**执行顺序对比**：

```plain
javascript
```

```plain
// async.js
console.log('async脚本执行');

// defer.js  
console.log('defer脚本执行');

// 典型输出顺序：
// 1. 内联脚本执行
// 2. async脚本执行（取决于加载速度）
// 3. defer脚本执行
// 4. DOMContentLoaded
```

### 2. preload, prefetch, preconnect

**代码示例**：

```html
<head>
    <!-- 1. preload：当前页面必需资源 -->
    <link rel="preload" href="critical.css" as="style">
    <link rel="preload" href="hero-image.jpg" as="image">
    <link rel="preload" href="main.js" as="script">
    <link rel="preload" href="font.woff2" as="font" type="font/woff2" crossorigin>
    
    <!-- 2. prefetch：下个页面可能需要的资源 -->
    <link rel="prefetch" href="next-page.css" as="style">
    <link rel="prefetch" href="next-page.js" as="script">
    
    <!-- 3. preconnect：提前建立连接 -->
    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="preconnect" href="https://api.example.com" crossorigin>
    
    <!-- 4. dns-prefetch：DNS预解析 -->
    <link rel="dns-prefetch" href="//cdn.example.com">
    
    <!-- 5. prerender：预渲染整个页面 -->
    <link rel="prerender" href="https://example.com/next-page">
    
    <!-- 实际应用 -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto&display=swap" rel="stylesheet">
</head>
```

**区别**：

| 类型  | 时机  | 用途  |
| --- | --- | --- |
| preload | 当前页面 | 关键资源提前加载 |
| prefetch | 空闲时 | 下个页面资源预加载 |
| preconnect | 早期  | 提前建立连接 |
| dns-prefetch | 早期  | DNS预解析 |
| prerender | 空闲时 | 整个页面预渲染 |

### 3. 网页加载性能优化

**代码示例**：

```html
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <!-- 1. 关键CSS内联 -->
    <style>
        /* 首屏关键样式 */
        .above-the-fold { /* ... */ }
    </style>
    
    <!-- 2. 非关键CSS异步加载 -->
    <link rel="preload" href="non-critical.css" as="style" 
          onload="this.onload=null;this.rel='stylesheet'">
    <noscript><link rel="stylesheet" href="non-critical.css"></noscript>
    
    <!-- 3. 字体优化 -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto&display=swap" 
          rel="stylesheet" 
          media="print" 
          onload="this.media='all'">
    
    <!-- 4. 异步脚本 -->
    <script defer src="analytics.js"></script>
    
    <!-- 5. 资源提示 -->
    <link rel="preload" href="hero-image.webp" as="image" type="image/webp">
    
    <!-- 6. 使用dns-prefetch -->
    <link rel="dns-prefetch" href="//cdn.example.com">
</head>
<body>
    <!-- 7. 图片懒加载 -->
    <img src="placeholder.jpg" 
         data-src="actual-image.jpg" 
         alt="描述"
         loading="lazy"
         width="600" height="400">
    
    <!-- 8. 响应式图片 -->
    <picture>
        <source srcset="image.webp" type="image/webp">
        <img src="image.jpg" alt="响应式图片">
    </picture>
    
    <!-- 9. 延迟加载iframe -->
    <iframe src="about:blank" 
            data-src="https://example.com" 
            loading="lazy"></iframe>
    
    <!-- 10. 代码拆分 -->
    <script type="module">
        // 动态导入（代码拆分）
        if (userNeedsFeature) {
            import('./feature.js')
                .then(module => module.init());
        }
    </script>
    
    <script>
        // 11. 性能监控
        window.addEventListener('load', () => {
            // 计算性能指标
            const perfData = performance.getEntriesByType('navigation')[0];
            console.log('加载时间:', perfData.loadEventEnd);
            
            // 上报性能数据
            if (navigator.sendBeacon) {
                navigator.sendBeacon('/analytics', JSON.stringify(perfData));
            }
        });
    </script>
</body>
</html>
```

### 4. 懒加载实现

**代码示例**：

```html
<!-- 1. 原生懒加载 -->
<img src="placeholder.jpg"
     data-src="image.jpg"
     alt="描述"
     loading="lazy"
     width="800" height="600">

<iframe src="about:blank"
        data-src="https://example.com"
        loading="lazy"></iframe>

<!-- 2. 自定义懒加载 -->
<div class="lazy-load-container">
    <!-- 图片懒加载 -->
    <img class="lazy" 
         src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 800 600'%3E%3C/svg%3E"
         data-src="image.jpg"
         data-srcset="image-800.jpg 800w, image-1200.jpg 1200w"
         alt="懒加载图片">
    
    <!-- 背景图片懒加载 -->
    <div class="lazy-bg" 
         data-bg="background.jpg"
         style="width: 100%; height: 300px;"></div>
    
    <!-- 视频懒加载 -->
    <video class="lazy" 
           preload="none"
           poster="thumbnail.jpg"
           data-src="video.mp4"
           controls></video>
</div>

<script>
    // 3. Intersection Observer API实现懒加载
    document.addEventListener('DOMContentLoaded', () => {
        const lazyElements = document.querySelectorAll('.lazy, .lazy-bg');
        
        const lazyObserver = new IntersectionObserver((entries, observer) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    const element = entry.target;
                    
                    if (element.classList.contains('lazy')) {
                        // 图片/视频懒加载
                        if (element.tagName === 'IMG') {
                            element.src = element.dataset.src;
                            if (element.dataset.srcset) {
                                element.srcset = element.dataset.srcset;
                            }
                        } else if (element.tagName === 'VIDEO') {
                            element.src = element.dataset.src;
                            element.load();
                        }
                        element.classList.remove('lazy');
                    } else if (element.classList.contains('lazy-bg')) {
                        // 背景图片懒加载
                        element.style.backgroundImage = `url(${element.dataset.bg})`;
                        element.classList.remove('lazy-bg');
                    }
                    
                    observer.unobserve(element);
                }
            });
        }, {
            rootMargin: '50px', // 提前50px开始加载
            threshold: 0.1
        });
        
        lazyElements.forEach(element => lazyObserver.observe(element));
    });
    
    // 4. 回退方案：兼容老浏览器
    if (!('IntersectionObserver' in window)) {
        const lazyLoadFallback = () => {
            const lazyElements = document.querySelectorAll('.lazy, .lazy-bg');
            const scrollTop = window.pageYOffset;
            
            lazyElements.forEach(element => {
                if (element.offsetTop < window.innerHeight + scrollTop) {
                    // 加载逻辑同上
                }
            });
        };
        
        window.addEventListener('scroll', lazyLoadFallback);
        window.addEventListener('resize', lazyLoadFallback);
        window.addEventListener('orientationchange', lazyLoadFallback);
    }
</script>

<style>
    /* 懒加载动画效果 */
    .lazy {
        opacity: 0;
        transition: opacity 0.3s ease;
    }
    
    .lazy.loaded {
        opacity: 1;
    }
    
    /* 占位符样式 */
    .lazy-placeholder {
        background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
        background-size: 200% 100%;
        animation: loading 1.5s infinite;
    }
    
    @keyframes loading {
        0% { background-position: 200% 0; }
        100% { background-position: -200% 0; }
    }
</style>
```

### 5. 重绘和重排

**代码示例**：

```html
<div id="demo" style="width: 100px; height: 100px; background: red;"></div>

<button onclick="causeRepaint()">触发重绘</button>
<button onclick="causeReflow()">触发重排</button>
<button onclick="optimizedUpdate()">优化更新</button>

<script>
    const demo = document.getElementById('demo');
    
    // 触发重绘：改变颜色、透明度等（不影响布局）
    function causeRepaint() {
        demo.style.backgroundColor = 'blue';
        demo.style.opacity = '0.8';
        demo.style.outline = '2px solid green';
    }
    
    // 触发重排：改变尺寸、位置等（影响布局）
    function causeReflow() {
        demo.style.width = '200px';          // 重排
        demo.style.margin = '20px';          // 重排
        demo.style.padding = '10px';         // 重排
        demo.style.display = 'inline-block'; // 重排
    }
    
    // 优化：批量DOM操作
    function optimizedUpdate() {
        // 1. 使用DocumentFragment
        const fragment = document.createDocumentFragment();
        for (let i = 0; i < 100; i++) {
            const div = document.createElement('div');
            div.textContent = `Item ${i}`;
            fragment.appendChild(div);
        }
        demo.appendChild(fragment);
        
        // 2. 脱离文档流操作
        const originalDisplay = demo.style.display;
        demo.style.display = 'none'; // 先隐藏（脱离文档流）
        // 批量修改
        demo.style.width = '200px';
        demo.style.height = '200px';
        demo.style.padding = '20px';
        demo.style.display = originalDisplay; // 恢复显示
        
        // 3. 使用transform代替top/left
        demo.style.transform = 'translate(100px, 50px)'; // 只重绘，不重排
        
        // 4. 读写分离
        // 不好：读写交替
        for (let i = 0; i < demo.childNodes.length; i++) {
            demo.childNodes[i].style.width = demo.offsetWidth + 'px'; // 读操作触发重排
        }
        
        // 好：先读后写
        const width = demo.offsetWidth; // 一次读取
        for (let i = 0; i < demo.childNodes.length; i++) {
            demo.childNodes[i].style.width = width + 'px'; // 批量写入
        }
    }
    
    // 性能监控
    function measurePerformance() {
        const startTime = performance.now();
        
        // 执行操作
        causeReflow();
        
        const endTime = performance.now();
        console.log(`操作耗时: ${endTime - startTime}ms`);
        
        // 使用PerformanceObserver监控
        const observer = new PerformanceObserver((list) => {
            list.getEntries().forEach(entry => {
                if (entry.entryType === 'layout-shift') {
                    console.log('布局偏移:', entry.value);
                }
            });
        });
        
        observer.observe({ entryTypes: ['layout-shift'] });
    }
</script>
```

## 5.5 存储与API

### 1. localStorage, sessionStorage, cookie 区别

**代码示例**：

```plain
javascript
```

```plain
// 1. localStorage - 持久化存储
localStorage.setItem('username', '张三');
localStorage.setItem('theme', 'dark');
localStorage.setItem('userSettings', JSON.stringify({
    fontSize: 16,
    notifications: true
}));

// 读取
const username = localStorage.getItem('username');
const settings = JSON.parse(localStorage.getItem('userSettings') || '{}');

// 删除
localStorage.removeItem('theme');
localStorage.clear(); // 清空所有

// 事件监听（其他标签页修改时触发）
window.addEventListener('storage', (e) => {
    console.log(`Key: ${e.key}, New: ${e.newValue}, Old: ${e.oldValue}, URL: ${e.url}`);
});

// 2. sessionStorage - 会话存储
sessionStorage.setItem('sessionId', 'abc123');
sessionStorage.setItem('cart', JSON.stringify(['item1', 'item2']));

// 3. Cookie操作
function setCookie(name, value, days = 7) {
    const expires = new Date();
    expires.setTime(expires.getTime() + days * 24 * 60 * 60 * 1000);
    document.cookie = `${name}=${encodeURIComponent(value)};expires=${expires.toUTCString()};path=/;SameSite=Lax`;
}

function getCookie(name) {
    const match = document.cookie.match(new RegExp('(^| )' + name + '=([^;]+)'));
    return match ? decodeURIComponent(match[2]) : null;
}

function deleteCookie(name) {
    document.cookie = `${name}=;expires=Thu, 01 Jan 1970 00:00:00 GMT;path=/`;
}

// 使用示例
setCookie('token', 'jwt_token_here', 30);
const token = getCookie('token');
deleteCookie('old_token');

// 4. IndexedDB - 大型结构化数据
const request = indexedDB.open('MyDatabase', 1);

request.onupgradeneeded = (e) => {
    const db = e.target.result;
    
    // 创建对象存储
    if (!db.objectStoreNames.contains('users')) {
        const store = db.createObjectStore('users', { keyPath: 'id' });
        store.createIndex('email', 'email', { unique: true });
    }
    
    if (!db.objectStoreNames.contains('products')) {
        db.createObjectStore('products', { keyPath: 'id', autoIncrement: true });
    }
};

request.onsuccess = (e) => {
    const db = e.target.result;
    
    // 添加数据
    const transaction = db.transaction(['users'], 'readwrite');
    const store = transaction.objectStore('users');
    
    store.add({
        id: 1,
        name: '张三',
        email: 'zhangsan@example.com'
    });
    
    // 查询数据
    const getRequest = store.get(1);
    getRequest.onsuccess = (e) => {
        console.log('用户数据:', e.target.result);
    };
};

// 5. 存储封装类
class StorageManager {
    constructor(namespace = 'app') {
        this.namespace = namespace;
    }
    
    set(key, value) {
        try {
            const data = JSON.stringify(value);
            localStorage.setItem(`${this.namespace}_${key}`, data);
            return true;
        } catch (e) {
            console.error('存储失败:', e);
            return false;
        }
    }
    
    get(key, defaultValue = null) {
        try {
            const data = localStorage.getItem(`${this.namespace}_${key}`);
            return data ? JSON.parse(data) : defaultValue;
        } catch (e) {
            console.error('读取失败:', e);
            return defaultValue;
        }
    }
    
    remove(key) {
        localStorage.removeItem(`${this.namespace}_${key}`);
    }
    
    clear() {
        Object.keys(localStorage).forEach(key => {
            if (key.startsWith(`${this.namespace}_`)) {
                localStorage.removeItem(key);
            }
        });
    }
}

// 使用封装类
const storage = new StorageManager('myApp');
storage.set('user', { name: '张三', age: 25 });
const user = storage.get('user');
```

**区别对比**：

| 特性  | Cookie | localStorage | sessionStorage |
| --- | --- | --- | --- |
| 容量  | ~4KB | ~5-10MB | ~5-10MB |
| 生命周期 | 可设置过期时间 | 永久（手动清除） | 标签页关闭 |
| 服务器通信 | 自动携带 | 不自动 | 不自动 |
| 访问范围 | 同源  | 同源  | 同标签页 |

### 2. 跨标签页通信

**代码示例**：

```html
<!-- 页面A -->
<h2>页面A</h2>
<input type="text" id="messageInput" placeholder="输入消息">
<button onclick="sendMessage()">发送消息</button>
<div id="messagesA"></div>

<!-- 页面B -->
<h2>页面B</h2>
<div id="messagesB"></div>

<script>
    // 1. localStorage + storage事件（同源）
    const messageInput = document.getElementById('messageInput');
    const messagesDiv = document.getElementById('messagesA') || 
                        document.getElementById('messagesB');
    
    // 发送消息
    function sendMessage() {
        const message = messageInput.value;
        const data = {
            type: 'message',
            content: message,
            timestamp: Date.now(),
            from: window.location.pathname
        };
        
        localStorage.setItem('crossTabMessage', JSON.stringify(data));
        messageInput.value = '';
    }
    
    // 接收消息
    window.addEventListener('storage', (e) => {
        if (e.key === 'crossTabMessage' && e.newValue) {
            const data = JSON.parse(e.newValue);
            if (data.type === 'message') {
                const message = document.createElement('div');
                message.textContent = `[${new Date(data.timestamp).toLocaleTimeString()}] ${data.content}`;
                messagesDiv.appendChild(message);
            }
        }
    });
    
    // 2. Broadcast Channel API（现代浏览器）
    const broadcastChannel = new BroadcastChannel('app_channel');
    
    // 发送
    broadcastChannel.postMessage({
        type: 'user_action',
        action: 'login',
        user: { name: '张三' }
    });
    
    // 接收
    broadcastChannel.onmessage = (e) => {
        console.log('收到广播消息:', e.data);
    };
    
    // 3. SharedWorker（共享Worker）
    const sharedWorker = new SharedWorker('shared-worker.js');
    sharedWorker.port.start();
    
    // 发送消息给Worker
    sharedWorker.port.postMessage({
        type: 'register',
        tabId: Math.random().toString(36).substr(2, 9)
    });
    
    // 接收Worker转发消息
    sharedWorker.port.onmessage = (e) => {
        if (e.data.type === 'broadcast') {
            console.log('收到其他标签页消息:', e.data.content);
        }
    };
    
    // 4. window.opener（父子窗口）
    // 打开新窗口
    const childWindow = window.open('child.html', '_blank');
    
    // 向子窗口发送消息
    setTimeout(() => {
        childWindow.postMessage('来自父窗口的消息', '*');
    }, 1000);
    
    // 接收子窗口消息
    window.addEventListener('message', (e) => {
        if (e.origin === window.location.origin) {
            console.log('收到子窗口消息:', e.data);
        }
    });
    
    // 5. Service Worker消息代理
    if ('serviceWorker' in navigator) {
        navigator.serviceWorker.addEventListener('message', (e) => {
            console.log('Service Worker转发消息:', e.data);
        });
    }
</script>
```

**shared-worker.js**：

```plain
javascript
```

```plain
// 共享Worker代码
const connections = new Map();

self.onconnect = (e) => {
    const port = e.ports[0];
    const tabId = Math.random().toString(36).substr(2, 9);
    
    port.addEventListener('message', (e) => {
        const data = e.data;
        
        if (data.type === 'register') {
            connections.set(data.tabId, port);
            port.tabId = data.tabId;
        } else if (data.type === 'broadcast') {
            // 广播消息给所有连接
            connections.forEach((conn, id) => {
                if (id !== port.tabId) {
                    conn.postMessage({
                        type: 'broadcast',
                        content: data.content,
                        from: port.tabId
                    });
                }
            });
        }
    });
    
    port.start();
};
```

### 3. Web Worker 应用场景

**代码示例**：

```html
<!-- 主线程 -->
<h2>Web Worker 示例</h2>
<button onclick="startWorker()">启动Worker</button>
<button onclick="stopWorker()">停止Worker</button>
<button onclick="sendMessageToWorker()">发送消息</button>
<button onclick="runHeavyTask()">运行繁重任务</button>
<div id="result"></div>

<script>
    let worker;
    
    // 1. 创建Worker
    function startWorker() {
        if (typeof(Worker) !== "undefined") {
            if (!worker) {
                worker = new Worker('worker.js');
                
                // 接收Worker消息
                worker.onmessage = (e) => {
                    document.getElementById('result').innerHTML = 
                        `Worker说: ${e.data}`;
                };
                
                // Worker错误处理
                worker.onerror = (e) => {
                    console.error('Worker错误:', e.message);
                };
                
                console.log('Worker已启动');
            }
        } else {
            alert("抱歉，您的浏览器不支持Web Worker");
        }
    }
    
    // 2. 向Worker发送消息
    function sendMessageToWorker() {
        if (worker) {
            worker.postMessage({
                type: 'greeting',
                message: '你好，Worker！'
            });
        }
    }
    
    // 3. 繁重任务
    function runHeavyTask() {
        if (!worker) startWorker();
        
        const data = {
            type: 'heavy_task',
            arraySize: 1000000 // 100万个元素
        };
        
        console.time('Worker处理时间');
        worker.postMessage(data);
        
        worker.onmessage = (e) => {
            if (e.data.type === 'heavy_result') {
                console.timeEnd('Worker处理时间');
                console.log('处理结果:', e.data.result.length);
            }
        };
    }
    
    // 4. 停止Worker
    function stopWorker() {
        if (worker) {
            worker.terminate();
            worker = null;
            console.log('Worker已停止');
        }
    }
    
    // 5. 对比：在主线程运行繁重任务
    function runHeavyTaskInMain() {
        console.time('主线程处理时间');
        
        // 模拟繁重计算
        let sum = 0;
        for (let i = 0; i < 1000000000; i++) {
            sum += i;
        }
        
        console.timeEnd('主线程处理时间');
        console.log('计算结果:', sum);
        
        // UI会卡顿
        document.getElementById('result').textContent = 
            `计算完成: ${sum}，注意UI的卡顿`;
    }
    
    // 6. 使用多个Worker
    function runParallelTasks() {
        const workerCount = 4;
        const workers = [];
        const promises = [];
        
        for (let i = 0; i < workerCount; i++) {
            const worker = new Worker('worker.js');
            workers.push(worker);
            
            const promise = new Promise((resolve) => {
                worker.onmessage = (e) => {
                    resolve({ workerId: i, result: e.data });
                    worker.terminate();
                };
            });
            
            promises.push(promise);
            
            // 分配任务
            worker.postMessage({
                type: 'parallel_task',
                taskId: i,
                data: generateDataForTask(i)
            });
        }
        
        // 等待所有Worker完成
        Promise.all(promises).then(results => {
            console.log('所有任务完成:', results);
        });
    }
    
    // 7. 使用SharedWorker
    function startSharedWorker() {
        const sharedWorker = new SharedWorker('shared-worker.js');
        
        // 连接共享Worker
        sharedWorker.port.start();
        
        // 发送消息
        sharedWorker.port.postMessage({
            type: 'hello',
            from: '页面1'
        });
        
        // 接收消息
        sharedWorker.port.onmessage = (e) => {
            console.log('共享Worker消息:', e.data);
        };
    }
</script>
```

**worker.js**：

```plain
javascript
```

```plain
// Web Worker代码（独立线程）

// 1. 监听消息
self.onmessage = function(e) {
    const data = e.data;
    
    switch(data.type) {
        case 'greeting':
            // 简单回应
            self.postMessage(`收到: ${data.message}`);
            break;
            
        case 'heavy_task':
            // 繁重计算任务
            const result = processHeavyData(data.arraySize);
            self.postMessage({
                type: 'heavy_result',
                result: result
            });
            break;
            
        case 'parallel_task':
            // 并行处理任务
            const taskResult = processTask(data.taskId, data.data);
            self.postMessage(taskResult);
            break;
            
        default:
            self.postMessage('未知消息类型');
    }
};

// 2. 繁重数据处理函数
function processHeavyData(size) {
    console.log('Worker开始处理数据，大小:', size);
    
    // 创建大型数组
    const array = new Array(size);
    
    // 模拟复杂计算
    for (let i = 0; i < size; i++) {
        array[i] = {
            id: i,
            value: Math.random() * 1000,
            processed: processItem(i)
        };
    }
    
    // 排序
    array.sort((a, b) => a.value - b.value);
    
    // 过滤
    const filtered = array.filter(item => item.value > 500);
    
    console.log('Worker处理完成');
    return filtered;
}

function processItem(index) {
    // 模拟复杂计算
    let result = index;
    for (let i = 0; i < 100; i++) {
        result = Math.sin(result) * Math.cos(index);
    }
    return result;
}

function processTask(taskId, data) {
    // 处理特定任务
    console.log(`Worker处理任务 ${taskId}`);
    
    // 模拟处理时间
    const start = Date.now();
    while (Date.now() - start < 1000) {
        // 模拟1秒处理时间
    }
    
    return {
        taskId,
        result: `任务${taskId}完成，数据长度: ${data ? data.length : 0}`
    };
}

// 3. 错误处理
self.onerror = function(error) {
    console.error('Worker内部错误:', error);
};

// 4. 导入脚本（支持ES6模块）
if (self.importScripts) {
    // importScripts('helper.js');
}

// 5. Worker关闭前清理
self.addEventListener('beforeunload', () => {
    console.log('Worker即将关闭，执行清理');
    // 清理资源
});
```

**应用场景**：

1.  图像处理（滤镜、压缩）
    
2.  大数据排序/过滤
    
3.  复杂数学计算
    
4.  CSV/JSON解析
    
5.  实时数据分析
    
6.  物理引擎计算
    
7.  加密/解密操作
    

### 4. Service Worker 生命周期

**代码示例**：

```plain
javascript
```

```plain
// service-worker.js
const CACHE_NAME = 'v1';
const urlsToCache = [
    '/',
    '/index.html',
    '/styles.css',
    '/main.js',
    '/manifest.json',
    '/icons/icon-192.png'
];

// 1. install事件 - 首次注册或更新时触发
self.addEventListener('install', (event) => {
    console.log('Service Worker installing...');
    
    // 跳过等待，立即激活
    self.skipWaiting();
    
    // 预缓存关键资源
    event.waitUntil(
        caches.open(CACHE_NAME)
            .then(cache => {
                console.log('Opened cache');
                return cache.addAll(urlsToCache);
            })
            .then(() => {
                console.log('所有资源已缓存');
            })
            .catch(error => {
                console.error('缓存失败:', error);
            })
    );
});

// 2. activate事件 - 激活时触发
self.addEventListener('activate', (event) => {
    console.log('Service Worker activating...');
    
    event.waitUntil(
        // 清理旧缓存
        caches.keys().then(cacheNames => {
            return Promise.all(
                cacheNames.map(cacheName => {
                    if (cacheName !== CACHE_NAME) {
                        console.log('删除旧缓存:', cacheName);
                        return caches.delete(cacheName);
                    }
                })
            );
        }).then(() => {
            // 控制所有客户端
            return self.clients.claim();
        })
    );
});

// 3. fetch事件 - 网络请求拦截
self.addEventListener('fetch', (event) => {
    const request = event.request;
    const url = new URL(request.url);
    
    // 忽略非GET请求和非同源请求
    if (request.method !== 'GET' || !url.origin.startsWith(self.location.origin)) {
        return;
    }
    
    // 离线优先策略
    event.respondWith(
        caches.match(request)
            .then(response => {
                // 返回缓存
                if (response) {
                    return response;
                }
                
                // 获取最新资源
                return fetch(request)
                    .then(response => {
                        // 检查响应是否有效
                        if (!response || response.status !== 200) {
                            return response;
                        }
                        
                        // 缓存新资源
                        const responseToCache = response.clone();
                        caches.open(CACHE_NAME)
                            .then(cache => {
                                cache.put(request, responseToCache);
                            });
                        
                        return response;
                    })
                    .catch(() => {
                        // 网络失败，返回离线页面
                        if (request.headers.get('accept').includes('text/html')) {
                            return caches.match('/offline.html');
                        }
                    });
            })
    );
});

// 4. push事件 - 推送通知
self.addEventListener('push', (event) => {
    console.log('收到推送消息:', event.data.text());
    
    const options = {
        body: event.data.text(),
        icon: '/icons/icon-192.png',
        badge: '/icons/badge-72.png',
        vibrate: [200, 100, 200],
        data: {
            url: 'https://example.com'
        },
        actions: [
            { action: 'view', title: '查看' },
            { action: 'close', title: '关闭' }
        ]
    };
    
    event.waitUntil(
        self.registration.showNotification('新消息', options)
    );
});

// 5. notificationclick事件 - 通知点击
self.addEventListener('notificationclick', (event) => {
    console.log('通知被点击:', event.notification.data);
    
    event.notification.close();
    
    if (event.action === 'view') {
        // 打开特定页面
        event.waitUntil(
            clients.openWindow(event.notification.data.url)
        );
    } else {
        // 默认打开应用
        event.waitUntil(
            clients.matchAll({ type: 'window' })
                .then(clientList => {
                    for (const client of clientList) {
                        if (client.url === '/' && 'focus' in client) {
                            return client.focus();
                        }
                    }
                    if (clients.openWindow) {
                        return clients.openWindow('/');
                    }
                })
        );
    }
});

// 6. sync事件 - 后台同步
self.addEventListener('sync', (event) => {
    if (event.tag === 'sync-messages') {
        console.log('开始后台同步...');
        event.waitUntil(syncMessages());
    }
});

async function syncMessages() {
    // 同步离线时的消息
    const messages = await getPendingMessages();
    
    for (const message of messages) {
        try {
            await sendMessageToServer(message);
            await markMessageAsSynced(message.id);
        } catch (error) {
            console.error('同步失败:', error);
            throw error; // 触发重试
        }
    }
}

// 7. message事件 - 与主线程通信
self.addEventListener('message', (event) => {
    console.log('收到主线程消息:', event.data);
    
    switch (event.data.type) {
        case 'CACHE_NEW_RESOURCE':
            cacheResource(event.data.url);
            break;
            
        case 'GET_CACHE_INFO':
            getCacheInfo().then(info => {
                event.ports[0].postMessage(info);
            });
            break;
            
        case 'SKIP_WAITING':
            self.skipWaiting();
            break;
    }
});

async function cacheResource(url) {
    const cache = await caches.open(CACHE_NAME);
    const response = await fetch(url);
    await cache.put(url, response);
}

async function getCacheInfo() {
    const cache = await caches.open(CACHE_NAME);
    const keys = await cache.keys();
    return {
        cachedCount: keys.length,
        cachedUrls: keys.map(req => req.url)
    };
}
```

**主线程注册Service Worker**：

```plain
javascript
```

```plain
// main.js
if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
        // 注册Service Worker
        navigator.serviceWorker.register('/service-worker.js')
            .then(registration => {
                console.log('Service Worker 注册成功:', registration.scope);
                
                // 检查更新
                registration.addEventListener('updatefound', () => {
                    const newWorker = registration.installing;
                    console.log('发现新版本Service Worker');
                    
                    newWorker.addEventListener('statechange', () => {
                        if (newWorker.state === 'installed') {
                            if (navigator.serviceWorker.controller) {
                                // 显示更新提示
                                showUpdateNotification();
                            }
                        }
                    });
                });
            })
            .catch(error => {
                console.error('Service Worker 注册失败:', error);
            });
        
        // 监听Service Worker消息
        navigator.serviceWorker.addEventListener('message', (event) => {
            console.log('收到Service Worker消息:', event.data);
        });
        
        // 发送消息到Service Worker
        function sendMessageToSW(message) {
            if (navigator.serviceWorker.controller) {
                navigator.serviceWorker.controller.postMessage(message);
            }
        }
        
        // 请求后台同步
        function requestBackgroundSync() {
            navigator.serviceWorker.ready.then(registration => {
                return registration.sync.register('sync-messages');
            }).then(() => {
                console.log('后台同步已注册');
            }).catch(error => {
                console.error('后台同步注册失败:', error);
            });
        }
        
        // 请求推送权限
        function requestPushPermission() {
            return Notification.requestPermission().then(permission => {
                if (permission === 'granted') {
                    console.log('推送权限已授予');
                    // 订阅推送服务
                    subscribeUserToPush();
                }
            });
        }
        
        // 离线状态检测
        window.addEventListener('online', () => {
            console.log('网络已恢复');
            // 触发同步
            requestBackgroundSync();
        });
        
        window.addEventListener('offline', () => {
            console.log('网络已断开');
        });
    });
} else {
    console.log('当前浏览器不支持Service Worker');
}
```

### 5. Geolocation API 使用

**代码示例**：

```html
<!DOCTYPE html>
<html>
<head>
    <title>地理位置API示例</title>
    <style>
        #map {
            width: 100%;
            height: 400px;
            border: 1px solid #ccc;
            margin: 20px 0;
        }
        
        .location-info {
            background: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
        }
        
        button {
            margin: 5px;
            padding: 10px 20px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        
        button:hover {
            background: #0056b3;
        }
        
        .error {
            color: red;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <h1>地理位置API示例</h1>
    
    <div>
        <button onclick="getCurrentPosition()">获取当前位置</button>
        <button onclick="watchPosition()">持续监控位置</button>
        <button onclick="stopWatching()">停止监控</button>
        <button onclick="clearPosition()">清除位置信息</button>
    </div>
    
    <div id="positionInfo" class="location-info">
        位置信息将显示在这里...
    </div>
    
    <div id="map"></div>
    
    <div id="history" class="location-info">
        <h3>位置历史</h3>
        <ul id="positionHistory"></ul>
    </div>
    
    <script>
        let watchId = null;
        let positionHistory = [];
        let map = null;
        
        // 1. 获取当前位置（单次）
        function getCurrentPosition() {
            if (!navigator.geolocation) {
                showError('您的浏览器不支持地理位置API');
                return;
            }
            
            showMessage('正在获取位置...');
            
            const options = {
                enableHighAccuracy: true,     // 高精度模式
                timeout: 10000,              // 超时时间（毫秒）
                maximumAge: 0                // 不缓存位置
            };
            
            navigator.geolocation.getCurrentPosition(
                // 成功回调
                (position) => {
                    displayPosition(position);
                    addToHistory(position);
                    showOnMap(position);
                },
                // 失败回调
                (error) => {
                    handleGeolocationError(error);
                },
                // 选项
                options
            );
        }
        
        // 2. 持续监控位置变化
        function watchPosition() {
            if (!navigator.geolocation) {
                showError('您的浏览器不支持地理位置API');
                return;
            }
            
            if (watchId) {
                showMessage('已经在监控位置');
                return;
            }
            
            showMessage('开始监控位置变化...');
            
            const options = {
                enableHighAccuracy: true,
                timeout: 5000,
                maximumAge: 0
            };
            
            watchId = navigator.geolocation.watchPosition(
                (position) => {
                    displayPosition(position);
                    addToHistory(position);
                    updateMap(position);
                },
                (error) => {
                    handleGeolocationError(error);
                },
                options
            );
        }
        
        // 3. 停止监控
        function stopWatching() {
            if (watchId) {
                navigator.geolocation.clearWatch(watchId);
                watchId = null;
                showMessage('已停止监控位置');
            }
        }
        
        // 4. 清除位置信息
        function clearPosition() {
            document.getElementById('positionInfo').innerHTML = 
                '位置信息已清除';
            document.getElementById('positionHistory').innerHTML = '';
            positionHistory = [];
            
            if (map) {
                map.remove();
                map = null;
            }
        }
        
        // 5. 显示位置信息
        function displayPosition(position) {
            const coords = position.coords;
            const timestamp = new Date(position.timestamp);
            
            const info = `
                <h3>当前位置信息</h3>
                <p><strong>纬度:</strong> ${coords.latitude.toFixed(6)}</p>
                <p><strong>经度:</strong> ${coords.longitude.toFixed(6)}</p>
                <p><strong>精度:</strong> ±${coords.accuracy.toFixed(2)}米</p>
                ${coords.altitude ? `<p><strong>海拔:</strong> ${coords.altitude.toFixed(2)}米</p>` : ''}
                ${coords.altitudeAccuracy ? `<p><strong>海拔精度:</strong> ±${coords.altitudeAccuracy.toFixed(2)}米</p>` : ''}
                ${coords.heading ? `<p><strong>方向:</strong> ${coords.heading.toFixed(2)}°（北偏东）</p>` : ''}
                ${coords.speed ? `<p><strong>速度:</strong> ${(coords.speed * 3.6).toFixed(2)} km/h</p>` : ''}
                <p><strong>时间:</strong> ${timestamp.toLocaleString()}</p>
            `;
            
            document.getElementById('positionInfo').innerHTML = info;
        }
        
        // 6. 错误处理
        function handleGeolocationError(error) {
            let message = '';
            
            switch(error.code) {
                case error.PERMISSION_DENIED:
                    message = '用户拒绝了位置请求';
                    break;
                case error.POSITION_UNAVAILABLE:
                    message = '位置信息不可用';
                    break;
                case error.TIMEOUT:
                    message = '获取位置超时';
                    break;
                case error.UNKNOWN_ERROR:
                    message = '发生未知错误';
                    break;
            }
            
            showError(message);
        }
        
        // 7. 在地图上显示位置
        function showOnMap(position) {
            const coords = position.coords;
            
            if (!map) {
                // 初始化地图
                map = L.map('map').setView([coords.latitude, coords.longitude], 13);
                
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '© OpenStreetMap contributors'
                }).addTo(map);
            }
            
            // 清除旧标记
            map.eachLayer((layer) => {
                if (layer instanceof L.Marker) {
                    map.removeLayer(layer);
                }
            });
            
            // 添加新标记
            L.marker([coords.latitude, coords.longitude])
                .addTo(map)
                .bindPopup('您的位置')
                .openPopup();
            
            // 添加精度圆圈
            L.circle([coords.latitude, coords.longitude], {
                color: 'red',
                fillColor: '#f03',
                fillOpacity: 0.2,
                radius: coords.accuracy
            }).addTo(map);
        }
        
        // 8. 更新地图位置
        function updateMap(position) {
            if (!map) return;
            
            const coords = position.coords;
            
            // 移动地图中心
            map.setView([coords.latitude, coords.longitude]);
            
            // 添加轨迹点
            L.circleMarker([coords.latitude, coords.longitude], {
                radius: 3,
                fillColor: 'blue',
                color: 'blue',
                weight: 1,
                opacity: 0.5,
                fillOpacity: 0.5
            }).addTo(map);
        }
        
        // 9. 添加到历史记录
        function addToHistory(position) {
            const coords = position.coords;
            const timestamp = new Date(position.timestamp);
            
            const historyItem = {
                latitude: coords.latitude,
                longitude: coords.longitude,
                accuracy: coords.accuracy,
                timestamp: timestamp
            };
            
            positionHistory.push(historyItem);
            
            // 只保留最近10条记录
            if (positionHistory.length > 10) {
                positionHistory.shift();
            }
            
            // 更新历史显示
            const historyList = document.getElementById('positionHistory');
            historyList.innerHTML = '';
            
            positionHistory.forEach((item, index) => {
                const li = document.createElement('li');
                li.innerHTML = `
                    ${index + 1}. 纬度: ${item.latitude.toFixed(6)}, 
                    经度: ${item.longitude.toFixed(6)}, 
                    精度: ±${item.accuracy.toFixed(2)}米,
                    时间: ${item.timestamp.toLocaleTimeString()}
                `;
                historyList.appendChild(li);
            });
        }
        
        // 10. 计算距离
        function calculateDistance(lat1, lon1, lat2, lon2) {
            const R = 6371; // 地球半径（公里）
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = 
                Math.sin(dLat/2) * Math.sin(dLat/2) +
                Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c * 1000; // 返回米
        }
        
        // 11. 工具函数
        function showMessage(message) {
            document.getElementById('positionInfo').innerHTML = 
                `<p>${message}</p>`;
        }
        
        function showError(message) {
            document.getElementById('positionInfo').innerHTML = 
                `<p class="error">错误: ${message}</p>`;
        }
        
        // 12. 页面加载时检查权限
        document.addEventListener('DOMContentLoaded', () => {
            if (!navigator.geolocation) {
                showError('您的浏览器不支持地理位置API');
                return;
            }
            
            // 检查权限状态
            if (navigator.permissions) {
                navigator.permissions.query({ name: 'geolocation' })
                    .then(permissionStatus => {
                        console.log('地理位置权限状态:', permissionStatus.state);
                        
                        permissionStatus.onchange = () => {
                            console.log('权限状态变化为:', permissionStatus.state);
                        };
                    });
            }
        });
        
        // 13. 使用高德地图API（备用方案）
        function showOnAMap(latitude, longitude) {
            // 加载高德地图API
            const script = document.createElement('script');
            script.src = `https://webapi.amap.com/maps?v=2.0&key=YOUR_KEY&plugin=AMap.Geolocation`;
            document.head.appendChild(script);
            
            script.onload = () => {
                const map = new AMap.Map('map', {
                    zoom: 13,
                    center: [longitude, latitude]
                });
                
                new AMap.Marker({
                    position: [longitude, latitude],
                    map: map
                });
            };
        }
    </script>
    
    <!-- 加载Leaflet地图库 -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
</body>
</html>
```

## 5.6 其他重要概念

### 1. meta 标签常用属性

**代码示例**：

```html
<head>
    <!-- 1. 字符编码 -->
    <meta charset="UTF-8">
    
    <!-- 2. 视口设置（响应式） -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, minimum-scale=1.0, viewport-fit=cover">
    
    <!-- 3. SEO相关 -->
    <meta name="description" content="网站描述，150-160字符">
    <meta name="keywords" content="关键词1,关键词2,关键词3">
    <meta name="author" content="作者名">
    <meta name="robots" content="index, follow">
    <meta name="googlebot" content="index, follow">
    
    <!-- 4. 社交分享 -->
    <!-- Open Graph（Facebook） -->
    <meta property="og:title" content="页面标题">
    <meta property="og:description" content="页面描述">
    <meta property="og:image" content="https://example.com/image.jpg">
    <meta property="og:url" content="https://example.com/page">
    <meta property="og:type" content="website">
    <meta property="og:site_name" content="网站名称">
    
    <!-- Twitter Cards -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@username">
    <meta name="twitter:creator" content="@creator">
    <meta name="twitter:title" content="页面标题">
    <meta name="twitter:description" content="页面描述">
    <meta name="twitter:image" content="https://example.com/image.jpg">
    
    <!-- 5. PWA应用 -->
    <meta name="theme-color" content="#2196f3">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="应用名称">
    <link rel="apple-touch-icon" href="/icons/icon-192.png">
    
    <!-- 6. 安全相关 -->
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'">
    <meta http-equiv="X-Content-Type-Options" content="nosniff">
    <meta http-equiv="X-Frame-Options" content="DENY">
    <meta http-equiv="X-XSS-Protection" content="1; mode=block">
    <meta name="referrer" content="strict-origin-when-cross-origin">
    
    <!-- 7. 浏览器兼容 -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <!-- 8. 刷新和重定向 -->
    <!-- 5秒后刷新 -->
    <meta http-equiv="refresh" content="5">
    <!-- 5秒后跳转 -->
    <meta http-equiv="refresh" content="5;url=https://example.com/new-page">
    
    <!-- 9. 移动端特定 -->
    <meta name="format-detection" content="telephone=no">
    <meta name="format-detection" content="date=no">
    <meta name="format-detection" content="address=no">
    <meta name="format-detection" content="email=no">
    
    <!-- 10. 搜索引擎验证 -->
    <meta name="google-site-verification" content="verification_token">
    <meta name="baidu-site-verification" content="verification_code">
    <meta name="msvalidate.01" content="verification_code">
    
    <!-- 11. RSS/Atom -->
    <link rel="alternate" type="application/rss+xml" title="RSS" href="/rss.xml">
    <link rel="alternate" type="application/atom+xml" title="Atom" href="/atom.xml">
    
    <!-- 12. 暗黑模式 -->
    <meta name="color-scheme" content="light dark">
    <meta name="supported-color-schemes" content="light dark">
    
    <!-- 13. 页面分类 -->
    <meta name="rating" content="general">
    <meta name="classification" content="technology">
    
    <!-- 14. 版权信息 -->
    <meta name="copyright" content="© 2024 公司名称">
    
    <!-- 15. 生成工具 -->
    <meta name="generator" content="Next.js">
</head>
```

### 2. viewport 设置

**代码示例**：

```html
<!-- 基本响应式设置 -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- 禁止缩放 -->
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

<!-- 适应刘海屏 -->
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">

<!-- 不同的设备适配 -->
<meta name="viewport" content="width=1200"> <!-- 固定宽度 -->
<meta name="viewport" content="width=device-width, initial-scale=1.5"> <!-- 放大 -->

<!-- 动态设置viewport -->
<script>
    // 根据设备动态设置viewport
    function setViewport() {
        const viewport = document.querySelector('meta[name="viewport"]');
        
        // 检测设备类型
        const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
        
        if (isMobile) {
            // 移动端：允许缩放
            viewport.setAttribute('content', 
                'width=device-width, initial-scale=1.0, maximum-scale=5.0');
        } else {
            // 桌面端：固定布局
            viewport.setAttribute('content', 'width=1200');
        }
    }
    
    // 检测横竖屏
    function handleOrientation() {
        const viewport = document.querySelector('meta[name="viewport"]');
        
        if (window.matchMedia("(orientation: portrait)").matches) {
            // 竖屏
            viewport.setAttribute('content', 
                'width=device-width, initial-scale=1.0');
        } else {
            // 横屏
            viewport.setAttribute('content', 
                'width=device-width, initial-scale=0.8');
        }
    }
    
    // 监听设备像素比
    function handleDPR() {
        const dpr = window.devicePixelRatio || 1;
        const viewport = document.querySelector('meta[name="viewport"]');
        
        if (dpr > 1) {
            // 高DPI设备
            const scale = 1 / dpr;
            viewport.setAttribute('content', 
                `width=device-width, initial-scale=${scale}, maximum-scale=${scale}`);
        }
    }
</script>
```

### 3. 暗黑模式实现

**代码示例**：

```html
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="color-scheme" content="light dark">
    <title>暗黑模式示例</title>
    
    <style>
        :root {
            /* 浅色主题变量 */
            --bg-color: #ffffff;
            --text-color: #333333;
            --primary-color: #007bff;
            --border-color: #dee2e6;
            --card-bg: #f8f9fa;
            --shadow: rgba(0, 0, 0, 0.1);
            
            /* 间距变量 */
            --spacing-sm: 8px;
            --spacing-md: 16px;
            --spacing-lg: 24px;
        }
        
        [data-theme="dark"] {
            /* 深色主题变量 */
            --bg-color: #121212;
            --text-color: #e0e0e0;
            --primary-color: #bb86fc;
            --border-color: #333333;
            --card-bg: #1e1e1e;
            --shadow: rgba(0, 0, 0, 0.3);
        }
        
        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            transition: background-color 0.3s ease, color 0.3s ease;
            font-family: Arial, sans-serif;
            margin: 0;
            padding: var(--spacing-md);
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: var(--spacing-lg) 0;
            border-bottom: 1px solid var(--border-color);
        }
        
        .theme-toggle {
            background: var(--primary-color);
            color: white;
            border: none;
            padding: var(--spacing-sm) var(--spacing-md);
            border-radius: 4px;
            cursor: pointer;
            transition: opacity 0.2s;
        }
        
        .theme-toggle:hover {
            opacity: 0.9;
        }
        
        .card {
            background: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: var(--spacing-lg);
            margin: var(--spacing-md) 0;
            box-shadow: 0 2px 8px var(--shadow);
        }
        
        .form-group {
            margin-bottom: var(--spacing-md);
        }
        
        input, textarea, select {
            width: 100%;
            padding: var(--spacing-sm);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background: var(--bg-color);
            color: var(--text-color);
            box-sizing: border-box;
        }
        
        /* 系统主题跟随 */
        @media (prefers-color-scheme: dark) {
            :root:not([data-theme]) {
                --bg-color: #121212;
                --text-color: #e0e0e0;
                --primary-color: #bb86fc;
                --border-color: #333333;
                --card-bg: #1e1e1e;
                --shadow: rgba(0, 0, 0, 0.3);
            }
        }
        
        /* 打印样式 */
        @media print {
            .theme-toggle {
                display: none;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header class="header">
            <h1>暗黑模式示例</h1>
            <button class="theme-toggle" onclick="toggleTheme()">
                切换主题
            </button>
        </header>
        
        <main>
            <div class="card">
                <h2>关于暗黑模式</h2>
                <p>暗黑模式可以减少眼睛疲劳，节省电池电量（OLED屏幕），并提供更好的夜间阅读体验。</p>
            </div>
            
            <div class="card">
                <h2>用户设置</h2>
                <div class="form-group">
                    <label>用户名</label>
                    <input type="text" placeholder="请输入用户名">
                </div>
                
                <div class="form-group">
                    <label>主题偏好</label>
                    <select onchange="changeTheme(this.value)">
                        <option value="auto">跟随系统</option>
                        <option value="light">浅色主题</option>
                        <option value="dark">深色主题</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label>个人简介</label>
                    <textarea rows="4" placeholder="请输入个人简介"></textarea>
                </div>
            </div>
        </main>
    </div>
    
    <script>
        // 1. 获取当前主题
        function getCurrentTheme() {
            // 检查localStorage
            const savedTheme = localStorage.getItem('theme');
            
            // 检查系统偏好
            const systemPrefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
            
            // 优先级：localStorage > 系统设置
            return savedTheme || (systemPrefersDark ? 'dark' : 'light');
        }
        
        // 2. 设置主题
        function setTheme(theme) {
            const html = document.documentElement;
            
            // 更新data-theme属性
            html.setAttribute('data-theme', theme);
            
            // 保存到localStorage
            localStorage.setItem('theme', theme);
            
            // 更新meta标签（可选）
            const metaThemeColor = document.querySelector('meta[name="theme-color"]');
            if (metaThemeColor) {
                metaThemeColor.content = theme === 'dark' ? '#121212' : '#ffffff';
            }
            
            // 发送自定义事件
            document.dispatchEvent(new CustomEvent('themeChange', { detail: { theme } }));
        }
        
        // 3. 切换主题
        function toggleTheme() {
            const currentTheme = getCurrentTheme();
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            setTheme(newTheme);
        }
        
        // 4. 监听系统主题变化
        window.matchMedia('(prefers-color-scheme: dark)').addListener((e) => {
            // 只有在没有用户偏好设置时才跟随系统
            if (!localStorage.getItem('theme')) {
                setTheme(e.matches ? 'dark' : 'light');
            }
        });
        
        // 5. 下拉选择主题
        function changeTheme(value) {
            if (value === 'auto') {
                // 清除用户偏好，跟随系统
                localStorage.removeItem('theme');
                const systemPrefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
                setTheme(systemPrefersDark ? 'dark' : 'light');
            } else {
                setTheme(value);
            }
        }
        
        // 6. 初始化主题
        function initTheme() {
            const theme = getCurrentTheme();
            setTheme(theme);
            
            // 设置下拉框状态
            const select = document.querySelector('select');
            if (select) {
                select.value = localStorage.getItem('theme') || 'auto';
            }
            
            // 添加transition类（避免初始加载时的过渡效果）
            setTimeout(() => {
                document.body.classList.add('theme-transition');
            }, 100);
        }
        
        // 7. 页面加载时初始化
        document.addEventListener('DOMContentLoaded', initTheme);
        
        // 8. 平滑过渡（避免闪烁）
        // 在CSS中使用 transition 属性
        
        // 9. 与iframe通信
        function syncThemeWithIframes() {
            const iframes = document.querySelectorAll('iframe');
            const theme = getCurrentTheme();
            
            iframes.forEach(iframe => {
                try {
                    iframe.contentWindow.postMessage({ 
                        type: 'THEME_CHANGE', 
                        theme 
                    }, '*');
                } catch (e) {
                    // 跨域限制
                }
            });
        }
        
        // 监听iframe消息
        window.addEventListener('message', (e) => {
            if (e.data.type === 'THEME_REQUEST') {
                e.source.postMessage({ 
                    type: 'THEME_RESPONSE', 
                    theme: getCurrentTheme() 
                }, '*');
            }
        });
        
        // 10. 主题变化时更新iframe
        document.addEventListener('themeChange', syncThemeWithIframes);
        
        // 11. 媒体查询检测
        function detectColorScheme() {
            const isDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
            const isLight = window.matchMedia('(prefers-color-scheme: light)').matches;
            const isNoPreference = window.matchMedia('(prefers-color-scheme: no-preference)').matches;
            
            console.log('系统主题偏好:', {
                isDark, isLight, isNoPreference
            });
        }
    </script>
</body>
</html>
```

由于篇幅限制，我将剩余的部分（SEO优化、无障碍访问、国际化、manifest等）的实现示例整理如下：

### 4. SEO优化HTML结构

```html
<!DOCTYPE html>
<html lang="zh-CN" itemscope itemtype="https://schema.org/WebPage">
<head>
    <!-- 基础SEO -->
    <meta charset="UTF-8">
    <title>产品名称 - 主要关键词 | 公司名称</title>
    <meta name="description" content="产品描述，包含主要关键词，150-160字符">
    <meta name="keywords" content="关键词1,关键词2,关键词3">
    
    <!-- 结构化数据 -->
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "Product",
        "name": "产品名称",
        "description": "产品详细描述",
        "brand": {
            "@type": "Brand",
            "name": "品牌名称"
        },
        "offers": {
            "@type": "Offer",
            "price": "99.99",
            "priceCurrency": "CNY"
        }
    }
    </script>
</head>
<body>
    <!-- 语义化结构 -->
    <header role="banner">
        <nav aria-label="主导航">
            <ul>
                <li><a href="/">首页</a></li>
                <li><a href="/products">产品</a></li>
            </ul>
        </nav>
    </header>
    
    <main>
        <!-- 面包屑导航 -->
        <nav aria-label="面包屑导航">
            <ol>
                <li><a href="/">首页</a></li>
                <li><a href="/products">产品</a></li>
                <li>当前产品</li>
            </ol>
        </nav>
        
        <!-- 主要内容 -->
        <article>
            <h1>产品标题</h1>
            <p>产品详细描述...</p>
            
            <!-- 图片优化 -->
            <img src="product.jpg" 
                 alt="产品名称的特写照片，展示主要功能"
                 width="800" 
                 height="600">
        </article>
        
        <!-- 相关文章 -->
        <aside aria-label="相关内容">
            <h2>相关产品</h2>
            <ul>
                <li><a href="/related-product1">相关产品1</a></li>
            </ul>
        </aside>
    </main>
    
    <!-- 页脚 -->
    <footer role="contentinfo">
        <address>
            联系地址：<a href="mailto:contact@example.com">contact@example.com</a>
        </address>
    </footer>
    
    <!-- 无障碍跳过链接 -->
    <a href="#main" class="skip-link">跳转到主要内容</a>
</body>
</html>
```

### 5. 无障碍访问（a11y）

```html
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <title>无障碍访问示例</title>
    <style>
        .skip-link {
            position: absolute;
            top: -40px;
            left: 0;
            background: #000;
            color: white;
            padding: 8px;
            z-index: 100;
        }
        
        .skip-link:focus {
            top: 0;
        }
        
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }
    </style>
</head>
<body>
    <!-- 跳过链接 -->
    <a href="#main" class="skip-link">跳转到主要内容</a>
    
    <!-- 导航 -->
    <nav aria-label="主要导航">
        <ul role="menubar">
            <li role="none"><a href="#" role="menuitem">首页</a></li>
        </ul>
    </nav>
    
    <!-- 主要内容 -->
    <main id="main" role="main">
        <h1>无障碍示例</h1>
        
        <!-- 图片 -->
        <img src="image.jpg" 
             alt="描述图片内容"
             aria-describedby="image-desc">
        <p id="image-desc">详细的图片描述</p>
        
        <!-- 表单 -->
        <form>
            <label for="name">
                姓名
                <span class="sr-only">（必填）</span>
            </label>
            <input type="text" 
                   id="name" 
                   required
                   aria-required="true"
                   aria-invalid="false"
                   aria-describedby="name-help">
            <p id="name-help">请输入您的全名</p>
            
            <!-- 错误状态 -->
            <div role="alert" id="error-message" hidden>
                表单有错误，请检查
            </div>
        </form>
        
        <!-- 动态内容 -->
        <div role="status" 
             aria-live="polite"
             aria-atomic="true">
            内容加载中...
        </div>
        
        <!-- 表格 -->
        <table>
            <caption>用户数据表</caption>
            <thead>
                <tr>
                    <th scope="col">姓名</th>
                    <th scope="col">年龄</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td scope="row">张三</td>
                    <td>25</td>
                </tr>
            </tbody>
        </table>
        
        <!-- 按钮 -->
        <button aria-expanded="false" 
                aria-controls="more-content">
            显示更多
        </button>
        <div id="more-content" hidden>
            更多内容...
        </div>
    </main>
    
    <!-- 页脚 -->
    <footer role="contentinfo">
        <!-- 键盘导航指示 -->
        <p>使用 Tab 键进行导航</p>
    </footer>
    
    <script>
        // 焦点管理
        function trapFocus(element) {
            const focusableElements = element.querySelectorAll(
                'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
            );
            const firstFocusable = focusableElements[0];
            const lastFocusable = focusableElements[focusableElements.length - 1];
            
            element.addEventListener('keydown', (e) => {
                if (e.key === 'Tab') {
                    if (e.shiftKey) {
                        if (document.activeElement === firstFocusable) {
                            lastFocusable.focus();
                            e.preventDefault();
                        }
                    } else {
                        if (document.activeElement === lastFocusable) {
                            firstFocusable.focus();
                            e.preventDefault();
                        }
                    }
                }
            });
        }
        
        // ARIA实时区域更新
        function updateLiveRegion(message) {
            const liveRegion = document.querySelector('[aria-live]');
            liveRegion.textContent = message;
        }
        
        // 高对比度支持
        const prefersContrast = window.matchMedia('(prefers-contrast: high)');
        if (prefersContrast.matches) {
            document.documentElement.classList.add('high-contrast');
        }
    </script>
</body>
</html>
```

### 6. 国际化（i18n）

```html
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title data-i18n="title">多语言示例</title>
</head>
<body>
    <!-- 语言切换 -->
    <div>
        <button onclick="changeLanguage('zh-CN')">中文</button>
        <button onclick="changeLanguage('en-US')">English</button>
        <button onclick="changeLanguage('ja-JP')">日本語</button>
    </div>
    
    <!-- 内容 -->
    <h1 data-i18n="welcome">欢迎</h1>
    <p data-i18n="description">这是一个多语言示例</p>
    
    <!-- 日期格式 -->
    <p data-i18n-date="2024-01-15"></p>
    
    <!-- 数字格式 -->
    <p data-i18n-number="1234.56"></p>
    
    <!-- 复数形式 -->
    <p data-i18n="itemCount" data-i18n-count="1"></p>
    
    <script>
        // 翻译数据
        const translations = {
            'zh-CN': {
                'title': '多语言示例',
                'welcome': '欢迎',
                'description': '这是一个多语言示例',
                'itemCount': '你有 {count} 个项目'
            },
            'en-US': {
                'title': 'Multi-language Example',
                'welcome': 'Welcome',
                'description': 'This is a multi-language example',
                'itemCount': 'You have {count} item{plural}'
            },
            'ja-JP': {
                'title': '多言語の例',
                'welcome': 'ようこそ',
                'description': 'これは多言語の例です',
                'itemCount': 'あなたは{count}個のアイテムを持っています'
            }
        };
        
        // 当前语言
        let currentLang = localStorage.getItem('language') || 
                         navigator.language || 
                         'zh-CN';
        
        // 改变语言
        function changeLanguage(lang) {
            currentLang = lang;
            localStorage.setItem('language', lang);
            updateContent();
            updateHtmlLang();
        }
        
        // 更新内容
        function updateContent() {
            const langData = translations[currentLang];
            
            // 更新文本内容
            document.querySelectorAll('[data-i18n]').forEach(element => {
                const key = element.getAttribute('data-i18n');
                const count = element.getAttribute('data-i18n-count');
                
                if (langData[key]) {
                    let text = langData[key];
                    
                    // 处理复数
                    if (count !== null) {
                        text = text.replace('{count}', count);
                        text = text.replace('{plural}', parseInt(count) > 1 ? 's' : '');
                    }
                    
                    element.textContent = text;
                }
            });
            
            // 更新日期格式
            document.querySelectorAll('[data-i18n-date]').forEach(element => {
                const date = new Date(element.getAttribute('data-i18n-date'));
                element.textContent = formatDate(date, currentLang);
            });
            
            // 更新数字格式
            document.querySelectorAll('[data-i18n-number]').forEach(element => {
                const number = parseFloat(element.getAttribute('data-i18n-number'));
                element.textContent = formatNumber(number, currentLang);
            });
        }
        
        // 日期格式化
        function formatDate(date, lang) {
            const options = { 
                year: 'numeric', 
                month: 'long', 
                day: 'numeric' 
            };
            return date.toLocaleDateString(lang, options);
        }
        
        // 数字格式化
        function formatNumber(number, lang) {
            return number.toLocaleString(lang, {
                minimumFractionDigits: 2,
                maximumFractionDigits: 2
            });
        }
        
        // 更新html lang属性
        function updateHtmlLang() {
            document.documentElement.lang = currentLang;
        }
        
        // 初始化
        function initI18n() {
            updateHtmlLang();
            updateContent();
            
            // 监听语言变化
            document.addEventListener('languagechange', () => {
                currentLang = navigator.language;
                updateContent();
                updateHtmlLang();
            });
        }
        
        // 方向性语言支持
        function handleDirection() {
            const rtlLanguages = ['ar', 'he', 'fa'];
            const langCode = currentLang.split('-')[0];
            
            if (rtlLanguages.includes(langCode)) {
                document.body.dir = 'rtl';
            } else {
                document.body.dir = 'ltr';
            }
        }
        
        // 页面加载时初始化
        document.addEventListener('DOMContentLoaded', () => {
            initI18n();
            handleDirection();
        });
    </script>
</body>
</html>
```

### 7. manifest 文件作用

```plain
json
```

```plain
// manifest.json
{
  // 基础信息
  "name": "我的应用",
  "short_name": "应用",
  "description": "应用的详细描述",
  "lang": "zh-CN",
  "dir": "ltr",
  
  // 启动配置
  "start_url": "/",
  "scope": "/",
  "display": "standalone", // fullscreen, standalone, minimal-ui, browser
  "orientation": "portrait", // portrait, landscape, any
  
  // 主题颜色
  "theme_color": "#2196f3",
  "background_color": "#ffffff",
  
  // 图标配置
  "icons": [
    {
      "src": "/icons/icon-72x72.png",
      "sizes": "72x72",
      "type": "image/png",
      "purpose": "any"
    },
    {
      "src": "/icons/icon-192x192.png",
      "sizes": "192x192",
      "type": "image/png",
      "purpose": "any maskable"
    },
    {
      "src": "/icons/icon-512x512.png",
      "sizes": "512x512",
      "type": "image/png"
    }
  ],
  
  // 快捷方式
  "shortcuts": [
    {
      "name": "新建项目",
      "short_name": "新建",
      "description": "创建新项目",
      "url": "/new",
      "icons": [{ "src": "/icons/new-96x96.png", "sizes": "96x96" }]
    }
  ],
  
  // 截图（应用商店展示）
  "screenshots": [
    {
      "src": "/screenshots/home.png",
      "sizes": "1280x720",
      "type": "image/png",
      "form_factor": "wide"
    }
  ],
  
  // 类别
  "categories": ["productivity", "utilities"],
  
  // 关联应用
  "related_applications": [
    {
      "platform": "play",
      "url": "https://play.google.com/store/apps/details?id=com.example.app"
    }
  ],
  
  // 偏好应用
  "prefer_related_applications": false,
  
  // 协议处理
  "protocol_handlers": [
    {
      "protocol": "web+myapp",
      "url": "/open?url=%s"
    }
  ]
}
```

```html
<!-- HTML中链接manifest -->
<head>
    <link rel="manifest" href="/manifest.json">
    
    <!-- iOS特定 -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon" href="/icons/icon-192.png">
    
    <!-- Windows特定 -->
    <meta name="msapplication-TileColor" content="#2196f3">
    <meta name="msapplication-TileImage" content="/icons/icon-144.png">
</head>
```

```plain
javascript
```

```plain
// 注册Service Worker并处理安装
if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
        navigator.serviceWorker.register('/sw.js')
            .then(registration => {
                console.log('Service Worker 注册成功');
                
                // 检查是否有更新
                registration.addEventListener('updatefound', () => {
                    const newWorker = registration.installing;
                    newWorker.addEventListener('statechange', () => {
                        if (newWorker.state === 'installed') {
                            if (navigator.serviceWorker.controller) {
                                // 显示更新提示
                                showUpdatePrompt();
                            } else {
                                // 首次安装
                                console.log('应用已准备好离线使用');
                            }
                        }
                    });
                });
            });
    });
}

// 添加到主屏幕
let deferredPrompt;
window.addEventListener('beforeinstallprompt', (e) => {
    // 阻止浏览器自动显示安装提示
    e.preventDefault();
    deferredPrompt = e;
    
    // 显示自定义安装按钮
    showInstallButton();
});

function showInstallButton() {
    const installButton = document.createElement('button');
    installButton.textContent = '安装应用';
    installButton.onclick = () => {
        if (deferredPrompt) {
            deferredPrompt.prompt();
            deferredPrompt.userChoice.then((choiceResult) => {
                if (choiceResult.outcome === 'accepted') {
                    console.log('用户接受了安装提示');
                }
                deferredPrompt = null;
            });
        }
    };
    document.body.appendChild(installButton);
}
```