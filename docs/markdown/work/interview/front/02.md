# 二、ES6+

## 2.1 变量声明

### 1. let、const、var 的区别？

**回答：**

*   **var**：函数作用域，会变量提升，可重复声明
    
*   **let**：块级作用域，存在暂时性死区，不可重复声明
    
*   **const**：块级作用域，声明时必须初始化，值不可重新赋值（但对象属性可修改）
    

```javascript
// var 示例
console.log(a); // undefined，变量提升
var a = 1;
var a = 2; // 可重复声明

// let 示例
{
  let b = 1;
  console.log(b); // 1
}
// console.log(b); // 报错：b is not defined

// const 示例
const c = { name: "John" };
c.name = "Jane"; // 可以修改属性
// c = {}; // 报错：Assignment to constant variable
```

### 2. 什么是暂时性死区（TDZ）？

**回答：** 在代码块内，使用 `let/const` 声明变量之前，该变量都不可访问，直到声明位置。

```javascript
console.log(myVar); // undefined
var myVar = 1;

// console.log(myLet); // 报错：Cannot access 'myLet' before initialization
let myLet = 2;

{
  // TDZ 开始
  // console.log(tmp); // 报错
  let tmp = "hello"; // TDZ 结束
  console.log(tmp); // "hello"
}
```

### 3. 块级作用域是什么？

**回答：** 由 `{}` 创建的独立作用域，`let/const` 声明的变量只在块内有效。

```javascript
// ES5 var 的问题
for (var i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 0); // 3 3 3
}

// ES6 let 解决
for (let j = 0; j < 3; j++) {
  setTimeout(() => console.log(j), 0); // 0 1 2
}

// 块级作用域示例
{
  let blockScoped = "inside";
  const PI = 3.14;
}
// console.log(blockScoped); // 报错
```

## 2.2 箭头函数

### 1. 箭头函数和普通函数的区别？

**回答：**

*   箭头函数没有自己的 `this`，继承父级作用域的 `this`
    
*   没有 `arguments` 对象，可用剩余参数 `...args`
    
*   不能用作构造函数，没有 `prototype`
    
*   不能使用 `yield`，不能作为生成器函数
    

```javascript
// 语法对比
const add = (a, b) => a + b; // 箭头函数
function add(a, b) { return a + b; } // 普通函数

// this 绑定示例
const obj = {
  name: "obj",
  regular: function() {
    console.log(this.name); // "obj"
  },
  arrow: () => {
    console.log(this.name); // undefined（取决于外层作用域）
  }
};

// 构造函数示例
function Person(name) { this.name = name; }
const person = new Person("John"); // 正常

const Animal = (name) => { this.name = name; };
// const animal = new Animal("Cat"); // 报错：Animal is not a constructor
```

### 2. 箭头函数的 this 指向规则？

**回答：** 箭头函数的 `this` 在定义时确定，继承自外层第一个普通函数的 `this`，且不会被改变。

```javascript
// 示例1
const obj = {
  name: "obj",
  regularFunc: function() {
    setTimeout(function() {
      console.log(this.name); // undefined，this指向window
    }, 100);
  },
  arrowFunc: function() {
    setTimeout(() => {
      console.log(this.name); // "obj"，继承arrowFunc的this
    }, 100);
  }
};

// 示例2：DOM事件
document.addEventListener('click', function() {
  console.log(this); // document
  
  setTimeout(() => {
    console.log(this); // document，继承外层this
  }, 100);
});
```

### 3. 箭头函数能用做构造函数吗？

**回答：** 不能，箭头函数没有 `prototype` 属性，不能使用 `new` 关键字。

```javascript
// 普通函数可作构造函数
function Person(name) {
  this.name = name;
}
Person.prototype.sayHello = function() {
  console.log(`Hello, ${this.name}`);
};

// 箭头函数不能
const Animal = (name) => {
  this.name = name; // 无效
};

console.log(Person.prototype); // {constructor: ƒ}
console.log(Animal.prototype); // undefined

const person = new Person("Alice"); // 正常
// const animal = new Animal("Dog"); // 报错
```

## 2.3 解构赋值

### 1. 数组解构和对象解构的语法？

**回答：** 按照模式匹配，从数组或对象中提取值。

```javascript
// 数组解构
const [first, second, ...rest] = [1, 2, 3, 4, 5];
console.log(first); // 1
console.log(rest); // [3, 4, 5]

// 交换变量
let a = 1, b = 2;
[a, b] = [b, a]; // a=2, b=1

// 对象解构
const user = { name: "John", age: 30 };
const { name, age } = user;
console.log(name); // "John"

// 重命名
const { name: userName, age: userAge } = user;
console.log(userName); // "John"

// 嵌套解构
const data = { 
  user: { 
    info: { 
      id: 1, 
      email: "test@example.com" 
    } 
  } 
};
const { user: { info: { id, email } } } = data;
```

### 2. 解构赋值的默认值如何设置？

**回答：** 在解构模式中使用 `=` 设置默认值。

```javascript
// 数组解构默认值
const [x = 1, y = 2] = [undefined, 5];
console.log(x, y); // 1, 5

// 对象解构默认值
const { name = "Anonymous", age = 18 } = { name: "John" };
console.log(name, age); // "John", 18

// 函数参数解构默认值
function greet({ name = "Guest", greeting = "Hello" } = {}) {
  console.log(`${greeting}, ${name}!`);
}
greet(); // "Hello, Guest!"
greet({ name: "Alice" }); // "Hello, Alice!"
```

### 3. 如何在函数参数中使用解构？

**回答：** 直接在参数位置使用解构语法。

```javascript
// 数组参数解构
function sum([a, b, c = 0]) {
  return a + b + c;
}
console.log(sum([1, 2])); // 3

// 对象参数解构
function createUser({ name, age, email = "default@email.com" }) {
  return { name, age, email };
}

const user = createUser({ name: "John", age: 25 });
console.log(user); // {name: "John", age: 25, email: "default@email.com"}

// 与默认值结合
function drawChart({ 
  size = "big", 
  coords = { x: 0, y: 0 }, 
  radius = 25 
} = {}) {
  console.log(size, coords, radius);
}

drawChart(); // "big" {x: 0, y: 0} 25
```

## 2.4 模板字符串

### 1. 模板字符串的优势？

**回答：**

1.  支持多行字符串
    
2.  支持变量插值 `${expression}`
    
3.  支持标签模板（高级用法）
    

```javascript
// 多行字符串
const multiLine = `这是第一行
这是第二行
这是第三行`;

// 变量插值
const name = "John";
const age = 25;
const message = `姓名: ${name}, 年龄: ${age}`;
console.log(message); // "姓名: John, 年龄: 25"

// 表达式计算
const a = 5, b = 10;
console.log(`${a} + ${b} = ${a + b}`); // "5 + 10 = 15"

// 调用函数
function greet(name) {
  return `Hello, ${name}`;
}
console.log(`${greet("Alice")}!`); // "Hello, Alice!"

// HTML模板
const items = ["Apple", "Banana", "Orange"];
const html = `
  <ul>
    ${items.map(item => `<li>${item}</li>`).join('')}
  </ul>
`;
```

### 2. 标签模板（Tagged Template）是什么？

**回答：** 一种函数调用方式，模板字符串前加函数名，用于自定义模板处理。

```javascript
// 基本用法
function tag(strings, ...values) {
  console.log(strings); // ["Hello ", "! Today is ", ""]
  console.log(values);  // ["John", "Monday"]
  return "Processed";
}

const name = "John";
const day = "Monday";
const result = tag`Hello ${name}! Today is ${day}`;

// 实际应用：SQL防注入
function sql(strings, ...values) {
  return strings.reduce((acc, str, i) => {
    return acc + str + (values[i] ? `'${values[i]}'` : '');
  }, '');
}

const userId = 123;
const query = sql`SELECT * FROM users WHERE id = ${userId}`;
// "SELECT * FROM users WHERE id = '123'"

// 样式处理
function highlight(strings, ...values) {
  return strings.reduce((acc, str, i) => {
    return acc + str + (values[i] ? `<span class="hl">${values[i]}</span>` : '');
  }, '');
}

const keyword = "important";
const text = highlight`This is ${keyword} information`;
// "This is <span class="hl">important</span> information"
```

### 3. 字符串新增的方法有哪些？

**回答：** ES6新增字符串方法包括：`includes()`、`startsWith()`、`endsWith()`、`repeat()`、`padStart()`、`padEnd()`等。

```javascript
const str = "Hello World";

// 1. includes() - 是否包含子串
console.log(str.includes("World")); // true
console.log(str.includes("world")); // false (区分大小写)

// 2. startsWith() - 是否以指定字符串开头
console.log(str.startsWith("Hello")); // true
console.log(str.startsWith("Hello", 0)); // true，从索引0开始检查

// 3. endsWith() - 是否以指定字符串结尾
console.log(str.endsWith("World")); // true
console.log(str.endsWith("Hello", 5)); // true，前5个字符是否以Hello结尾

// 4. repeat() - 重复字符串
console.log("ha".repeat(3)); // "hahaha"

// 5. padStart() / padEnd() - 字符串填充
console.log("5".padStart(3, "0")); // "005"
console.log("5".padEnd(3, "0"));   // "500"

// 6. trimStart() / trimEnd() - 去空格
const spaceStr = "  hello  ";
console.log(spaceStr.trimStart()); // "hello  "
console.log(spaceStr.trimEnd());   // "  hello"

// 7. String.raw - 原始字符串
console.log(`Hello\nWorld`); // 换行输出
console.log(String.raw`Hello\nWorld`); // "Hello\\nWorld"
```

## 2.5 扩展运算符

### 1. 扩展运算符的常见用途？

**回答：** 用于展开可迭代对象（数组、字符串、Set等）或对象属性。

```javascript
// 1. 数组展开
const arr1 = [1, 2, 3];
const arr2 = [4, 5, 6];
const combined = [...arr1, ...arr2]; // [1, 2, 3, 4, 5, 6]

// 2. 复制数组
const original = [1, 2, 3];
const copy = [...original]; // 浅拷贝

// 3. 函数调用传参
const numbers = [1, 2, 3];
console.log(Math.max(...numbers)); // 3

// 4. 字符串转数组
const str = "hello";
const chars = [...str]; // ["h", "e", "l", "l", "o"]

// 5. 对象展开（ES2018）
const obj1 = { a: 1, b: 2 };
const obj2 = { c: 3, d: 4 };
const merged = { ...obj1, ...obj2 }; // {a: 1, b: 2, c: 3, d: 4}

// 6. 对象浅拷贝
const user = { name: "John", age: 30 };
const userCopy = { ...user };

// 7. 合并并覆盖属性
const defaults = { theme: "light", fontSize: 14 };
const settings = { ...defaults, fontSize: 16 }; // 覆盖fontSize
```

### 2. 剩余参数（rest parameters）的作用？

**回答：** 将多个参数收集到一个数组中，替代 `arguments` 对象。

```javascript
// 1. 收集剩余参数
function sum(...numbers) {
  return numbers.reduce((acc, curr) => acc + curr, 0);
}
console.log(sum(1, 2, 3, 4)); // 10

// 2. 与普通参数结合
function concat(separator, ...strings) {
  return strings.join(separator);
}
console.log(concat("-", "a", "b", "c")); // "a-b-c"

// 3. 解构中的剩余参数
const [first, second, ...others] = [1, 2, 3, 4, 5];
console.log(first, second, others); // 1 2 [3, 4, 5]

const { name, ...rest } = { name: "John", age: 30, city: "NY" };
console.log(name, rest); // "John" {age: 30, city: "NY"}

// 4. 箭头函数使用（箭头函数没有arguments）
const multiply = (...nums) => nums.reduce((acc, n) => acc * n, 1);
console.log(multiply(2, 3, 4)); // 24
```

### 3. 展开运算符和剩余参数的区别？

**回答：**

*   **展开运算符**：将数组/对象展开为单个元素
    
*   **剩余参数**：将多个元素收集到一个数组中
    
*   都是 `...` 语法，但使用位置不同
    

```javascript
// 展开运算符（用于展开）
const arr = [1, 2, 3];
console.log(...arr); // 1 2 3（展开为三个参数）

// 剩余参数（用于收集）
function log(...args) { // 收集所有参数
  console.log(args); // [1, 2, 3]
}
log(1, 2, 3);

// 对比示例
const numbers = [1, 2, 3, 4, 5];
const [first, ...rest] = numbers; // 解构中的剩余参数
console.log(first); // 1
console.log(rest);  // [2, 3, 4, 5]

const newArr = [first, ...rest]; // 数组中的展开运算符
console.log(newArr); // [1, 2, 3, 4, 5]
```

## 2.6 数组新方法

### 1. Array.from() 和 Array.of() 的区别？

**回答：**

*   `Array.from()`: 将类数组或可迭代对象转为数组
    
*   `Array.of()`: 将一组参数转为数组，解决 `new Array()` 的问题
    

```javascript
// 1. Array.from()
// 类数组转数组
const arrayLike = { 0: 'a', 1: 'b', length: 2 };
console.log(Array.from(arrayLike)); // ['a', 'b']

// 字符串转数组
console.log(Array.from('hello')); // ['h', 'e', 'l', 'l', 'o']

// Set转数组
console.log(Array.from(new Set([1, 2, 2, 3]))); // [1, 2, 3]

// 带映射函数
console.log(Array.from([1, 2, 3], x => x * 2)); // [2, 4, 6]

// 2. Array.of()
// 解决 new Array() 的歧义
console.log(Array.of(7));      // [7]
console.log(new Array(7));     // [empty × 7]（长度为7的空数组）

console.log(Array.of(1, 2, 3)); // [1, 2, 3]
console.log(new Array(1, 2, 3)); // [1, 2, 3]

// 生成数字序列
console.log(Array.from({ length: 5 }, (_, i) => i + 1)); // [1, 2, 3, 4, 5]
```

### 2. find()、findIndex()、includes() 的区别？

**回答：**

*   `find()`: 返回第一个满足条件的元素
    
*   `findIndex()`: 返回第一个满足条件的元素索引
    
*   `includes()`: 检查是否包含某个元素（使用 SameValueZero 比较）
    

```javascript
const users = [
  { id: 1, name: 'John' },
  { id: 2, name: 'Jane' },
  { id: 3, name: 'Bob' }
];

// 1. find() - 返回元素
const user = users.find(u => u.id === 2);
console.log(user); // {id: 2, name: 'Jane'}

// 2. findIndex() - 返回索引
const index = users.findIndex(u => u.name === 'Bob');
console.log(index); // 2

// 3. includes() - 检查包含
const numbers = [1, 2, 3, NaN];
console.log(numbers.includes(2));    // true
console.log(numbers.includes(4));    // false
console.log(numbers.includes(NaN));  // true（与 indexOf 不同）

// 与 indexOf 对比
console.log(numbers.indexOf(NaN));   // -1（找不到NaN）
console.log(numbers.indexOf(2) !== -1); // true

// 实际应用
const inventory = [
  { name: 'apples', quantity: 2 },
  { name: 'bananas', quantity: 0 },
  { name: 'cherries', quantity: 5 }
];

// 找到第一个库存为0的商品
const outOfStock = inventory.find(item => item.quantity === 0);
// 检查是否有苹果
const hasApples = inventory.some(item => item.name === 'apples');
```

### 3. flat() 和 flatMap() 的作用？

**回答：**

*   `flat()`: 扁平化嵌套数组
    
*   `flatMap()`: 先映射再扁平化（只能扁平化一层）
    

```javascript
// 1. flat()
const nested = [1, [2, [3, [4]]]];
console.log(nested.flat());      // [1, 2, [3, [4]]]（默认深度1）
console.log(nested.flat(2));     // [1, 2, 3, [4]]
console.log(nested.flat(Infinity)); // [1, 2, 3, 4]

// 2. flatMap()
const arr = [1, 2, 3, 4];
// 普通 map + flat
const doubled = arr.map(x => [x * 2]); // [[2], [4], [6], [8]]
console.log(doubled.flat()); // [2, 4, 6, 8]

// 使用 flatMap
const flatMapped = arr.flatMap(x => [x * 2]);
console.log(flatMapped); // [2, 4, 6, 8]

// 实际应用：处理句子
const sentences = ["Hello world", "ES6 is great"];
const words = sentences.flatMap(sentence => sentence.split(' '));
console.log(words); // ["Hello", "world", "ES6", "is", "great"]

// 过滤并映射
const numbers = [1, 2, 3, 4, 5];
const result = numbers.flatMap(n => n % 2 === 0 ? [n * 2] : []);
console.log(result); // [4, 8]（只处理偶数）
```

### 4. at() 方法解决了什么问题？

**回答：** 解决负索引访问问题，更直观地访问数组元素。

```javascript
const arr = [10, 20, 30, 40, 50];

// 传统方式访问最后一个元素
console.log(arr[arr.length - 1]); // 50
console.log(arr.slice(-1)[0]);    // 50

// 使用 at() 方法
console.log(arr.at(-1)); // 50（最后一个元素）
console.log(arr.at(-2)); // 40（倒数第二个）
console.log(arr.at(0));  // 10（第一个）
console.log(arr.at(1));  // 20（第二个）

// 字符串也支持 at()
const str = "Hello";
console.log(str.at(-1)); // "o"
console.log(str.at(-2)); // "l"

// 对于稀疏数组
const sparse = [1, , 3];
console.log(sparse.at(1)); // undefined
```

## 2.7 对象新特性

### 1. 对象属性简写和计算属性名？

**回答：**

*   **属性简写**：属性名和变量名相同时可简写
    
*   **计算属性名**：使用 `[]` 动态定义属性名
    

```javascript
// 1. 属性简写
const name = "John";
const age = 30;

// ES5写法
const obj1 = {
  name: name,
  age: age,
  sayHello: function() {
    console.log("Hello");
  }
};

// ES6写法
const obj2 = {
  name,  // 等同于 name: name
  age,   // 等同于 age: age
  sayHello() {  // 方法简写
    console.log("Hello");
  }
};

// 2. 计算属性名
const propName = "firstName";
const dynamicKey = "dynamic";

const person = {
  [propName]: "John",  // 属性名动态计算
  ["last" + "Name"]: "Doe",
  [dynamicKey + "Key"]: "value",
  
  // 方法名也可动态
  ["say" + "Hello"]() {
    console.log("Hello");
  }
};

console.log(person.firstName); // "John"
console.log(person.dynamicKey); // "value"
person.sayHello(); // "Hello"

// 实际应用场景
function createObject(key, value) {
  return {
    [key]: value,
    [`${key}Length`]: value.length
  };
}

const obj = createObject("name", "Alice");
console.log(obj); // {name: "Alice", nameLength: 5}
```

### 2. Object.keys()、Object.values()、Object.entries() 的作用？

**回答：** 分别获取对象的键、值、键值对数组。

```javascript
const user = {
  name: "John",
  age: 30,
  city: "New York"
};

// 1. Object.keys() - 获取键数组
const keys = Object.keys(user);
console.log(keys); // ["name", "age", "city"]

// 2. Object.values() - 获取值数组
const values = Object.values(user);
console.log(values); // ["John", 30, "New York"]

// 3. Object.entries() - 获取键值对数组
const entries = Object.entries(user);
console.log(entries);
// [["name", "John"], ["age", 30], ["city", "New York"]]

// 实际应用
// 遍历对象
for (const [key, value] of Object.entries(user)) {
  console.log(`${key}: ${value}`);
}

// 对象转Map
const map = new Map(Object.entries(user));
console.log(map.get("name")); // "John"

// 过滤对象属性
const filtered = Object.entries(user)
  .filter(([key, value]) => typeof value === "string")
  .reduce((obj, [key, value]) => {
    obj[key] = value;
    return obj;
  }, {});

console.log(filtered); // {name: "John", city: "New York"}
```

### 3. Object.assign() 是深拷贝还是浅拷贝？

**回答：** 浅拷贝，只拷贝第一层属性。

```javascript
// 浅拷贝示例
const source = {
  name: "John",
  address: {
    city: "NY",
    street: "123 Main St"
  },
  hobbies: ["reading", "sports"]
};

const target = Object.assign({}, source);

// 修改第一层属性
target.name = "Jane";
console.log(source.name); // "John"（未受影响）

// 修改嵌套对象
target.address.city = "LA";
console.log(source.address.city); // "LA"（受影响！）

// 修改数组
target.hobbies.push("music");
console.log(source.hobbies); // ["reading", "sports", "music"]（受影响！）

// 实现简单深拷贝
const deepCopy = JSON.parse(JSON.stringify(source));

// 注意：Object.assign() 不能拷贝getter/setter
const objWithGetter = {
  get value() {
    return 42;
  }
};
const copied = Object.assign({}, objWithGetter);
console.log(copied.value); // 42（值被拷贝，getter没了）
```

### 4. 对象扩展运算符的用途？

**回答：** 对象展开（ES2018+），用于对象浅拷贝、合并等。

```javascript
// 1. 对象浅拷贝
const original = { a: 1, b: 2 };
const copy = { ...original };
console.log(copy); // {a: 1, b: 2}

// 2. 对象合并
const obj1 = { a: 1, b: 2 };
const obj2 = { b: 3, c: 4 };
const merged = { ...obj1, ...obj2 };
console.log(merged); // {a: 1, b: 3, c: 4}（后面的覆盖前面的）

// 3. 添加新属性
const base = { x: 1, y: 2 };
const extended = { ...base, z: 3 };
console.log(extended); // {x: 1, y: 2, z: 3}

// 4. 覆盖属性
const defaults = { theme: "light", fontSize: 14 };
const settings = { ...defaults, fontSize: 16 };
console.log(settings); // {theme: "light", fontSize: 16}

// 5. 条件添加属性
const condition = true;
const dynamicObj = {
  name: "John",
  ...(condition && { age: 30 }),  // 条件添加
  ...(condition ? { city: "NY" } : { city: "LA" })
};
console.log(dynamicObj); // {name: "John", age: 30, city: "NY"}

// 6. 移除属性（需配合解构）
const { password, ...userWithoutPassword } = { 
  name: "John", 
  email: "john@test.com", 
  password: "secret" 
};
console.log(userWithoutPassword); // {name: "John", email: "john@test.com"}

// 注意：只能拷贝可枚举的自有属性
const parent = { inherited: "parent" };
const child = Object.create(parent);
child.own = "child";

const spread = { ...child };
console.log(spread); // {own: "child"}（不会拷贝继承的属性）
```

## 2.8 异步编程

### 1. Promise.all、Promise.race、Promise.allSettled、Promise.any 的区别？

**回答：**

*   `Promise.all`: 所有成功才成功，一个失败就失败
    
*   `Promise.race`: 第一个完成（无论成功/失败）
    
*   `Promise.allSettled`: 所有都完成（无论成功/失败）
    
*   `Promise.any`: 第一个成功就成功，全部失败才失败
    

```javascript
// 创建测试promise
const success = (value, delay) => 
  new Promise(resolve => setTimeout(() => resolve(value), delay));
const failure = (reason, delay) => 
  new Promise((_, reject) => setTimeout(() => reject(reason), delay));

// 1. Promise.all
Promise.all([
  success("A", 100),
  success("B", 200),
  success("C", 300)
]).then(results => {
  console.log("All success:", results); // ["A", "B", "C"]（300ms后）
}).catch(err => {
  console.log("One failed:", err);
});

// 2. Promise.race
Promise.race([
  success("Fast", 100),
  success("Slow", 500),
  failure("Error", 200)
]).then(result => {
  console.log("Race winner:", result); // "Fast"（100ms后）
}).catch(err => {
  console.log("Race error:", err);
});

// 3. Promise.allSettled
Promise.allSettled([
  success("A", 100),
  failure("Error B", 200),
  success("C", 300)
]).then(results => {
  console.log("All settled:", results);
  // [
  //   {status: "fulfilled", value: "A"},
  //   {status: "rejected", reason: "Error B"},
  //   {status: "fulfilled", value: "C"}
  // ]
});

// 4. Promise.any
Promise.any([
  failure("Error 1", 100),
  success("Success!", 200),
  failure("Error 2", 300)
]).then(result => {
  console.log("Any success:", result); // "Success!"（200ms后）
}).catch(err => {
  console.log("All failed:", err.errors);
});

// Promise.any 全部失败
Promise.any([
  failure("Error A", 100),
  failure("Error B", 200)
]).catch(err => {
  console.log("All promises rejected:", err.errors); // ["Error A", "Error B"]
});
```

### 2. async/await 的优势和注意事项？

**回答：**  
**优势：**

1.  代码更简洁，类似同步代码
    
2.  错误处理更直观（try/catch）
    
3.  调试更方便
    

**注意事项：**

1.  await 只能在 async 函数中使用
    
2.  可能会阻塞代码执行（await 会等待）
    
3.  并行任务需要优化处理
    

```javascript
// 传统 Promise vs async/await

// Promise链式调用
function fetchDataPromise() {
  return fetchUser()
    .then(user => fetchPosts(user.id))
    .then(posts => fetchComments(posts[0].id))
    .catch(error => console.error("Error:", error));
}

// async/await
async function fetchDataAsync() {
  try {
    const user = await fetchUser();
    const posts = await fetchPosts(user.id);
    const comments = await fetchComments(posts[0].id);
    return comments;
  } catch (error) {
    console.error("Error:", error);
    throw error;
  }
}

// 模拟API
function fetchUser() {
  return new Promise(resolve => 
    setTimeout(() => resolve({ id: 1, name: "John" }), 100));
}
function fetchPosts() {
  return new Promise(resolve => 
    setTimeout(() => resolve([{ id: 101, title: "Post 1" }]), 100));
}
function fetchComments() {
  return new Promise(resolve => 
    setTimeout(() => resolve(["Great post!"]), 100));
}

// 注意事项1：await只能在async函数中
// const user = await fetchUser(); // 报错（除非在模块顶层）

// 注意事项2：for循环中的await
async function processItems(items) {
  for (const item of items) {
    await processItem(item); // 顺序执行，可能会慢
  }
  
  // 改进：并行执行
  await Promise.all(items.map(item => processItem(item)));
}

// 注意事项3：async函数总是返回Promise
async function getNumber() {
  return 42; // 自动包装为Promise
}
getNumber().then(value => console.log(value)); // 42
```

### 3. 如何用 async/await 并行处理多个异步任务？

**回答：** 使用 `Promise.all()` 或循环结合 `map()` 实现并行。

```javascript
// 1. 使用 Promise.all 并行
async function fetchAllData() {
  const urls = [
    'https://api.example.com/data1',
    'https://api.example.com/data2',
    'https://api.example.com/data3'
  ];
  
  // 错误写法（顺序执行）
  const results1 = [];
  for (const url of urls) {
    const data = await fetch(url); // 一个完成才下一个
    results1.push(data);
  }
  
  // 正确写法（并行执行）
  const promises = urls.map(url => fetch(url));
  const results2 = await Promise.all(promises); // 同时发起请求
  
  return results2;
}

// 2. 带错误处理的并行
async function fetchMultiple() {
  try {
    const [user, posts, comments] = await Promise.all([
      fetchUser(),
      fetchPosts(),
      fetchComments()
    ]);
    return { user, posts, comments };
  } catch (error) {
    console.error("One request failed:", error);
    // 可以在这里处理部分成功的情况
    throw error;
  }
}

// 3. 限制并发数
async function parallelWithLimit(tasks, limit) {
  const results = [];
  const executing = [];
  
  for (const task of tasks) {
    const p = task().then(result => {
      executing.splice(executing.indexOf(p), 1);
      return result;
    });
    
    results.push(p);
    executing.push(p);
    
    if (executing.length >= limit) {
      await Promise.race(executing);
    }
  }
  
  return Promise.all(results);
}

// 4. 使用 Promise.allSettled 处理部分失败
async function fetchWithSettled() {
  const results = await Promise.allSettled([
    fetch('/api/data1'),
    fetch('/api/data2'),
    fetch('/api/data3')
  ]);
  
  const successful = results
    .filter(r => r.status === 'fulfilled')
    .map(r => r.value);
    
  const failed = results
    .filter(r => r.status === 'rejected')
    .map(r => r.reason);
    
  return { successful, failed };
}
```

### 4. 顶层 await（Top-level await）是什么？

**回答：** 在模块顶层直接使用 await，无需包裹 async 函数。

```javascript
// 在ES模块中可以直接使用（需要type="module"）
// module.js
import { fetchData } from './api.js';

// 顶层await
const data = await fetchData();
console.log(data);

export { data };

// 另一个模块中使用
// main.js
import { data } from './module.js';
console.log("Data loaded:", data);

// 实际应用场景

// 1. 动态导入模块
const module = await import(`./modules/${dynamicName}.js`);

// 2. 初始化配置
const config = await fetch('/api/config.json');
const app = initializeApp(config);

// 3. 资源依赖
const translations = await fetch('/locales/en.json');
const user = await fetchUser();

// 注意：会影响模块加载顺序
// moduleA.js
console.log("Module A start");
await new Promise(resolve => setTimeout(resolve, 1000));
console.log("Module A end");

// moduleB.js  
console.log("Module B");

// main.js
import './moduleA.js'; // 会等待1秒
import './moduleB.js'; // 然后才加载B

// 错误处理
try {
  const data = await fetch('/api/data');
} catch (error) {
  console.error("Failed to load data:", error);
  // 可以设置默认值
  const data = { default: true };
}
```

## 2.9 Class 类

### 1. ES6 Class 的本质是什么？

**回答：** Class 是构造函数的语法糖，本质还是基于原型继承。

```javascript
// ES5 构造函数
function PersonES5(name) {
  this.name = name;
}
PersonES5.prototype.sayHello = function() {
  console.log("Hello, " + this.name);
};

// ES6 Class
class PersonES6 {
  constructor(name) {
    this.name = name;
  }
  
  sayHello() {
    console.log(`Hello, ${this.name}`);
  }
  
  // 静态方法
  static createAnonymous() {
    return new PersonES6("Anonymous");
  }
}

// 本质相同
const p1 = new PersonES5("John");
const p2 = new PersonES6("Jane");

console.log(typeof PersonES6); // "function"
console.log(PersonES6 === PersonES6.prototype.constructor); // true

// Class只是语法糖的证据
console.log(PersonES6.prototype.sayHello); // 方法在原型上
console.log(Object.getOwnPropertyNames(PersonES6.prototype)); // ["constructor", "sayHello"]

// 但不能直接调用
// PersonES6(); // 报错：Class constructor不能直接调用

// Class表达式
const Animal = class {
  constructor(name) {
    this.name = name;
  }
};

// 立即执行类
const instance = new (class {
  constructor(value) {
    this.value = value;
  }
})("test");

console.log(instance.value); // "test"
```

### 2. 如何实现继承？super 的作用？

**回答：** 使用 `extends` 关键字实现继承，`super` 用于调用父类构造函数和方法。

```javascript
// 父类
class Animal {
  constructor(name) {
    this.name = name;
    this.speed = 0;
  }
  
  run(speed) {
    this.speed = speed;
    console.log(`${this.name} runs at ${speed} km/h`);
  }
  
  stop() {
    this.speed = 0;
    console.log(`${this.name} stopped`);
  }
}

// 子类继承
class Rabbit extends Animal {
  constructor(name, earLength) {
    super(name); // 必须调用父类constructor
    this.earLength = earLength;
  }
  
  // 重写父类方法
  run(speed) {
    super.run(speed * 2); // 调用父类方法
    console.log("Rabbit runs faster!");
  }
  
  // 新增方法
  hide() {
    console.log(`${this.name} hides!`);
  }
}

// 使用
const rabbit = new Rabbit("White Rabbit", 10);
rabbit.run(5); // "White Rabbit runs at 10 km/h" "Rabbit runs faster!"
rabbit.hide(); // "White Rabbit hides!"
console.log(rabbit.earLength); // 10

// super在静态方法中
class Parent {
  static staticMethod() {
    return "Parent static";
  }
  
  instanceMethod() {
    return "Parent instance";
  }
}

class Child extends Parent {
  static staticMethod() {
    return super.staticMethod() + " extended";
  }
  
  instanceMethod() {
    return super.instanceMethod() + " extended";
  }
}

console.log(Child.staticMethod()); // "Parent static extended"
const child = new Child();
console.log(child.instanceMethod()); // "Parent instance extended"

// 继承内置类
class MyArray extends Array {
  isEmpty() {
    return this.length === 0;
  }
  
  // 覆盖内置方法
  map(callback) {
    console.log("Custom map called");
    return super.map(callback);
  }
}

const arr = new MyArray(1, 2, 3);
console.log(arr.isEmpty()); // false
console.log(arr.map(x => x * 2)); // [2, 4, 6]
```

### 3. 静态方法的作用和调用方式？

**回答：** 静态方法属于类本身，而不是实例，用于工具函数或工厂方法。

```javascript
class MathUtils {
  // 静态方法
  static add(a, b) {
    return a + b;
  }
  
  static multiply(a, b) {
    return a * b;
  }
  
  // 静态属性（ES2022）
  static PI = 3.14159;
  
  // 静态getter/setter
  static get version() {
    return "1.0.0";
  }
}

// 通过类名调用
console.log(MathUtils.add(2, 3)); // 5
console.log(MathUtils.PI); // 3.14159
console.log(MathUtils.version); // "1.0.0"

// 不能通过实例调用
const util = new MathUtils();
// util.add(2, 3); // 报错

// 实际应用：工厂方法
class User {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }
  
  // 静态工厂方法
  static createFromJSON(json) {
    const data = JSON.parse(json);
    return new User(data.name, data.age);
  }
  
  static createAnonymous() {
    return new User("Anonymous", 18);
  }
  
  // 静态验证方法
  static isValidUser(user) {
    return user && user.name && user.age >= 0;
  }
}

// 使用工厂方法
const user1 = User.createFromJSON('{"name": "John", "age": 30}');
const user2 = User.createAnonymous();

console.log(User.isValidUser(user1)); // true
console.log(User.isValidUser({})); // false

// 继承中的静态方法
class Animal {
  static identify() {
    console.log("I'm an Animal");
  }
}

class Dog extends Animal {
  static identify() {
    super.identify();
    console.log("I'm a Dog");
  }
}

Dog.identify();
// "I'm an Animal"
// "I'm a Dog"

// 静态方法中的this指向类
class MyClass {
  static staticMethod() {
    return this === MyClass;
  }
}

console.log(MyClass.staticMethod()); // true

// 作为回调时this可能丢失
class AnotherClass {
  static staticMethod() {
    console.log(this === AnotherClass);
  }
}

const func = AnotherClass.staticMethod;
func(); // false（this指向全局或undefined）
```

### 4. 私有字段（#name）如何定义和使用？

**回答：** 使用 `#` 前缀定义私有字段，只能在类内部访问。

```javascript
class Counter {
  // 私有字段
  #count = 0;
  
  // 私有方法
  #increment() {
    this.#count++;
  }
  
  // 公共方法
  tick() {
    this.#increment();
    console.log(this.#count);
  }
  
  getCount() {
    return this.#count;
  }
  
  // 静态私有字段
  static #maxCount = 100;
  
  static getMaxCount() {
    return this.#maxCount;
  }
}

const counter = new Counter();
counter.tick(); // 1
counter.tick(); // 2
console.log(counter.getCount()); // 2

// 外部无法访问私有字段
// console.log(counter.#count); // 报错：Private field '#count' must be declared in an enclosing class
// counter.#increment(); // 报错

console.log(Counter.getMaxCount()); // 100

// 继承中的私有字段
class Parent {
  #privateField = "parent private";
  
  getPrivate() {
    return this.#privateField;
  }
}

class Child extends Parent {
  #privateField = "child private"; // 不同的私有字段
  
  getChildPrivate() {
    return this.#privateField;
  }
}

const child = new Child();
console.log(child.getPrivate()); // "parent private"
console.log(child.getChildPrivate()); // "child private"

// 实际应用：封装数据
class BankAccount {
  #balance = 0;
  #transactionHistory = [];
  
  deposit(amount) {
    if (amount > 0) {
      this.#balance += amount;
      this.#recordTransaction('deposit', amount);
      return true;
    }
    return false;
  }
  
  withdraw(amount) {
    if (amount > 0 && amount <= this.#balance) {
      this.#balance -= amount;
      this.#recordTransaction('withdraw', amount);
      return true;
    }
    return false;
  }
  
  #recordTransaction(type, amount) {
    this.#transactionHistory.push({
      type,
      amount,
      timestamp: new Date(),
      balance: this.#balance
    });
  }
  
  getBalance() {
    return this.#balance;
  }
  
  getStatement() {
    return [...this.#transactionHistory]; // 返回副本
  }
}

const account = new BankAccount();
account.deposit(100);
account.withdraw(30);
console.log(account.getBalance()); // 70
console.log(account.getStatement());

// 注意：私有字段不能在构造函数外声明
class Example {
  // #privateField; // 可以
  constructor() {
    // this.#anotherField = 1; // 必须先声明
  }
}
```

## 2.10 新数据结构

### 1. Set 和 Map 的区别？

**回答：**

*   **Set**: 值集合，值唯一
    
*   **Map**: 键值对集合，键可以是任意类型
    

```javascript
// 1. Set - 值集合
const set = new Set([1, 2, 3, 3, 4, 5]);
console.log(set.size); // 5（去重）
console.log(set.has(3)); // true
set.add(6);
set.delete(2);
set.forEach(value => console.log(value));

// Set应用：数组去重
const arr = [1, 2, 2, 3, 3, 3];
const unique = [...new Set(arr)]; // [1, 2, 3]

// Set应用：并集、交集、差集
const setA = new Set([1, 2, 3]);
const setB = new Set([2, 3, 4]);

// 并集
const union = new Set([...setA, ...setB]); // {1, 2, 3, 4}

// 交集
const intersection = new Set([...setA].filter(x => setB.has(x))); // {2, 3}

// 差集
const difference = new Set([...setA].filter(x => !setB.has(x))); // {1}

// 2. Map - 键值对集合
const map = new Map();
const key1 = { id: 1 };
const key2 = function() {};

map.set(key1, "value1");
map.set(key2, "value2");
map.set("stringKey", "value3");

console.log(map.size); // 3
console.log(map.get(key1)); // "value1"
console.log(map.has("stringKey")); // true

// Map遍历
for (const [key, value] of map) {
  console.log(key, value);
}

// Map应用：缓存
const cache = new Map();
function expensiveOperation(key) {
  if (cache.has(key)) {
    return cache.get(key);
  }
  const result = computeResult(key);
  cache.set(key, result);
  return result;
}

// Map与Object对比
const obj = {};
obj[true] = "bool"; // 键会转为字符串 "true"
obj[1] = "number";  // 键会转为字符串 "1"
obj[{ id: 1 }] = "object"; // 键会转为 "[object Object]"

const map2 = new Map();
map2.set(true, "bool"); // 键保持boolean
map2.set(1, "number");  // 键保持number
map2.set({ id: 1 }, "object"); // 键保持对象引用

console.log(Object.keys(obj)); // ["1", "true", "[object Object]"]
console.log([...map2.keys()]); // [true, 1, {id: 1}]
```

### 2. WeakSet 和 WeakMap 的特点？

**回答：**

*   键/值必须是对象
    
*   弱引用，不影响垃圾回收
    
*   不可遍历，没有 `size` 属性
    

```javascript
// 1. WeakSet - 弱引用对象集合
let obj1 = { id: 1 };
let obj2 = { id: 2 };

const weakSet = new WeakSet();
weakSet.add(obj1);
weakSet.add(obj2);

console.log(weakSet.has(obj1)); // true

obj1 = null; // 删除引用
// obj1会被垃圾回收，weakSet中的对应项自动移除

// WeakSet应用：检测循环引用
function isCyclic(obj) {
  const seen = new WeakSet();
  
  function detect(obj) {
    if (obj && typeof obj === 'object') {
      if (seen.has(obj)) return true;
      seen.add(obj);
      for (let key in obj) {
        if (detect(obj[key])) return true;
      }
    }
    return false;
  }
  
  return detect(obj);
}

// 2. WeakMap - 弱引用键值对
let keyObj = { key: "original" };
let valueObj = { value: "data" };

const weakMap = new WeakMap();
weakMap.set(keyObj, valueObj);

console.log(weakMap.get(keyObj)); // {value: "data"}

keyObj = null; // 删除引用
// keyObj会被垃圾回收，weakMap中的对应项自动移除

// WeakMap应用：私有数据存储
const privateData = new WeakMap();

class Person {
  constructor(name, age) {
    // 存储私有数据
    privateData.set(this, {
      name,
      age,
      secret: Math.random()
    });
  }
  
  getName() {
    return privateData.get(this).name;
  }
  
  getSecret() {
    return privateData.get(this).secret;
  }
}

const person = new Person("John", 30);
console.log(person.getName()); // "John"
console.log(person.getSecret()); // 随机数

// 外部无法访问私有数据
console.log(person.secret); // undefined
console.log(privateData.get(person)); // undefined（需要this引用）

// WeakMap应用：DOM元素元数据
const domMetadata = new WeakMap();

function attachMetadata(element, metadata) {
  domMetadata.set(element, metadata);
}

function getMetadata(element) {
  return domMetadata.get(element);
}

const div = document.createElement('div');
attachMetadata(div, { created: new Date(), clicks: 0 });

div.addEventListener('click', () => {
  const meta = getMetadata(div);
  meta.clicks++;
  console.log(`Clicked ${meta.clicks} times`);
});

// 当div从DOM移除并被垃圾回收时，metadata自动清理

// 与Map/Set对比
const map = new Map();
const weakMap2 = new WeakMap();

let obj = { data: "test" };

map.set(obj, "value");
weakMap2.set(obj, "value");

console.log(map.size); // 1
// console.log(weakMap2.size); // undefined（WeakMap没有size）

obj = null;
// weakMap2中的项会被自动清理，但map中的不会
```

### 3. Symbol 的作用和用途？

**回答：** 创建唯一的标识符，用于避免属性名冲突。

```javascript
// 1. 创建Symbol
const sym1 = Symbol();
const sym2 = Symbol("description"); // 可选的描述
const sym3 = Symbol("description");

console.log(sym1 === sym2); // false（每个Symbol都是唯一的）
console.log(sym2 === sym3); // false（即使描述相同）

// 2. 作为对象属性键（避免冲突）
const user = {
  name: "John",
  [Symbol("id")]: 123, // 唯一的属性键
  [Symbol.for("globalId")]: 456 // 全局Symbol
};

// 常规方式无法访问
console.log(user.name); // "John"
console.log(Object.keys(user)); // ["name"]
console.log(Object.getOwnPropertySymbols(user)); // [Symbol(), Symbol(globalId)]

// 3. 全局Symbol注册表
const globalSym1 = Symbol.for("app.key"); // 创建或获取
const globalSym2 = Symbol.for("app.key");
console.log(globalSym1 === globalSym2); // true（全局相同）

console.log(Symbol.keyFor(globalSym1)); // "app.key"（获取描述）

// 4. 内置Symbol（用于元编程）
const obj = {
  [Symbol.toStringTag]: "MyObject", // 自定义toString标签
  [Symbol.iterator]: function*() { // 实现迭代器
    yield 1;
    yield 2;
    yield 3;
  }
};

console.log(obj.toString()); // "[object MyObject]"
console.log([...obj]); // [1, 2, 3]

// 5. 实际应用：定义类的私有属性
const _counter = Symbol("counter");
const _increment = Symbol("increment");

class MyClass {
  constructor() {
    this[_counter] = 0;
  }
  
  [_increment]() {
    this[_counter]++;
  }
  
  increment() {
    this[_increment]();
    return this[_counter];
  }
}

const instance = new MyClass();
console.log(instance.increment()); // 1
console.log(instance[_counter]); // 1（仍然可以访问，但需要Symbol引用）

// 6. 实际应用：定义枚举
const Color = {
  RED: Symbol("red"),
  GREEN: Symbol("green"),
  BLUE: Symbol("blue")
};

function setColor(color) {
  switch(color) {
    case Color.RED:
      return "#ff0000";
    case Color.GREEN:
      return "#00ff00";
    case Color.BLUE:
      return "#0000ff";
  }
}

// 7. 实际应用：避免属性覆盖
const EVENT_CLICK = Symbol("click");
const EVENT_HOVER = Symbol("hover");

class EventEmitter {
  constructor() {
    this.listeners = {
      [EVENT_CLICK]: [],
      [EVENT_HOVER]: []
    };
  }
  
  on(event, callback) {
    this.listeners[event].push(callback);
  }
  
  emit(event, data) {
    this.listeners[event].forEach(cb => cb(data));
  }
}

// 不会与其他库的"click"属性冲突
```

## 2.11 迭代器与生成器

### 1. 什么是迭代器（Iterator）？

**回答：** 一种接口，为不同的数据结构提供统一的访问机制。

```javascript
// 1. 迭代器协议：对象必须实现next()方法
const myIterator = {
  data: [1, 2, 3],
  index: 0,
  
  // 必须实现next()方法
  next() {
    if (this.index < this.data.length) {
      return {
        value: this.data[this.index++],
        done: false
      };
    } else {
      return { done: true };
    }
  },
  
  // 可选：实现[Symbol.iterator]使其可迭代
  [Symbol.iterator]() {
    return this;
  }
};

// 使用迭代器
let result = myIterator.next();
while (!result.done) {
  console.log(result.value); // 1, 2, 3
  result = myIterator.next();
}

// 2. 可迭代对象：实现了[Symbol.iterator]方法的对象
const iterableObject = {
  from: 1,
  to: 3,
  
  [Symbol.iterator]() {
    return {
      current: this.from,
      last: this.to,
      
      next() {
        if (this.current <= this.last) {
          return { value: this.current++, done: false };
        } else {
          return { done: true };
        }
      }
    };
  }
};

// 使用for...of遍历
for (let value of iterableObject) {
  console.log(value); // 1, 2, 3
}

// 3. 内置的可迭代对象
const arr = [1, 2, 3];
const iterator = arr[Symbol.iterator]();

console.log(iterator.next()); // {value: 1, done: false}
console.log(iterator.next()); // {value: 2, done: false}
console.log(iterator.next()); // {value: 3, done: false}
console.log(iterator.next()); // {value: undefined, done: true}

// 4. 字符串也是可迭代的
const str = "Hello";
for (const char of str) {
  console.log(char); // H, e, l, l, o
}

// 5. 自定义可迭代对象
class Range {
  constructor(start, end, step = 1) {
    this.start = start;
    this.end = end;
    this.step = step;
  }
  
  [Symbol.iterator]() {
    let current = this.start;
    const end = this.end;
    const step = this.step;
    
    return {
      next() {
        if ((step > 0 && current <= end) || (step < 0 && current >= end)) {
          const value = current;
          current += step;
          return { value, done: false };
        }
        return { done: true };
      }
    };
  }
}

const range = new Range(1, 5);
console.log([...range]); // [1, 2, 3, 4, 5]
```

### 2. for...of 循环的原理？

**回答：** 调用对象的 `[Symbol.iterator]()` 方法获取迭代器，然后不断调用 `next()` 方法遍历。

```javascript
// for...of的工作原理
const array = [1, 2, 3];

// 等价于以下代码
const iterator = array[Symbol.iterator]();
let result = iterator.next();

while (!result.done) {
  const value = result.value;
  console.log(value); // 处理value
  result = iterator.next();
}

// 1. 数组的for...of
const arr = ['a', 'b', 'c'];
for (const element of arr) {
  console.log(element); // 'a', 'b', 'c'
}

// 2. 字符串的for...of
const str = "Hello";
for (const char of str) {
  console.log(char); // 'H', 'e', 'l', 'l', 'o'
}

// 3. Set的for...of
const set = new Set([1, 2, 3, 3]);
for (const num of set) {
  console.log(num); // 1, 2, 3（去重）
}

// 4. Map的for...of
const map = new Map([['a', 1], ['b', 2]]);
for (const [key, value] of map) {
  console.log(key, value); // 'a' 1, 'b' 2
}

// 5. 类数组对象
const arrayLike = {
  0: 'a',
  1: 'b', 
  2: 'c',
  length: 3
};

// 直接使用for...of会报错
// for (const item of arrayLike) {} // 报错

// 转换为可迭代对象
for (const item of Array.from(arrayLike)) {
  console.log(item); // 'a', 'b', 'c'
}

// 6. 自定义可迭代对象
const myIterable = {
  *[Symbol.iterator]() {
    yield 1;
    yield 2;
    yield 3;
  }
};

for (const value of myIterable) {
  console.log(value); // 1, 2, 3
}

// 7. 与for...in的区别
const obj = { a: 1, b: 2, c: 3 };

for (const key in obj) {
  console.log(key); // 'a', 'b', 'c'（遍历键）
}

// 对象默认不可迭代
// for (const value of obj) {} // 报错

// 但可以手动添加迭代器
obj[Symbol.iterator] = function*() {
  for (const key in this) {
    yield this[key];
  }
};

for (const value of obj) {
  console.log(value); // 1, 2, 3
}
```

### 3. 生成器（Generator）函数的作用？

**回答：** 可以暂停和恢复执行的函数，用于简化迭代器创建。

```javascript
// 1. 基本语法：function*
function* numberGenerator() {
  yield 1;
  yield 2;
  yield 3;
}

const gen = numberGenerator();

console.log(gen.next()); // {value: 1, done: false}
console.log(gen.next()); // {value: 2, done: false}
console.log(gen.next()); // {value: 3, done: false}
console.log(gen.next()); // {value: undefined, done: true}

// 2. 使用for...of遍历
for (const num of numberGenerator()) {
  console.log(num); // 1, 2, 3
}

// 3. yield可以返回值
function* fibonacci() {
  let [prev, curr] = [0, 1];
  while (true) {
    yield curr;
    [prev, curr] = [curr, prev + curr];
  }
}

const fib = fibonacci();
console.log(fib.next().value); // 1
console.log(fib.next().value); // 1
console.log(fib.next().value); // 2
console.log(fib.next().value); // 3

// 4. yield接收值
function* twoWayGenerator() {
  const name = yield "What's your name?";
  yield `Hello, ${name}!`;
}

const twoWay = twoWayGenerator();
console.log(twoWay.next().value); // "What's your name?"
console.log(twoWay.next("John").value); // "Hello, John!"

// 5. yield* 委托给另一个生成器
function* generatorA() {
  yield 'a';
  yield 'b';
}

function* generatorB() {
  yield 'x';
  yield* generatorA(); // 委托
  yield 'y';
}

console.log([...generatorB()]); // ['x', 'a', 'b', 'y']

// 6. 实际应用：异步操作
function* fetchUserGenerator() {
  try {
    const user = yield fetch('/api/user');
    const posts = yield fetch(`/api/posts/${user.id}`);
    return posts;
  } catch (error) {
    console.error('Error:', error);
  }
}

// 需要执行器来运行
function run(generator) {
  const gen = generator();
  
  function handle(result) {
    if (result.done) return Promise.resolve(result.value);
    
    return Promise.resolve(result.value)
      .then(res => handle(gen.next(res)))
      .catch(err => gen.throw(err));
  }
  
  return handle(gen.next());
}

// 7. 实际应用：状态机
function* trafficLight() {
  while (true) {
    yield 'red';
    yield 'green';
    yield 'yellow';
  }
}

const light = trafficLight();
console.log(light.next().value); // 'red'
console.log(light.next().value); // 'green'
console.log(light.next().value); // 'yellow'

// 8. 实际应用：数据流处理
function* dataProcessor(data) {
  for (const item of data) {
    if (typeof item === 'number') {
      yield item * 2;
    } else if (typeof item === 'string') {
      yield item.toUpperCase();
    }
  }
}

const data = [1, 'hello', 3, 'world'];
console.log([...dataProcessor(data)]); // [2, 'HELLO', 6, 'WORLD']
```

## 2.12 模块化

### 1. ES6 模块与 CommonJS 的核心区别？

**回答：**

*   **加载方式**：ES6 编译时静态加载，CommonJS 运行时动态加载
    
*   **输出**：ES6 输出值的引用，CommonJS 输出值的拷贝
    
*   **使用场景**：ES6 用于浏览器/Node.js，CommonJS 主要用于Node.js
    

```javascript
// ES6模块写法
// math.js
export const add = (a, b) => a + b;
export const PI = 3.14159;
export default function multiply(a, b) {
  return a * b;
}

// app.js
import multiply, { add, PI } from './math.js';
console.log(add(2, 3)); // 5
console.log(PI); // 3.14159

// CommonJS写法
// math.cjs
const add = (a, b) => a + b;
const PI = 3.14159;
module.exports = {
  add,
  PI,
  multiply: (a, b) => a * b
};

// app.cjs
const math = require('./math.cjs');
console.log(math.add(2, 3)); // 5

// 关键区别1：输出值的方式
// ES6模块输出的是值的引用
// counter.js (ES6)
export let count = 0;
export function increment() {
  count++;
}

// main.js (ES6)
import { count, increment } from './counter.js';
console.log(count); // 0
increment();
console.log(count); // 1（值被改变）

// counter.cjs (CommonJS)
let count = 0;
function increment() {
  count++;
}
module.exports = { count, increment };

// main.cjs (CommonJS)
const { count, increment } = require('./counter.cjs');
console.log(count); // 0
increment();
console.log(count); // 0（值拷贝，未改变）

// 关键区别2：加载时机
// ES6模块（静态，编译时确定依赖）
// import { foo } from './module.js'; // 必须顶层，不能条件导入

// CommonJS（动态，运行时加载）
if (condition) {
  const module = require('./module.cjs'); // 可以条件导入
}

// 关键区别3：this指向
// ES6模块顶层的this是undefined
// CommonJS模块顶层的this是module.exports

// Node.js中使用ES6模块
// package.json中设置 "type": "module"
// 或者文件使用.mjs扩展名

// 浏览器中使用ES6模块
// <script type="module" src="app.js"></script>
```

### 2. export 和 export default 的区别？

**回答：**

*   `export`：命名导出，可以有多个
    
*   `export default`：默认导出，只能有一个
    

```javascript
// 1. 命名导出（多个）
// module.js
export const name = "John";
export const age = 30;
export function sayHello() {
  console.log("Hello");
}

// 导入时需要相同名称
import { name, age, sayHello } from './module.js';

// 2. 默认导出（一个）
// defaultModule.js
const defaultValue = "I'm default";
export default defaultValue;

// 或
export default function() {
  console.log("Default function");
}

// 导入时可以任意命名
import myDefault from './defaultModule.js';

// 3. 混合导出
// mixedModule.js
export const config = { version: "1.0" };
export const MAX_SIZE = 1024;

export default class User {
  constructor(name) {
    this.name = name;
  }
}

// 混合导入
import User, { config, MAX_SIZE } from './mixedModule.js';

// 4. 重命名导出
// renameModule.js
const internalName = "Secret";
export { internalName as publicName };

// 导入
import { publicName } from './renameModule.js';

// 5. 整体导入
// 导入所有命名导出
import * as utils from './module.js';
console.log(utils.name);

// 6. 重新导出
// 从其他模块导出
export { name } from './module.js';
export { default as DefaultUser } from './user.js';

// 7. 实际应用示例
// constants.js
export const API_URL = "https://api.example.com";
export const TIMEOUT = 5000;
export const MAX_RETRIES = 3;

// utils.js
export function formatDate(date) {
  return date.toISOString();
}

export function debounce(func, delay) {
  let timer;
  return function(...args) {
    clearTimeout(timer);
    timer = setTimeout(() => func.apply(this, args), delay);
  };
}

export default class Logger {
  log(message) {
    console.log(`[LOG]: ${message}`);
  }
}

// app.js
import Logger, { API_URL, formatDate, debounce } from './utils.js';

const logger = new Logger();
logger.log("App started");

// 8. 注意事项
// 不能动态导出
// if (condition) {
//   export const value = 1; // 报错
// }

// 但可以这样
const value = condition ? 1 : 2;
export { value };
```

### 3. 动态导入 import() 的使用场景？

**回答：** 动态加载模块，返回Promise，适用于按需加载、条件加载等场景。

```javascript
// 1. 基本用法
// 返回Promise
import('./module.js')
  .then(module => {
    module.doSomething();
  })
  .catch(error => {
    console.error('Module loading failed:', error);
  });

// 2. 使用async/await
async function loadModule() {
  try {
    const module = await import('./module.js');
    module.doSomething();
  } catch (error) {
    console.error('Failed to load module:', error);
  }
}

// 3. 按需加载（懒加载）
const button = document.getElementById('loadButton');
button.addEventListener('click', async () => {
  // 点击时才加载
  const heavyModule = await import('./heavyModule.js');
  heavyModule.init();
});

// 4. 条件加载
async function loadBasedOnCondition(condition) {
  if (condition) {
    const moduleA = await import('./moduleA.js');
    moduleA.run();
  } else {
    const moduleB = await import('./moduleB.js');
    moduleB.run();
  }
}

// 5. 动态路径
async function loadDynamicModule(path) {
  const module = await import(`./modules/${path}.js`);
  return module;
}

// 6. 预加载（preload）
// 提前获取但不执行
const link = document.createElement('link');
link.rel = 'modulepreload';
link.href = './criticalModule.js';
document.head.appendChild(link);

// 7. 实际应用：路由懒加载
const routes = {
  '/home': () => import('./views/Home.js'),
  '/about': () => import('./views/About.js'),
  '/contact': () => import('./views/Contact.js')
};

async function navigate(path) {
  const viewModule = await routes[path]();
  const view = new viewModule.default();
  view.render();
}

// 8. 实际应用：多语言支持
let currentLanguage = 'en';
const translations = {};

async function setLanguage(lang) {
  if (!translations[lang]) {
    translations[lang] = await import(`./locales/${lang}.js`);
  }
  
  currentLanguage = lang;
  updateUI();
}

function t(key) {
  return translations[currentLanguage][key] || key;
}

// 9. 实际应用：polyfill按需加载
async function loadPolyfills() {
  if (!window.Promise) {
    await import('promise-polyfill');
  }
  
  if (!window.fetch) {
    await import('whatwg-fetch');
  }
}

// 10. 配合webpack的魔法注释
const module = await import(
  /* webpackChunkName: "my-chunk" */
  /* webpackPrefetch: true */
  /* webpackPreload: true */
  './myModule.js'
);

// 11. 错误处理
async function safeImport(modulePath) {
  try {
    return await import(modulePath);
  } catch (error) {
    if (error.code === 'ERR_MODULE_NOT_FOUND') {
      console.warn(`Module ${modulePath} not found, using fallback`);
      return await import('./fallback.js');
    }
    throw error;
  }
}
```

## 2.13 新操作符

### 1. 可选链操作符（?.）如何避免访问深层属性时报错？

**回答：** 在访问可能不存在的属性时使用 `?.`，遇到 `null` 或 `undefined` 时立即返回 `undefined`。

```javascript
// 1. 对象属性访问
const user = {
  profile: {
    name: "John",
    address: {
      city: "NY"
    }
  }
};

// 传统方式
const city1 = user && user.profile && user.profile.address && user.profile.address.city;

// 可选链方式
const city2 = user?.profile?.address?.city;
console.log(city2); // "NY"

// 访问不存在的属性
console.log(user?.profile?.age?.years); // undefined（不会报错）

// 2. 数组元素访问
const arr = [1, 2, 3];
console.log(arr?.[5]); // undefined
console.log(arr?.[0]); // 1

// 3. 函数调用
const obj = {
  method1() {
    return "Hello";
  }
};

console.log(obj.method1?.()); // "Hello"
console.log(obj.method2?.()); // undefined（不会报错）

// 4. 结合nullish coalescing
const name = user?.profile?.name ?? "Anonymous";
console.log(name); // "John"（如果name为null/undefined则用"Anonymous"）

// 5. 实际应用：API响应处理
const response = {
  data: {
    user: {
      posts: [
        { title: "Post 1", comments: [] }
      ]
    }
  }
};

// 安全访问
const firstComment = response?.data?.user?.posts?.[0]?.comments?.[0];
console.log(firstComment); // undefined

// 6. DOM操作
const element = document.querySelector('.non-existent');
console.log(element?.textContent); // undefined
element?.addEventListener?.('click', handler); // 安全调用

// 7. 动态属性名
const propName = "address";
console.log(user?.profile?.[propName]?.city); // "NY"

// 8. 与delete结合
delete user?.profile?.address?.city; // 安全删除

// 9. 不能用于赋值
// user?.profile?.name = "Jane"; // 报错：Invalid left-hand side

// 10. 在函数参数中使用
function getUserCity(user) {
  return user?.address?.city ?? "Unknown";
}

console.log(getUserCity(null)); // "Unknown"

// 11. 注意：可选链短路
const result = obj?.method();
// 如果obj为null/undefined，method()不会执行

// 12. 多层可选链
const config = {
  settings: {
    theme: {
      colors: {
        primary: "#007bff"
      }
    }
  }
};

const primaryColor = config.settings?.theme?.colors?.primary;
const secondaryColor = config.settings?.theme?.colors?.secondary;
```

### 2. 空值合并操作符（??）与逻辑或（||）的区别？

**回答：**

*   `??` 只对 `null` 或 `undefined` 使用默认值
    
*   `||` 对所有假值（`false`、`0`、`""`、`NaN`、`null`、`undefined`）使用默认值
    

```javascript
// 1. 基本区别
const value1 = 0;
const value2 = "";
const value3 = false;
const value4 = null;
const value5 = undefined;

console.log(value1 || "default"); // "default"（0是假值）
console.log(value1 ?? "default"); // 0（0不是null/undefined）

console.log(value2 || "default"); // "default"（空字符串是假值）
console.log(value2 ?? "default"); // ""（空字符串不是null/undefined）

console.log(value3 || "default"); // "default"（false是假值）
console.log(value3 ?? "default"); // false（false不是null/undefined）

console.log(value4 || "default"); // "default"
console.log(value4 ?? "default"); // "default"（null用默认值）

console.log(value5 || "default"); // "default"
console.log(value5 ?? "default"); // "default"（undefined用默认值）

// 2. 实际应用：配置默认值
const config = {
  timeout: 0, // 0是有效值
  retries: false, // false是有效值
  apiUrl: "" // 空字符串是有效值
};

// 使用||会丢失有效值
const timeout1 = config.timeout || 5000; // 5000（错误，0被覆盖）
const timeout2 = config.timeout ?? 5000; // 0（正确，保留0）

// 3. 函数参数默认值
function connect(options) {
  const host = options.host ?? "localhost";
  const port = options.port ?? 8080;
  const secure = options.secure ?? false; // 可以正确保留false
  const timeout = options.timeout ?? 0; // 可以正确保留0
  
  console.log({ host, port, secure, timeout });
}

connect({ port: 0, secure: false }); // {host: "localhost", port: 0, secure: false, timeout: 0}

// 4. 与可选链结合
const user = {
  settings: {
    theme: null,
    fontSize: 0
  }
};

const theme = user?.settings?.theme ?? "light";
const fontSize = user?.settings?.fontSize ?? 14;

console.log(theme); // "light"（null用默认值）
console.log(fontSize); // 0（0不是null/undefined，保留）

// 5. 注意运算符优先级
const a = null;
const b = "value";
const c = false;

// ??优先级低于&&和||
// console.log(a ?? b || c); // 报错：需要用括号

console.log((a ?? b) || c); // "value"
console.log(a ?? (b || c)); // "value"
console.log(a ?? b ?? c); // "value"

// 6. 不能与||或&&直接连用
// const result = a ?? b || c; // 报错
// const result = a || b ?? c; // 报错

// 需要用括号
const result1 = (a ?? b) || c; // 正确
const result2 = a || (b ?? c); // 正确

// 7. 实际应用：API响应处理
const apiResponse = {
  data: {
    items: [],
    total: 0
  }
};

// ||会错误处理空数组和0
const items1 = apiResponse.data.items || ["default"]; // ["default"]（错误）
const items2 = apiResponse.data.items ?? ["default"]; // []（正确）

const total1 = apiResponse.data.total || 1; // 1（错误，0被覆盖）
const total2 = apiResponse.data.total ?? 1; // 0（正确，保留0）

// 8. 默认值链式
const config1 = null;
const config2 = { value: undefined };
const config3 = { value: 0 };

const valueA = config1?.value ?? "default"; // "default"
const valueB = config2?.value ?? "default"; // "default"
const valueC = config3?.value ?? "default"; // 0
```

### 3. 逻辑赋值运算符（&&=、||=、??=）如何使用？

**回答：** 简化逻辑运算与赋值的结合。

```javascript
// 1. 逻辑与赋值 (&&=)
// 只有当左侧为真时，才赋值右侧
let a = 1;
let b = 0;

a &&= 2; // a = 1 && 2 → 2
b &&= 2; // b = 0 && 2 → 0

console.log(a); // 2
console.log(b); // 0

// 等价于
// a = a && 2;

// 2. 逻辑或赋值 (||=)
// 只有当左侧为假时，才赋值右侧
let x = 0;
let y = "hello";

x ||= "default"; // x = 0 || "default" → "default"
y ||= "default"; // y = "hello" || "default" → "hello"

console.log(x); // "default"
console.log(y); // "hello"

// 等价于
// x = x || "default";

// 3. 空值合并赋值 (??=)
// 只有当左侧为null或undefined时，才赋值右侧
let p = null;
let q = 0;
let r = "";

p ??= "default"; // p = null ?? "default" → "default"
q ??= "default"; // q = 0 ?? "default" → 0
r ??= "default"; // r = "" ?? "default" → ""

console.log(p); // "default"
console.log(q); // 0
console.log(r); // ""

// 等价于
// p = p ?? "default";

// 4. 实际应用：对象属性默认值
const config = {};

// 设置默认值
config.port ||= 8080; // config.port = undefined || 8080 → 8080
config.host ??= "localhost"; // config.host = undefined ?? "localhost" → "localhost"
config.timeout ??= 0; // config.timeout = undefined ?? 0 → 0

console.log(config); // {port: 8080, host: "localhost", timeout: 0}

// 如果已经存在，不会覆盖
config.port = 3000;
config.port ||= 8080; // 不会执行，port已经是3000
console.log(config.port); // 3000

// 5. 实际应用：缓存数据
let cache = null;

function getData() {
  // 如果缓存为空，则获取数据
  cache ??= fetchData();
  return cache;
}

async function fetchData() {
  console.log("Fetching data...");
  return { data: "some data" };
}

// 第一次调用
getData(); // "Fetching data..."
// 第二次调用（使用缓存）
getData(); // 不会再次获取

// 6. 实际应用：DOM元素初始化
const container = document.getElementById('container') ??= createContainer();
const button = document.getElementById('button') ||= createButton();

function createContainer() {
  const div = document.createElement('div');
  div.id = 'container';
  document.body.appendChild(div);
  return div;
}

function createButton() {
  const btn = document.createElement('button');
  btn.id = 'button';
  btn.textContent = 'Click me';
  document.body.appendChild(btn);
  return btn;
}

// 7. 实际应用：配置合并
function mergeConfig(defaults, overrides) {
  const config = { ...defaults };
  
  for (const key in overrides) {
    // 只有当override的值不是undefined时才覆盖
    overrides[key] !== undefined && (config[key] = overrides[key]);
    // 使用逻辑赋值简化
    // config[key] &&= overrides[key]; // 只有当config[key]存在时才覆盖
  }
  
  return config;
}

// 8. 注意：短路特性
let counter = 0;
let value = null;

value ??= ++counter; // counter会增加
console.log(counter); // 1

value ||= ++counter; // counter不会增加，因为value不是假值
console.log(counter); // 1

value &&= ++counter; // counter会增加，因为value为真
console.log(counter); // 2
```

## 2.14 Proxy 与 Reflect

### 1. Proxy 和 Reflect 的典型应用场景？

**回答：**

*   **Proxy**: 创建对象的代理，拦截并自定义基本操作
    
*   **Reflect**: 提供拦截操作的默认行为
    

```javascript
// 1. Proxy基本用法
const target = { name: "John", age: 30 };
const handler = {
  get(obj, prop) {
    console.log(`Getting property: ${prop}`);
    return prop in obj ? obj[prop] : "default";
  },
  set(obj, prop, value) {
    console.log(`Setting property: ${prop} = ${value}`);
    if (prop === "age" && (value < 0 || value > 150)) {
      throw new Error("Invalid age");
    }
    obj[prop] = value;
    return true; // 必须返回true表示成功
  }
};

const proxy = new Proxy(target, handler);

console.log(proxy.name); // "Getting property: name" → "John"
console.log(proxy.gender); // "Getting property: gender" → "default"
proxy.age = 25; // "Setting property: age = 25"
// proxy.age = -5; // 报错：Invalid age

// 2. Reflect基本用法
const obj = { a: 1 };
console.log(Reflect.get(obj, "a")); // 1
console.log(Reflect.set(obj, "b", 2)); // true
console.log(obj.b); // 2

// 3. 典型应用：数据验证
const validator = {
  set(target, prop, value) {
    if (prop === "age") {
      if (!Number.isInteger(value)) {
        throw new TypeError("Age must be an integer");
      }
      if (value < 0 || value > 150) {
        throw new RangeError("Invalid age");
      }
    }
    return Reflect.set(target, prop, value);
  }
};

const person = new Proxy({}, validator);
person.age = 25; // 正常
// person.age = -5; // 报错
// person.age = "25"; // 报错

// 4. 典型应用：观察者模式
function createObservable(target, onChange) {
  return new Proxy(target, {
    set(target, prop, value) {
      const oldValue = target[prop];
      const result = Reflect.set(target, prop, value);
      if (result && oldValue !== value) {
        onChange(prop, oldValue, value);
      }
      return result;
    }
  });
}

const user = createObservable({ name: "John" }, (prop, oldVal, newVal) => {
  console.log(`Property ${prop} changed from ${oldVal} to ${newVal}`);
});

user.name = "Jane"; // "Property name changed from John to Jane"

// 5. 典型应用：负索引数组
function createNegativeArray(array) {
  return new Proxy(array, {
    get(target, prop) {
      const index = Number(prop);
      if (index < 0) {
        prop = target.length + index;
      }
      return Reflect.get(target, prop);
    }
  });
}

const arr = createNegativeArray([10, 20, 30, 40]);
console.log(arr[-1]); // 40
console.log(arr[-2]); // 30

// 6. 典型应用：自动填充默认值
const withDefaults = (target, defaults) => {
  return new Proxy(target, {
    get(obj, prop) {
      if (prop in obj) {
        return obj[prop];
      } else if (prop in defaults) {
        return defaults[prop];
      } else {
        return undefined;
      }
    }
  });
};

const config = withDefaults(
  { theme: "dark" },
  { theme: "light", fontSize: 14, language: "en" }
);

console.log(config.theme); // "dark"（使用自定义值）
console.log(config.fontSize); // 14（使用默认值）

// 7. Reflect配合Proxy使用
const logHandler = {
  get(target, prop, receiver) {
    console.log(`GET ${prop}`);
    return Reflect.get(target, prop, receiver);
  },
  set(target, prop, value, receiver) {
    console.log(`SET ${prop}=${value}`);
    return Reflect.set(target, prop, value, receiver);
  }
};

// 8. 函数代理
function trace(fn) {
  return new Proxy(fn, {
    apply(target, thisArg, args) {
      console.log(`Calling ${target.name} with args:`, args);
      const result = Reflect.apply(target, thisArg, args);
      console.log(`Result:`, result);
      return result;
    }
  });
}

function add(a, b) {
  return a + b;
}

const tracedAdd = trace(add);
tracedAdd(2, 3); // 输出调用和结果日志
```

### 2. 如何用 Proxy 实现响应式数据？

**回答：** 使用 Proxy 拦截对象的读写操作，实现数据变化时自动更新视图。

```javascript
// 1. 简易响应式系统
function reactive(target) {
  const handlers = {
    get(target, prop, receiver) {
      console.log(`Get ${prop}`);
      track(target, prop); // 收集依赖
      const value = Reflect.get(target, prop, receiver);
      if (typeof value === 'object' && value !== null) {
        return reactive(value); // 深层响应式
      }
      return value;
    },
    
    set(target, prop, value, receiver) {
      console.log(`Set ${prop} = ${value}`);
      const oldValue = target[prop];
      const result = Reflect.set(target, prop, value, receiver);
      
      if (oldValue !== value) {
        trigger(target, prop); // 触发更新
      }
      
      return result;
    },
    
    deleteProperty(target, prop) {
      console.log(`Delete ${prop}`);
      const result = Reflect.deleteProperty(target, prop);
      trigger(target, prop); // 触发更新
      return result;
    }
  };
  
  return new Proxy(target, handlers);
}

// 依赖收集和触发
const targetMap = new WeakMap();
let activeEffect = null;

function track(target, prop) {
  if (activeEffect) {
    let depsMap = targetMap.get(target);
    if (!depsMap) {
      depsMap = new Map();
      targetMap.set(target, depsMap);
    }
    
    let dep = depsMap.get(prop);
    if (!dep) {
      dep = new Set();
      depsMap.set(prop, dep);
    }
    
    dep.add(activeEffect);
  }
}

function trigger(target, prop) {
  const depsMap = targetMap.get(target);
  if (!depsMap) return;
  
  const dep = depsMap.get(prop);
  if (dep) {
    dep.forEach(effect => effect());
  }
}

function effect(fn) {
  activeEffect = fn;
  fn();
  activeEffect = null;
}

// 2. 使用示例
const state = reactive({
  count: 0,
  user: {
    name: "John",
    address: {
      city: "NY"
    }
  }
});

// 建立响应式依赖
effect(() => {
  console.log(`Count is: ${state.count}`);
});

effect(() => {
  console.log(`User city is: ${state.user.address.city}`);
});

// 触发更新
state.count++; // "Count is: 1"
state.user.address.city = "LA"; // "User city is: LA"

// 3. 计算属性
function computed(getter) {
  let value;
  let dirty = true;
  
  const effectFn = effect(() => {
    value = getter();
    dirty = false;
  });
  
  return {
    get value() {
      if (dirty) {
        value = getter();
        dirty = false;
      }
      track(this, 'value');
      return value;
    }
  };
}

const double = computed(() => state.count * 2);
effect(() => {
  console.log(`Double count: ${double.value}`);
});

state.count = 5; // 触发计算属性重新计算

// 4. 观察者模式实现
function watch(source, callback, options = {}) {
  let getter;
  
  if (typeof source === 'function') {
    getter = source;
  } else {
    getter = () => traverse(source);
  }
  
  let oldValue, newValue;
  
  const effectFn = effect(() => getter(), {
    scheduler() {
      newValue = getter();
      callback(newValue, oldValue);
      oldValue = newValue;
    }
  });
  
  oldValue = getter();
}

function traverse(value, seen = new Set()) {
  if (typeof value !== 'object' || value === null || seen.has(value)) {
    return;
  }
  
  seen.add(value);
  for (const key in value) {
    traverse(value[key], seen);
  }
  
  return value;
}

// 监听状态变化
watch(() => state.count, (newVal, oldVal) => {
  console.log(`Count changed from ${oldVal} to ${newVal}`);
});

state.count = 10;

// 5. 数组响应式处理
const reactiveArray = (arr) => {
  return new Proxy(arr, {
    get(target, prop) {
      if (prop === 'push' || prop === 'pop' || prop === 'shift' || prop === 'unshift') {
        return function(...args) {
          const result = Array.prototype[prop].apply(target, args);
          trigger(target, 'length'); // 触发长度变化
          return result;
        };
      }
      return Reflect.get(target, prop);
    }
  });
};

const items = reactiveArray([1, 2, 3]);
effect(() => {
  console.log(`Array length: ${items.length}`);
});

items.push(4); // "Array length: 4"
```

## 2.15 其他新特性

### 46. globalThis 的作用是什么？

**回答：** 提供一种标准方式在不同环境中访问全局对象。

```javascript
// 1. 不同环境的全局对象
// 浏览器：window、self、frames
// Node.js：global
// Web Workers：self
// 通用：globalThis

// 2. 使用globalThis
// 设置全局变量
globalThis.myGlobal = "Hello World";

// 在不同环境中都能访问
console.log(globalThis.myGlobal); // "Hello World"

// 3. 检查当前环境
if (globalThis.window) {
  console.log("Running in browser");
} else if (globalThis.process) {
  console.log("Running in Node.js");
} else if (globalThis.self === globalThis) {
  console.log("Running in Web Worker");
}

// 4. 安全地访问全局对象
function getGlobal() {
  if (typeof globalThis !== 'undefined') return globalThis;
  if (typeof window !== 'undefined') return window;
  if (typeof global !== 'undefined') return global;
  if (typeof self !== 'undefined') return self;
  throw new Error('Unable to locate global object');
}

const globals = getGlobal();

// 5. 添加全局polyfill
if (!globalThis.Promise) {
  globalThis.Promise = MyPromisePolyfill;
}

// 6. 跨环境共享状态
class GlobalStore {
  constructor() {
    if (!globalThis.__myAppStore) {
      globalThis.__myAppStore = new Map();
    }
    this.store = globalThis.__myAppStore;
  }
  
  set(key, value) {
    this.store.set(key, value);
  }
  
  get(key) {
    return this.store.get(key);
  }
}

// 在多个模块中共享同一个store
const store1 = new GlobalStore();
store1.set('theme', 'dark');

const store2 = new GlobalStore();
console.log(store2.get('theme')); // 'dark'
```

### 47. Promise 中的微任务是如何调度的？

**回答：** Promise 回调作为微任务执行，在当前宏任务结束后、下一个宏任务开始前执行。

```javascript
// 1. 宏任务 vs 微任务
console.log('Start script'); // 1. 同步代码

setTimeout(() => {
  console.log('setTimeout'); // 4. 宏任务
}, 0);

Promise.resolve()
  .then(() => {
    console.log('Promise 1'); // 3. 微任务
  })
  .then(() => {
    console.log('Promise 2'); // 微任务
  });

console.log('End script'); // 2. 同步代码

// 输出顺序：
// "Start script"
// "End script"  
// "Promise 1"
// "Promise 2"
// "setTimeout"

// 2. 微任务队列
function testMicrotask() {
  console.log('Start');
  
  // 微任务
  Promise.resolve().then(() => console.log('Microtask 1'));
  
  // 另一个微任务
  queueMicrotask(() => console.log('Microtask 2'));
  
  console.log('End');
}

testMicrotask();
// 输出：
// "Start"
// "End"
// "Microtask 1"
// "Microtask 2"

// 3. queueMicrotask API
// 添加微任务的标准方法
function processData(data) {
  queueMicrotask(() => {
    console.log('Processing data in microtask:', data);
  });
}

processData('test');

// 4. 嵌套微任务
Promise.resolve()
  .then(() => {
    console.log('Outer promise');
    Promise.resolve()
      .then(() => {
        console.log('Inner promise');
      });
  });

// 5. 微任务与DOM更新
const button = document.createElement('button');
button.textContent = 'Click me';
button.addEventListener('click', () => {
  console.log('Click event'); // 宏任务
  
  Promise.resolve().then(() => {
    console.log('Promise in click'); // 微任务
  });
  
  console.log('End of click handler');
});

// 6. 微任务循环
let promise = Promise.resolve();

for (let i = 0; i < 5; i++) {
  promise = promise.then(() => {
    console.log(`Microtask ${i}`);
  });
}

// 7. 与async/await的关系
async function asyncFunc() {
  console.log('Async start');
  
  await Promise.resolve(); // 微任务调度点
  console.log('After await'); // 微任务中执行
  
  return 'Done';
}

asyncFunc().then(console.log);

// 8. 实际应用：批量DOM更新
function batchDOMUpdates(updates) {
  // 同步收集所有更新
  const changes = [];
  
  // 在微任务中批量应用
  queueMicrotask(() => {
    for (const change of changes) {
      applyDOMChange(change);
    }
  });
}

// 9. 避免微任务饥饿
function processWithTimeout() {
  return new Promise((resolve) => {
    // 使用setTimeout确保不阻塞微任务队列
    setTimeout(() => {
      // 长时间操作...
      resolve();
    }, 0);
  });
}
```

### 48. structuredClone() 的作用？

**回答：** 深拷贝对象，支持循环引用和更多内置类型。

```javascript
// 1. 基本用法
const original = {
  name: "John",
  age: 30,
  hobbies: ["reading", "coding"],
  address: {
    city: "NY",
    zip: "10001"
  }
};

const cloned = structuredClone(original);

original.name = "Jane";
original.hobbies.push("sports");

console.log(cloned.name); // "John"（未改变）
console.log(cloned.hobbies); // ["reading", "coding"]（未改变）

// 2. 支持循环引用
const obj = { name: "Circular" };
obj.self = obj;

const clonedObj = structuredClone(obj);
console.log(clonedObj.self === clonedObj); // true（保持循环引用）

// 3. 支持更多类型
const data = {
  date: new Date(),
  map: new Map([["key", "value"]]),
  set: new Set([1, 2, 3]),
  regexp: /pattern/g,
  arrayBuffer: new ArrayBuffer(8),
  typedArray: new Uint8Array([1, 2, 3]),
  bigint: 123n,
  error: new Error("test")
};

const clonedData = structuredClone(data);
console.log(clonedData.date instanceof Date); // true
console.log(clonedData.map instanceof Map); // true
console.log(clonedData.regexp instanceof RegExp); // true

// 4. 不支持的类型
const unsupported = {
  function: () => {},
  symbol: Symbol("test"),
  // DOM元素
  element: document.createElement("div"),
  // 方法
  method: function() {},
  // Proxy
  proxy: new Proxy({}, {})
};

// const clonedUnsupported = structuredClone(unsupported); // 报错

// 5. 实际应用：Web Worker通信
// 主线程
const complexData = {
  matrix: new Float64Array([1.1, 2.2, 3.3]),
  config: { size: 1000 }
};

const worker = new Worker("worker.js");
worker.postMessage(structuredClone(complexData));

// Worker线程
// self.onmessage = (event) => {
//   const data = event.data; // 深拷贝的数据
// };

// 6. 实际应用：状态快照
class StateManager {
  constructor(initialState) {
    this.state = initialState;
    this.history = [];
  }
  
  saveSnapshot() {
    this.history.push(structuredClone(this.state));
  }
  
  restoreSnapshot(index) {
    this.state = structuredClone(this.history[index]);
  }
}

// 7. 实际应用：撤销/重做
class UndoManager {
  constructor() {
    this.states = [];
    this.currentIndex = -1;
  }
  
  saveState(state) {
    // 移除当前位置之后的所有状态
    this.states = this.states.slice(0, this.currentIndex + 1);
    this.states.push(structuredClone(state));
    this.currentIndex++;
  }
  
  undo() {
    if (this.currentIndex > 0) {
      this.currentIndex--;
      return structuredClone(this.states[this.currentIndex]);
    }
    return null;
  }
  
  redo() {
    if (this.currentIndex < this.states.length - 1) {
      this.currentIndex++;
      return structuredClone(this.states[this.currentIndex]);
    }
    return null;
  }
}

// 8. 性能考虑
function clonePerformanceTest() {
  const largeObject = {};
  for (let i = 0; i < 10000; i++) {
    largeObject[`key${i}`] = { value: i, nested: { data: "test" } };
  }
  
  console.time("structuredClone");
  const cloned = structuredClone(largeObject);
  console.timeEnd("structuredClone");
  
  console.time("JSON clone");
  const jsonCloned = JSON.parse(JSON.stringify(largeObject));
  console.timeEnd("JSON clone");
}

// 9. 与JSON方法的对比
const objWithSpecialTypes = {
  date: new Date(),
  nan: NaN,
  infinity: Infinity,
  regex: /test/g
};

const jsonClone = JSON.parse(JSON.stringify(objWithSpecialTypes));
console.log(jsonClone.date); // 字符串
console.log(jsonClone.nan); // null

const structuredCloneResult = structuredClone(objWithSpecialTypes);
console.log(structuredCloneResult.date instanceof Date); // true
console.log(structuredCloneResult.nan); // NaN
```


## 自己总结的面试题

### 1. ES6新增哪些属性


1. **变量声明方面**

    * 引入了 `let`和 `const`，提供了块级作用域
        
    * 解决了 `var`的变量提升和重复声明问题

2. **函数增强**

    * 箭头函数，语法更简洁，this 指向更明确
        
    * 函数参数支持默认值和剩余参数
        
3. **字符串处理**

    * 模板字符串，支持变量嵌入和多行文本
        
    * 新增了 `includes()`、`startsWith()`等字符串方法
        

4. **数组和对象扩展**

    * 扩展运算符 `...`，方便数组合并和对象合并
        
    * 解构赋值，可以快速从数组或对象中提取值
        
    * 新增了 `Array.from()`、`Object.assign()`等方法
        
5. **新的数据结构**

    * `Set`和 `Map`，提供了更合适的集合类型
        
    * `Symbol`类型，创建唯一的值

6. **异步编程改进**

    * `Promise`，更好地处理异步操作
        
    * 后来的 `async/await`让异步代码更像同步代码
        
7. **面向对象编程**

    * `Class`语法，更接近传统面向对象语言的写法
        
    * 支持 `extends`继承和 `super`调用父类
        
8. **模块化系统**

    * `import`和 `export`，原生支持模块化开发
        
9. **其他实用特性**

    * 代理 `Proxy`和反射 `Reflect`
        
    * 生成器函数 `function*`
        
    * 迭代器和 `for...of`循环
        
