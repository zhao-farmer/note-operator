# 六、Vue场景题


## 6.1 Vue 2 核心

### 1. Vue 2 响应式原理（Object.defineProperty）？

**原理**：  
Vue 2 通过 `Object.defineProperty` 劫持对象属性的 getter 和 setter，在数据被访问或修改时进行依赖收集和派发更新。

**核心代码示例**：

```javascript
// 简化版的响应式实现
function defineReactive(obj, key, val) {
  // 递归处理嵌套对象
  observe(val);
  
  const dep = new Dep(); // 每个属性对应一个依赖管理器
  
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get() {
      // 收集依赖（当前正在计算的 Watcher）
      if (Dep.target) {
        dep.addSub(Dep.target);
      }
      return val;
    },
    set(newVal) {
      if (newVal === val) return;
      val = newVal;
      // 通知所有依赖进行更新
      dep.notify();
    }
  });
}

// Dep类 - 依赖管理器
class Dep {
  constructor() {
    this.subs = [];
  }
  
  addSub(sub) {
    this.subs.push(sub);
  }
  
  notify() {
    this.subs.forEach(sub => sub.update());
  }
}

Dep.target = null; // 当前正在计算的 Watcher
```

**局限性**：

*   无法检测对象属性的添加或删除（需要 `Vue.set`/`Vue.delete`）
    
*   无法监听数组索引变化和长度变化
    
*   性能消耗较大（需要递归遍历所有属性）
    

### 2. Vue 2 生命周期钩子函数有哪些？

```javascript
export default {
  // 初始化阶段
  beforeCreate() {
    // 实例初始化之后，数据观测之前
    // 此时 data、methods 都不可用
  },
  created() {
    // 实例创建完成，数据观测完成
    // 可以访问 data、methods，但 DOM 未挂载
  },
  
  // 挂载阶段
  beforeMount() {
    // 模板编译完成，但未挂载到 DOM
  },
  mounted() {
    // 实例已挂载到 DOM
    // 可以访问 $el
  },
  
  // 更新阶段
  beforeUpdate() {
    // 数据更新时，DOM 更新之前
  },
  updated() {
    // 数据更新后，DOM 已更新
  },
  
  // 销毁阶段
  beforeDestroy() {
    // 实例销毁之前
    // 可以清理定时器、解绑事件等
  },
  destroyed() {
    // 实例已销毁
  },
  
  // 特殊钩子
  activated() {
    // keep-alive 组件激活时
  },
  deactivated() {
    // keep-alive 组件停用时
  },
  
  // 错误处理
  errorCaptured(err, vm, info) {
    // 捕获子孙组件错误
  }
}
```

### 3. computed 和 watch 的区别？

| 特性  | computed | watch |
| --- | --- | --- |
| 缓存  | 有缓存，依赖不变不重新计算 | 无缓存，每次变化都执行 |
| 返回值 | 必须返回一个值 | 无返回值，执行副作用 |
| 异步  | 不支持异步操作 | 支持异步操作 |
| 使用场景 | 模板中使用的计算属性 | 数据变化时执行异步或复杂操作 |

**示例**：

```javascript
export default {
  data() {
    return {
      firstName: '张',
      lastName: '三',
      count: 0
    }
  },
  
  computed: {
    // 计算属性
    fullName() {
      return this.firstName + this.lastName;
    }
  },
  
  watch: {
    // 监听器
    count(newVal, oldVal) {
      console.log(`count从${oldVal}变为${newVal}`);
    },
    
    // 深度监听
    someObject: {
      handler(newVal) {
        // 处理对象变化
      },
      deep: true,
      immediate: true // 立即执行一次
    }
  }
}
```

### 4. 组件通信的几种方式？

**1. 父传子 - props**

```vue
<!-- 父组件 -->
<template>
  <ChildComponent :title="parentTitle" />
</template>

<script>
export default {
  data() {
    return {
      parentTitle: 'Hello'
    }
  }
}
</script>

<!-- 子组件 -->
<script>
export default {
  props: {
    title: {
      type: String,
      required: true,
      default: ''
    }
  }
}
</script>
```

**2. 子传父 - $emit**

```vue
<!-- 子组件 -->
<template>
  <button @click="sendMessage">发送消息</button>
</template>

<script>
export default {
  methods: {
    sendMessage() {
      this.$emit('message', '来自子组件的消息');
    }
  }
}
</script>

<!-- 父组件 -->
<template>
  <ChildComponent @message="handleMessage" />
</template>

<script>
export default {
  methods: {
    handleMessage(msg) {
      console.log(msg); // "来自子组件的消息"
    }
  }
}
</script>
```

**3. 兄弟组件 - Event Bus（Vue 2）**

```javascript
// event-bus.js
import Vue from 'vue';
export const EventBus = new Vue();

// 组件A（发送）
EventBus.$emit('event-name', data);

// 组件B（接收）
EventBus.$on('event-name', data => {
  // 处理数据
});

// 组件销毁前记得移除监听
EventBus.$off('event-name');
```

**4. Vuex/Pinia - 全局状态管理**  
**5. provide/inject - 跨层级通信**

```javascript
// 祖先组件
export default {
  provide() {
    return {
      theme: 'dark',
      changeTheme: this.changeTheme
    }
  },
  methods: {
    changeTheme(theme) {
      this.theme = theme;
    }
  }
}

// 子孙组件
export default {
  inject: ['theme', 'changeTheme'],
  methods: {
    toggleTheme() {
      this.changeTheme('light');
    }
  }
}
```

**6. $parent/$children（不推荐）**  
**7. $attrs/$listeners（Vue 2.4+）**

### 5. v-model 的实现原理？

**本质**：语法糖，实现双向数据绑定

**Vue 2 实现**：

```xml
<!-- 使用 v-model -->
<input v-model="message">

<!-- 等价于 -->
<input 
  :value="message" 
  @input="message = $event.target.value"
>

<!-- 自定义组件使用 v-model -->
<CustomInput v-model="message" />

<!-- 等价于 -->
<CustomInput 
  :value="message" 
  @input="message = $event"
/>
```

**自定义组件实现**：

```vue
<!-- CustomInput.vue -->
<template>
  <input 
    :value="value" 
    @input="$emit('input', $event.target.value)"
  >
</template>

<script>
export default {
  props: ['value']
}
</script>
```

**Vue 2.2+ 支持 model 选项**：

```javascript
export default {
  model: {
    prop: 'value',    // 绑定的属性名
    event: 'change'   // 自定义事件名
  },
  props: {
    value: String
  },
  methods: {
    handleInput(e) {
      this.$emit('change', e.target.value);
    }
  }
}
```

### 6. Vue 2 的 nextTick 原理？

**作用**：在下次 DOM 更新循环结束之后执行延迟回调

**原理**：

1.  Vue 采用异步更新策略，同一事件循环中的数据变化会被批量更新
    
2.  nextTick 使用了微任务（microtask）和宏任务（macrotask）的降级策略
    

**实现原理**：

```javascript
let callbacks = [];
let pending = false;

function flushCallbacks() {
  pending = false;
  const copies = callbacks.slice(0);
  callbacks.length = 0;
  copies.forEach(callback => callback());
}

// 降级策略：Promise > MutationObserver > setImmediate > setTimeout
let timerFunc;

if (typeof Promise !== 'undefined') {
  // 使用 Promise（微任务）
  const p = Promise.resolve();
  timerFunc = () => {
    p.then(flushCallbacks);
  };
} else if (typeof MutationObserver !== 'undefined') {
  // 使用 MutationObserver（微任务）
  let counter = 1;
  const observer = new MutationObserver(flushCallbacks);
  const textNode = document.createTextNode(String(counter));
  observer.observe(textNode, { characterData: true });
  timerFunc = () => {
    counter = (counter + 1) % 2;
    textNode.data = String(counter);
  };
} else if (typeof setImmediate !== 'undefined') {
  // 使用 setImmediate（宏任务）
  timerFunc = () => {
    setImmediate(flushCallbacks);
  };
} else {
  // 使用 setTimeout（宏任务）
  timerFunc = () => {
    setTimeout(flushCallbacks, 0);
  };
}

export function nextTick(cb, ctx) {
  callbacks.push(() => {
    if (cb) {
      try {
        cb.call(ctx);
      } catch (e) {
        // 错误处理
      }
    }
  });
  
  if (!pending) {
    pending = true;
    timerFunc();
  }
}
```

**使用场景**：

```javascript
export default {
  data() {
    return {
      message: 'Hello'
    }
  },
  methods: {
    updateMessage() {
      this.message = 'World';
      
      // DOM 还未更新
      console.log(this.$el.textContent); // 'Hello'
      
      this.$nextTick(() => {
        // DOM 已更新
        console.log(this.$el.textContent); // 'World'
      });
    }
  }
}
```

## 6.2 Vue 3 核心

### 1. Vue 3 的 Composition API 优势？

**核心优势**：

1.  **更好的逻辑复用**：可以将相关逻辑组织在一起
    
2.  **更好的类型推断**：更适合 TypeScript
    
3.  **更灵活的组织方式**：不再受 Options API 的限制
    
4.  **更小的打包体积**：Tree-shaking 更友好
    

**对比示例**：

**Options API**：

```javascript
export default {
  data() {
    return {
      count: 0,
      todos: []
    }
  },
  methods: {
    increment() {
      this.count++;
    },
    addTodo(todo) {
      this.todos.push(todo);
    }
  },
  mounted() {
    console.log('组件已挂载');
  }
}
```

**Composition API**：

```javascript
import { ref, onMounted } from 'vue';

export default {
  setup() {
    // 计数器逻辑
    const count = ref(0);
    const increment = () => {
      count.value++;
    };
    
    // Todo列表逻辑
    const todos = ref([]);
    const addTodo = (todo) => {
      todos.value.push(todo);
    };
    
    // 生命周期
    onMounted(() => {
      console.log('组件已挂载');
    });
    
    return {
      count,
      increment,
      todos,
      addTodo
    };
  }
}
```

### 2. setup 函数的作用和特点？

**作用**：Composition API 的入口点，在组件创建之前执行

**特点**：

1.  在 `beforeCreate` 之前执行
    
2.  没有 `this` 上下文
    
3.  接收两个参数：`props` 和 `context`
    
4.  返回的对象会暴露给模板
    

```javascript
import { ref } from 'vue';

export default {
  props: {
    title: String
  },
  
  setup(props, context) {
    // 访问 props
    console.log(props.title);
    
    // context 包含 attrs、slots、emit 等
    const { attrs, slots, emit } = context;
    
    // 定义响应式数据
    const count = ref(0);
    
    // 定义方法
    const increment = () => {
      count.value++;
      emit('increment', count.value);
    };
    
    // 返回值会暴露给模板
    return {
      count,
      increment
    };
  }
}
```

**setup 语法糖（`<script setup>`）**：

```vue
<script setup>
import { ref, defineProps, defineEmits } from 'vue';

// 定义 props
const props = defineProps({
  title: String
});

// 定义 emits
const emit = defineEmits(['increment']);

// 响应式数据
const count = ref(0);

// 方法
const increment = () => {
  count.value++;
  emit('increment', count.value);
};
</script>
```

### 3. ref 和 reactive 的区别？

| 特性  | ref | reactive |
| --- | --- | --- |
| 数据类型 | 基本类型和对象 | 只能是对象 |
| 访问方式 | 需要 `.value` | 直接访问 |
| 类型支持 | 支持所有类型 | 只支持对象 |
| 解构  | 保持响应式 | 失去响应式（需用 toRefs） |

**示例**：

```javascript
import { ref, reactive, toRefs } from 'vue';

// ref - 用于基本类型
const count = ref(0);
console.log(count.value); // 0
count.value = 1;

// ref - 也可以用于对象
const objRef = ref({ name: 'John' });
console.log(objRef.value.name); // 'John'

// reactive - 用于对象
const state = reactive({
  name: 'John',
  age: 30
});
console.log(state.name); // 'John'

// reactive 解构会失去响应性
const { name, age } = state; // ❌ 失去响应性

// 使用 toRefs 保持响应性
const { name: nameRef, age: ageRef } = toRefs(state); // ✅ 保持响应性
```

### 4. Vue 3 响应式原理（Proxy）？

**原理**：使用 ES6 的 Proxy 实现数据劫持

**核心实现**：

```javascript
// 简化版的 reactive 实现
function reactive(target) {
  return new Proxy(target, {
    get(target, key, receiver) {
      track(target, key); // 收集依赖
      const result = Reflect.get(target, key, receiver);
      // 如果是对象，递归代理
      if (typeof result === 'object' && result !== null) {
        return reactive(result);
      }
      return result;
    },
    set(target, key, value, receiver) {
      const oldValue = target[key];
      const result = Reflect.set(target, key, value, receiver);
      if (oldValue !== value) {
        trigger(target, key); // 触发更新
      }
      return result;
    },
    deleteProperty(target, key) {
      const hadKey = Object.prototype.hasOwnProperty.call(target, key);
      const result = Reflect.deleteProperty(target, key);
      if (hadKey) {
        trigger(target, key);
      }
      return result;
    }
  });
}

// ref 的实现
function ref(value) {
  return {
    get value() {
      track(this, 'value');
      return value;
    },
    set value(newVal) {
      if (newVal !== value) {
        value = newVal;
        trigger(this, 'value');
      }
    }
  };
}
```

**优势**：

1.  支持数组索引和长度变化
    
2.  支持动态添加/删除属性
    
3.  性能更好
    
4.  支持 Map、Set 等数据结构
    

### 5. Teleport、Suspense 组件的作用？

**Teleport**：将组件内容渲染到 DOM 中的指定位置

```vue
<template>
  <div class="modal-container">
    <button @click="showModal = true">打开模态框</button>
    
    <!-- 将模态框渲染到 body 下 -->
    <Teleport to="body">
      <div v-if="showModal" class="modal">
        <h2>标题</h2>
        <button @click="showModal = false">关闭</button>
      </div>
    </Teleport>
  </div>
</template>

<script setup>
import { ref } from 'vue';
const showModal = ref(false);
</script>
```

**Suspense**：处理异步组件加载状态

```vue
<template>
  <Suspense>
    <!-- 默认插槽：异步组件 -->
    <template #default>
      <AsyncComponent />
    </template>
    
    <!-- fallback 插槽：加载状态 -->
    <template #fallback>
      <div>加载中...</div>
    </template>
  </Suspense>
</template>

<script setup>
import { defineAsyncComponent } from 'vue';

const AsyncComponent = defineAsyncComponent(() =>
  import('./AsyncComponent.vue')
);
</script>
```

### 6. Vue 3 的生命周期有哪些变化？

**变化**：

1.  `beforeDestroy` → `beforeUnmount`
    
2.  `destroyed` → `unmounted`
    
3.  新增 `renderTracked` 和 `renderTriggered`（开发模式调试）
    

**Vue 3 生命周期对应关系**：

```javascript
import {
  onBeforeMount,
  onMounted,
  onBeforeUpdate,
  onUpdated,
  onBeforeUnmount,
  onUnmounted,
  onErrorCaptured,
  onRenderTracked,
  onRenderTriggered
} from 'vue';

export default {
  setup() {
    // 挂载阶段
    onBeforeMount(() => {
      console.log('组件挂载前');
    });
    
    onMounted(() => {
      console.log('组件已挂载');
    });
    
    // 更新阶段
    onBeforeUpdate(() => {
      console.log('组件更新前');
    });
    
    onUpdated(() => {
      console.log('组件已更新');
    });
    
    // 卸载阶段
    onBeforeUnmount(() => {
      console.log('组件卸载前');
    });
    
    onUnmounted(() => {
      console.log('组件已卸载');
    });
    
    // 错误处理
    onErrorCaptured((err, instance, info) => {
      console.error('捕获到错误:', err);
      return false; // 阻止错误继续向上传播
    });
    
    // 开发调试
    onRenderTracked((event) => {
      console.log('跟踪到依赖', event);
    });
    
    onRenderTriggered((event) => {
      console.log('依赖触发更新', event);
    });
  }
}
```

## 6.3 组件相关

### 1. 什么是单向数据流？

**概念**：父组件通过 props 向子组件传递数据，子组件不能直接修改 props，需要通过事件通知父组件修改

**为什么需要单向数据流**：

1.  防止子组件意外修改父组件状态
    
2.  数据流向更清晰，易于调试
    
3.  遵循"单一数据源"原则
    

**正确做法**：

```vue
<!-- 父组件 -->
<template>
  <ChildComponent :value="parentValue" @update:value="parentValue = $event" />
</template>

<script>
export default {
  data() {
    return {
      parentValue: 'Hello'
    }
  }
}
</script>

<!-- 子组件 -->
<template>
  <input :value="value" @input="$emit('update:value', $event.target.value)">
</template>

<script>
export default {
  props: ['value']
}
</script>
```

### 2. 插槽（slot）的几种类型？

**1. 默认插槽**

```vue
<!-- 子组件 Child.vue -->
<template>
  <div class="container">
    <slot>默认内容</slot>
  </div>
</template>

<!-- 父组件使用 -->
<Child>
  <p>自定义内容</p>
</Child>
```

**2. 具名插槽**

```vue
<!-- 子组件 Layout.vue -->
<template>
  <div>
    <header>
      <slot name="header"></slot>
    </header>
    <main>
      <slot></slot>
    </main>
    <footer>
      <slot name="footer"></slot>
    </footer>
  </div>
</template>

<!-- 父组件使用 -->
<Layout>
  <template v-slot:header>
    <h1>标题</h1>
  </template>
  
  <p>主要内容</p>
  
  <template #footer>  <!-- 简写 -->
    <p>页脚</p>
  </template>
</Layout>
```

**3. 作用域插槽**

```vue
<!-- 子组件 List.vue -->
<template>
  <ul>
    <li v-for="item in items" :key="item.id">
      <slot :item="item">
        {{ item.name }}
      </slot>
    </li>
  </ul>
</template>

<script>
export default {
  props: ['items']
}
</script>

<!-- 父组件使用 -->
<List :items="userList">
  <template v-slot="{ item }">
    <div>{{ item.name }} - {{ item.age }}</div>
  </template>
</List>
```

**4. 动态插槽名**

```vue
<template>
  <BaseLayout>
    <template v-slot:[dynamicSlotName]>
      动态插槽内容
    </template>
  </BaseLayout>
</template>
```

### 3. 动态组件和异步组件？

**动态组件**：根据条件动态切换组件

```vue
<template>
  <component :is="currentComponent"></component>
  <button @click="toggleComponent">切换组件</button>
</template>

<script>
import ComponentA from './ComponentA.vue';
import ComponentB from './ComponentB.vue';

export default {
  data() {
    return {
      currentComponent: 'ComponentA'
    }
  },
  components: {
    ComponentA,
    ComponentB
  },
  methods: {
    toggleComponent() {
      this.currentComponent = 
        this.currentComponent === 'ComponentA' ? 'ComponentB' : 'ComponentA';
    }
  }
}
</script>
```

**异步组件**：按需加载组件

```javascript
// Vue 2
const AsyncComponent = () => ({
  component: import('./MyComponent.vue'),
  loading: LoadingComponent,    // 加载时显示的组件
  error: ErrorComponent,        // 加载失败时显示的组件
  delay: 200,                   // 延迟显示 loading 的时间
  timeout: 3000                 // 超时时间
});

// Vue 3
import { defineAsyncComponent } from 'vue';

const AsyncComponent = defineAsyncComponent({
  loader: () => import('./MyComponent.vue'),
  loadingComponent: LoadingComponent,
  errorComponent: ErrorComponent,
  delay: 200,
  timeout: 3000,
  suspensible: false // 是否使用 Suspense
});
```

### 4. keep-alive 组件的作用？

**作用**：缓存不活动的组件实例，避免重复渲染

**使用**：

```vue
<template>
  <div>
    <button @click="currentTab = 'TabA'">Tab A</button>
    <button @click="currentTab = 'TabB'">Tab B</button>
    
    <keep-alive>
      <component :is="currentTab"></component>
    </keep-alive>
  </div>
</template>

<script>
export default {
  data() {
    return {
      currentTab: 'TabA'
    }
  },
  components: {
    TabA: {
      template: '<div>Tab A Content</div>',
      created() {
        console.log('TabA created');
      },
      destroyed() {
        console.log('TabA destroyed');
      },
      activated() {
        console.log('TabA activated');
      },
      deactivated() {
        console.log('TabA deactivated');
      }
    },
    TabB: {
      template: '<div>Tab B Content</div>'
    }
  }
}
</script>
```

**属性**：

*   `include`：只有名称匹配的组件会被缓存
    
*   `exclude`：任何名称匹配的组件都不会被缓存
    
*   `max`：最多可以缓存多少组件实例
    

```vue
<keep-alive :include="['TabA', 'TabB']" :exclude="['TabC']" :max="10">
<component :is="currentComponent">
</component>
</keep-alive>
```

### 5. 递归组件如何使用？

**递归组件**：组件可以在其模板中调用自身

**使用场景**：树形结构、菜单、评论嵌套等

**示例**：

```vue
<!-- TreeItem.vue -->
<template>
  <li>
    <div @click="toggle">
      {{ item.name }}
      <span v-if="hasChildren">[{{ isOpen ? '-' : '+' }}]</span>
    </div>
    <ul v-if="isOpen && hasChildren">
      <TreeItem
        v-for="child in item.children"
        :key="child.id"
        :item="child"
      />
    </ul>
  </li>
</template>

<script>
export default {
  name: 'TreeItem', // 必须设置 name，用于递归调用
  props: {
    item: Object
  },
  data() {
    return {
      isOpen: false
    }
  },
  computed: {
    hasChildren() {
      return this.item.children && this.item.children.length > 0;
    }
  },
  methods: {
    toggle() {
      if (this.hasChildren) {
        this.isOpen = !this.isOpen;
      }
    }
  }
}
</script>

<!-- 父组件使用 -->
<template>
  <ul>
    <TreeItem v-for="item in treeData" :key="item.id" :item="item" />
  </ul>
</template>
```

### 6. 函数式组件的特点？

**特点**：

1.  无状态（无响应式数据）
    
2.  无实例（没有 `this`）
    
3.  无生命周期钩子
    
4.  性能更高（渲染开销小）
    

**Vue 2 函数式组件**：

```vue
<template functional>
  <div class="functional-component">
    <p>{{ props.message }}</p>
    <button @click="listeners.click">点击</button>
  </div>
</template>

<script>
export default {
  functional: true,
  props: {
    message: String
  },
  render(h, context) {
    // context 包含 props、children、data、listeners 等
    const { props, listeners } = context;
    return h('div', { class: 'functional-component' }, [
      h('p', props.message),
      h('button', { on: { click: listeners.click } }, '点击')
    ]);
  }
}
</script>
```

**Vue 3 函数式组件**：

```javascript
// 选项式
import { h } from 'vue';

const FunctionalComponent = (props, context) => {
  const { slots, attrs, emit } = context;
  return h('div', attrs, [
    h('p', props.message),
    slots.default?.()
  ]);
};

FunctionalComponent.props = ['message'];
FunctionalComponent.emits = ['click'];

// 或使用 defineComponent
import { defineComponent } from 'vue';

export default defineComponent({
  name: 'FunctionalComponent',
  props: ['message'],
  setup(props, { slots, attrs }) {
    return () => h('div', attrs, [
      h('p', props.message),
      slots.default?.()
    ]);
  }
});
```

## 6.4 指令与模板

### 1. 自定义指令如何创建？

**Vue 2**：

```javascript
// 全局指令
Vue.directive('focus', {
  // 指令第一次绑定到元素时调用
  bind(el, binding, vnode) {
    // el: 指令绑定的元素
    // binding: 包含指令信息的对象
    // vnode: Vue 编译生成的虚拟节点
  },
  
  // 被绑定元素插入父节点时调用
  inserted(el, binding) {
    el.focus();
  },
  
  // 所在组件的 VNode 更新时调用
  update(el, binding) {
    // 处理更新
  },
  
  // 指令所在组件的 VNode 及其子 VNode 全部更新后调用
  componentUpdated(el, binding) {
    // 处理组件更新完成后的逻辑
  },
  
  // 指令与元素解绑时调用
  unbind(el, binding) {
    // 清理工作
  }
});

// 局部指令
export default {
  directives: {
    focus: {
      inserted(el) {
        el.focus();
      }
    }
  }
}
```

**Vue 3**：

```javascript
// 全局指令
const app = createApp({});

app.directive('focus', {
  // 绑定元素时调用
  mounted(el, binding, vnode) {
    el.focus();
  },
  
  // 组件更新时调用
  updated(el, binding, vnode) {
    // 处理更新
  },
  
  // 解绑时调用
  unmounted(el, binding, vnode) {
    // 清理工作
  }
});

// 组合式 API 中的局部指令
export default {
  setup() {
    const vFocus = {
      mounted(el) {
        el.focus();
      }
    };
    
    return { vFocus };
  }
}
```

**使用指令**：

```vue
<template>
  <!-- 基本使用 -->
  <input v-focus>
  
  <!-- 传递参数 -->
  <div v-color="'red'"></div>
  
  <!-- 动态参数 -->
  <div v-move:[direction]="100"></div>
  
  <!-- 修饰符 -->
  <button v-click.once="handleClick">点击</button>
</template>
```

### 2. v-if 和 v-show 的区别？

| 特性  | v-if | v-show |
| --- | --- | --- |
| 原理  | 条件性渲染，切换时销毁/创建组件 | 条件性显示，通过 CSS display 控制 |
| 编译  | 惰性的，初始为 false 则不编译 | 无论初始条件如何都会编译 |
| 性能  | 切换开销大，适合不频繁切换 | 初始渲染开销大，切换开销小 |
| 使用场景 | 运行时很少改变条件 | 需要频繁切换显示状态 |

**示例**：

```vue
<template>
  <!-- v-if：条件为 false 时元素不存在于 DOM -->
  <div v-if="isVisible">v-if 内容</div>
  
  <!-- v-show：条件为 false 时元素存在于 DOM，display: none -->
  <div v-show="isVisible">v-show 内容</div>
  
  <button @click="isVisible = !isVisible">切换显示</button>
</template>

<script>
export default {
  data() {
    return {
      isVisible: true
    }
  }
}
</script>
```

### 3. v-for 的 key 的作用？

**作用**：

1.  **标识唯一性**：帮助 Vue 识别每个节点的身份
    
2.  **高效更新**：基于 key 复用已有节点，避免不必要的 DOM 操作
    
3.  **状态保持**：保持组件内部状态（如表单输入值）
    

**正确使用**：

```vue
<template>
  <!-- 使用唯一标识作为 key -->
  <ul>
    <li v-for="item in items" :key="item.id">
      {{ item.name }}
    </li>
  </ul>
  
  <!-- 有相同父元素的子元素必须有独特的 key -->
  <template v-if="condition">
    <div key="a">内容 A</div>
  </template>
  <template v-else>
    <div key="b">内容 B</div>
  </template>
</template>
```

**为什么不推荐使用 index 作为 key**：

```javascript
// 初始数据
items = [
  { id: 1, name: 'A' },
  { id: 2, name: 'B' },
  { id: 3, name: 'C' }
];

// 使用 index 作为 key
// 删除第一项后，剩余的 key 会变化：
// 原来 key=1 对应 'B'，现在 key=0 对应 'B'
// 导致不必要的重新渲染
```

### 4. 事件修饰符有哪些？

**常用事件修饰符**：

```vue
<template>
  <!-- 阻止默认事件 -->
  <form @submit.prevent="onSubmit"></form>
  
  <!-- 阻止事件冒泡 -->
  <div @click.stop="handleClick"></div>
  
  <!-- 事件只触发一次 -->
  <button @click.once="handleClick"></button>
  
  <!-- 事件捕获模式 -->
  <div @click.capture="handleClick"></div>
  
  <!-- 只有 event.target 是当前元素时才触发 -->
  <div @click.self="handleClick"></div>
  
  <!-- 阻止默认事件，不阻止冒泡 -->
  <a @click.prevent.self></a>
  
  <!-- 串联使用 -->
  <form @submit.prevent.stop="onSubmit"></form>
</template>
```

**按键修饰符**：

```vue
<template>
  <!-- 回车键 -->
  <input @keyup.enter="submit">
  
  <!-- 组合键 -->
  <input @keyup.ctrl.enter="submit">
  
  <!-- 常用按键别名 -->
  <input @keyup.esc="cancel">
  <input @keyup.tab="next">
  <input @keyup.delete="deleteItem">
  
  <!-- 系统修饰键 -->
  <input @keyup.ctrl="doSomething">
  <input @click.ctrl.exact="onCtrlClick">
</template>
```

**鼠标修饰符**：

```vue
<template>
  <button @click.right="rightClick">右键</button>
  <button @click.middle="middleClick">中键</button>
  <button @click.left="leftClick">左键</button>
</template>
```

### 5. 表单输入修饰符？

```vue
<template>
  <!-- .lazy：在 change 事件后同步数据 -->
  <input v-model.lazy="message">
  <!-- 等价于 -->
  <input :value="message" @change="message = $event.target.value">
  
  <!-- .number：自动将输入转为数字 -->
  <input v-model.number="age" type="number">
  
  <!-- .trim：自动去除首尾空格 -->
  <input v-model.trim="username">
  
  <!-- 组合使用 -->
  <input v-model.lazy.trim="search">
</template>

<script>
export default {
  data() {
    return {
      message: '',
      age: 0,
      username: '',
      search: ''
    }
  }
}
</script>
```

### 6. 模板编译过程？

**Vue 模板编译的三个阶段**：

1.  **解析阶段**：将模板字符串转换为 AST（抽象语法树）
    
2.  **优化阶段**：标记静态节点，提高更新性能
    
3.  **代码生成阶段**：将 AST 转换为渲染函数
    

**简化的编译过程**：

```javascript
// 模板
const template = '<div id="app">{{ message }}</div>';

// 1. 解析成 AST
const ast = {
  type: 1, // 元素节点
  tag: 'div',
  attrsList: [{ name: 'id', value: 'app' }],
  attrsMap: { id: 'app' },
  children: [
    {
      type: 2, // 表达式节点
      expression: '_s(message)',
      text: '{{ message }}'
    }
  ]
};

// 2. 优化（标记静态节点）
markStatic(ast);

// 3. 生成渲染函数代码
const code = generate(ast, options);
// 生成的代码类似于：
// with(this){return _c('div',{attrs:{"id":"app"}},[_v(_s(message))])}

// 4. 创建渲染函数
const render = new Function(`with(this){return ${code}}`);
```

**Vue 3 的编译优化**：

1.  **Patch Flag**：标记动态节点类型
    
2.  **静态提升**：将静态节点提升到渲染函数外
    
3.  **树结构打平**：减少嵌套层级
    
4.  **缓存事件处理函数**
    

## 6.5 状态管理

### 1. Vuex 的核心概念？

**Vuex 流程图**：

```text
┌─────────┐   dispatch    ┌─────────────┐   commit    ┌─────────────┐
│  View   │──────────────>│   Actions   │────────────>│  Mutations  │
└─────────┘               └─────────────┘             └─────────────┘
     │                         │                            │
     │                         │                            │
     │          ┌──────────────┴──────────────┐            │
     │          │                             │            │
     │          ▼                             ▼            ▼
     │    ┌─────────────┐               ┌─────────────┐
     └───>│    State    │<──────────────│    Getters  │
          └─────────────┘               └─────────────┘
```

**核心概念实现**：

```javascript
// store.js
import Vue from 'vue';
import Vuex from 'vuex';

Vue.use(Vuex);

export default new Vuex.Store({
  // 状态（数据源）
  state: {
    count: 0,
    todos: []
  },
  
  // 获取器（计算属性）
  getters: {
    doubleCount(state) {
      return state.count * 2;
    },
    completedTodos(state) {
      return state.todos.filter(todo => todo.completed);
    }
  },
  
  // 同步修改（mutations 必须是同步函数）
  mutations: {
    increment(state) {
      state.count++;
    },
    addTodo(state, todo) {
      state.todos.push(todo);
    }
  },
  
  // 异步操作（actions 可以包含异步操作）
  actions: {
    incrementAsync({ commit }) {
      setTimeout(() => {
        commit('increment');
      }, 1000);
    },
    fetchTodos({ commit }) {
      return api.getTodos().then(todos => {
        commit('setTodos', todos);
      });
    }
  },
  
  // 模块化
  modules: {
    user: {
      state: () => ({
        name: '',
        token: ''
      }),
      mutations: {
        setUser(state, user) {
          state.name = user.name;
          state.token = user.token;
        }
      },
      getters: {
        isLoggedIn(state) {
          return !!state.token;
        }
      }
    }
  }
});
```

**在组件中使用**：

```vue
<template>
  <div>
    <p>Count: {{ count }}</p>
    <p>Double: {{ doubleCount }}</p>
    <button @click="increment">同步增加</button>
    <button @click="incrementAsync">异步增加</button>
  </div>
</template>

<script>
import { mapState, mapGetters, mapMutations, mapActions } from 'vuex';

export default {
  computed: {
    // 方式1：使用辅助函数
    ...mapState(['count']),
    ...mapGetters(['doubleCount']),
    
    // 方式2：直接访问
    // count() {
    //   return this.$store.state.count;
    // }
  },
  methods: {
    // 方式1：使用辅助函数
    ...mapMutations(['increment']),
    ...mapActions(['incrementAsync']),
    
    // 方式2：直接调用
    // increment() {
    //   this.$store.commit('increment');
    // }
  }
}
</script>
```

### 2. Pinia 相比 Vuex 的优势？

**Pinia 优势**：

1.  **更简单的 API**：不需要 mutations，直接修改 state
    
2.  **更好的 TypeScript 支持**：完全类型化
    
3.  **更小的体积**：约 1KB
    
4.  **模块化设计**：自动按需引入
    
5.  **支持 Composition API**：更适合 Vue 3
    

**Pinia 基本使用**：

```javascript
// store/counter.js
import { defineStore } from 'pinia';

export const useCounterStore = defineStore('counter', {
  // 状态
  state: () => ({
    count: 0,
    todos: []
  }),
  
  // 计算属性
  getters: {
    doubleCount: (state) => state.count * 2,
    // 访问其他 store
    userTodos(state) {
      const userStore = useUserStore();
      return state.todos.filter(todo => todo.userId === userStore.userId);
    }
  },
  
  // 操作（支持同步和异步）
  actions: {
    increment() {
      this.count++;
    },
    async fetchTodos() {
      const todos = await api.getTodos();
      this.todos = todos;
    },
    // 可以访问整个 store 实例
    reset() {
      this.$reset(); // 重置到初始状态
    }
  }
});

// store/user.js
export const useUserStore = defineStore('user', {
  state: () => ({
    name: '',
    token: ''
  }),
  actions: {
    login(credentials) {
      // 直接修改 state
      this.name = credentials.name;
      this.token = 'fake-token';
    }
  }
});
```

**在组件中使用**：

```vue
<template>
  <div>
    <p>Count: {{ counter.count }}</p>
    <p>Double: {{ counter.doubleCount }}</p>
    <button @click="counter.increment()">增加</button>
  </div>
</template>

<script setup>
import { useCounterStore } from '@/stores/counter';

const counter = useCounterStore();

// 响应式解构（保持响应性）
import { storeToRefs } from 'pinia';
const { count, doubleCount } = storeToRefs(counter);

// 监听状态变化
counter.$subscribe((mutation, state) => {
  console.log('状态变化:', mutation.type, state);
});

// 监听 actions
counter.$onAction(({ name, store, args, after, onError }) => {
  console.log('Action 开始:', name, args);
  
  after((result) => {
    console.log('Action 完成:', name, result);
  });
  
  onError((error) => {
    console.error('Action 失败:', name, error);
  });
});
</script>
```

### 3. 如何实现持久化存储？

**方案 1：使用 vuex-persistedstate（Vuex）**

```javascript
import createPersistedState from 'vuex-persistedstate';

const store = new Vuex.Store({
  // ...其他配置
  plugins: [
    createPersistedState({
      key: 'my-app', // 存储的 key
      paths: ['user', 'settings'], // 只持久化指定模块
      storage: window.sessionStorage, // 使用 sessionStorage
      // 自定义序列化
      serialize: JSON.stringify,
      deserialize: JSON.parse
    })
  ]
});
```

**方案 2：手动实现**

```javascript
// 自定义插件
const persistencePlugin = (store) => {
  // 初始化时从 localStorage 恢复
  const savedState = localStorage.getItem('vuex-state');
  if (savedState) {
    store.replaceState(JSON.parse(savedState));
  }
  
  // 监听 mutations，保存到 localStorage
  store.subscribe((mutation, state) => {
    // 只保存需要的部分
    const stateToSave = {
      user: state.user,
      settings: state.settings
    };
    localStorage.setItem('vuex-state', JSON.stringify(stateToSave));
  });
};

// Pinia 持久化
import { defineStore } from 'pinia';

export const useStore = defineStore('main', {
  state: () => ({
    data: null
  }),
  persist: {
    enabled: true,
    strategies: [
      {
        key: 'my-store',
        storage: localStorage,
        paths: ['data']
      }
    ]
  }
});
```

### 4. 模块化状态管理？

**Vuex 模块化**：

```javascript
// modules/user.js
const userModule = {
  namespaced: true, // 启用命名空间
  
  state: () => ({
    name: '',
    token: ''
  }),
  
  getters: {
    isLoggedIn: state => !!state.token
  },
  
  mutations: {
    SET_USER(state, user) {
      state.name = user.name;
      state.token = user.token;
    }
  },
  
  actions: {
    async login({ commit }, credentials) {
      const user = await api.login(credentials);
      commit('SET_USER', user);
    }
  }
};

// store.js
import user from './modules/user';
import products from './modules/products';

export default new Vuex.Store({
  modules: {
    user,
    products
  }
});

// 组件中使用（带命名空间）
export default {
  computed: {
    ...mapState('user', ['name', 'token']),
    ...mapGetters('user', ['isLoggedIn'])
  },
  methods: {
    ...mapActions('user', ['login'])
  }
}
```

**Pinia 模块化**：

```javascript
// stores/user.js
export const useUserStore = defineStore('user', {
  // ...
});

// stores/products.js
export const useProductsStore = defineStore('products', {
  // ...
});

// 在组件中使用多个 store
import { useUserStore, useProductsStore } from '@/stores';

const userStore = useUserStore();
const productsStore = useProductsStore();
```

### 5. 如何实现跨组件状态共享？

**1. 使用状态管理库（Vuex/Pinia）**

```javascript
// 大型应用首选，提供完整的工具链和调试支持
```

**2. 使用 provide/inject**

```javascript
// 祖先组件
export default {
  provide() {
    return {
      sharedState: reactive({
        count: 0,
        increment: () => this.sharedState.count++
      })
    };
  }
};

// 子孙组件
export default {
  inject: ['sharedState'],
  template: '<button @click="sharedState.increment">{{ sharedState.count }}</button>'
};
```

**3. 使用可组合函数（Composables）**

```javascript
// composables/useCounter.js
import { ref } from 'vue';

export function useCounter() {
  const count = ref(0);
  const increment = () => count.value++;
  
  return { count, increment };
}

// 多个组件共享同一个实例
import { createSharedComposable } from '@vueuse/core';
export const useSharedCounter = createSharedComposable(useCounter);
```

**4. 使用 Event Bus（小型应用）**

```javascript
// mitt 或 vue-bus
import mitt from 'mitt';

const emitter = mitt();

// 组件 A
emitter.emit('event', data);

// 组件 B
emitter.on('event', (data) => {
  // 处理数据
});
```

**5. 使用全局状态（简单场景）**

```javascript
// globalState.js
import { reactive } from 'vue';

export const globalState = reactive({
  user: null,
  theme: 'light'
});

// 任何组件中都可以使用
import { globalState } from './globalState';
```

## 6.6 路由

### 1. Vue Router 的导航守卫有哪些？

**完整的导航解析流程**：

```text
导航被触发
↓
调用失活组件的 beforeRouteLeave
↓
调用全局的 beforeEach
↓
在重用的组件里调用 beforeRouteUpdate
↓
在路由配置里调用 beforeEnter
↓
解析异步路由组件
↓
在被激活的组件里调用 beforeRouteEnter
↓
调用全局的 beforeResolve
↓
导航被确认
↓
调用全局的 afterEach
↓
触发 DOM 更新
↓
调用 beforeRouteEnter 守卫中传给 next 的回调函数
```

**导航守卫类型**：

**1. 全局守卫**

```javascript
const router = createRouter({ ... });

// 全局前置守卫
router.beforeEach((to, from, next) => {
  // to: 目标路由
  // from: 当前路由
  // next: 必须调用 next() 才能继续
  
  if (to.meta.requiresAuth && !isAuthenticated()) {
    next('/login'); // 重定向到登录页
  } else {
    next(); // 继续导航
  }
});

// 全局解析守卫（组件和路由守卫解析后调用）
router.beforeResolve((to, from) => {
  // 适合处理需要等待的数据
});

// 全局后置钩子（导航完成后调用）
router.afterEach((to, from) => {
  // 可以用于修改页面标题等
  document.title = to.meta.title || '默认标题';
});
```

**2. 路由独享守卫**

```javascript
const routes = [
  {
    path: '/admin',
    component: Admin,
    beforeEnter: (to, from, next) => {
      // 只对这个路由生效
      if (!isAdmin()) {
        next('/forbidden');
      } else {
        next();
      }
    }
  }
];
```

**3. 组件内守卫**

```vue
<script>
export default {
  // 离开当前路由前调用
  beforeRouteLeave(to, from, next) {
    const answer = window.confirm('确定要离开吗？');
    if (answer) {
      next();
    } else {
      next(false); // 取消导航
    }
  },
  
  // 当前路由改变，但该组件被复用时调用
  beforeRouteUpdate(to, from, next) {
    // 例如：/user/:id 跳转到 /user/:id
    this.userId = to.params.id;
    this.fetchUser();
    next();
  },
  
  // 进入路由前调用（不能访问组件实例 this）
  beforeRouteEnter(to, from, next) {
    next(vm => {
      // 通过回调访问组件实例
      vm.fetchData();
    });
  }
}
</script>
```

### 2. 路由懒加载如何实现？

**Vue 2（Webpack）**：

```javascript
const router = new VueRouter({
  routes: [
    {
      path: '/home',
      component: () => import(/* webpackChunkName: "home" */ './views/Home.vue')
    },
    {
      path: '/about',
      component: () => import(/* webpackChunkName: "about" */ './views/About.vue')
    }
  ]
});
```

**Vue 3（Vite）**：

```javascript
import { createRouter, createWebHistory } from 'vue-router';

const router = createRouter({
  history: createWebHistory(),
  routes: [
    {
      path: '/',
      component: () => import('./views/Home.vue')
    },
    {
      path: '/about',
      // 命名 chunk
      component: () => import(/* webpackChunkName: "about" */ './views/About.vue')
    }
  ]
});
```

**分组打包**：

```javascript
const routes = [
  {
    path: '/user',
    component: () => import(/* webpackChunkName: "user-group" */ './views/User.vue'),
    children: [
      {
        path: 'profile',
        component: () => import(/* webpackChunkName: "user-group" */ './views/UserProfile.vue')
      },
      {
        path: 'settings',
        component: () => import(/* webpackChunkName: "user-group" */ './views/UserSettings.vue')
      }
    ]
  }
];
```

### 3. 动态路由和嵌套路由？

**动态路由**：

```javascript
const routes = [
  // 动态路径参数
  {
    path: '/user/:id',
    component: User,
    props: true // 将 params 作为 props 传递
  },
  
  // 多个动态参数
  {
    path: '/user/:id/posts/:postId',
    component: Post
  },
  
  // 可选参数
  {
    path: '/user/:id?', // id 是可选的
    component: User
  },
  
  // 正则匹配
  {
    path: '/user/:id(\\d+)', // 只匹配数字
    component: User
  },
  
  // 匹配所有路径
  {
    path: '/:pathMatch(.*)*', // 404 页面
    component: NotFound
  }
];
```

**在组件中获取参数**：

```vue
<template>
  <div>用户 ID: {{ $route.params.id }}</div>
</template>

<script>
export default {
  // 方式1：通过 $route
  created() {
    const userId = this.$route.params.id;
  },
  
  // 方式2：通过 props（推荐）
  props: ['id'],
  
  // 方式3：使用 Composition API
  setup() {
    import { useRoute } from 'vue-router';
    const route = useRoute();
    const userId = route.params.id;
    
    return { userId };
  }
}
</script>
```

**嵌套路由**：

```javascript
const routes = [
  {
    path: '/user/:id',
    component: User,
    children: [
      // UserProfile 会被渲染在 User 的 <router-view> 内部
      {
        path: 'profile',
        component: UserProfile
      },
      {
        path: 'posts',
        component: UserPosts
      },
      // 默认子路由
      {
        path: '',
        component: UserDashboard
      }
    ]
  }
];
```

**User 组件模板**：

```vue
<template>
  <div class="user">
    <h2>用户信息</h2>
    <!-- 嵌套路由出口 -->
    <router-view></router-view>
  </div>
</template>
```

### 4. 编程式导航和声明式导航？

**声明式导航**（使用组件）：

```vue
<template>
  <!-- 基础使用 -->
  <router-link to="/home">首页</router-link>
  
  <!-- 命名路由 -->
  <router-link :to="{ name: 'user', params: { id: 123 }}">用户</router-link>
  
  <!-- 带查询参数 -->
  <router-link :to="{ path: '/search', query: { q: 'vue' }}">搜索</router-link>
  
  <!-- 替换当前历史记录 -->
  <router-link :to="/home" replace>首页</router-link>
  
  <!-- 自定义类名 -->
  <router-link 
    to="/about" 
    active-class="active-link"
    exact-active-class="exact-active"
  >
    关于
  </router-link>
</template>
```

**编程式导航**（使用 API）：

```javascript
// Vue 2
export default {
  methods: {
    goToHome() {
      // 字符串路径
      this.$router.push('/home');
      
      // 对象
      this.$router.push({ path: '/home' });
      
      // 命名路由
      this.$router.push({ name: 'user', params: { id: '123' } });
      
      // 带查询参数
      this.$router.push({ path: '/search', query: { q: 'vue' } });
      
      // 替换当前历史记录
      this.$router.replace('/home');
      
      // 前进/后退
      this.$router.go(1);  // 前进一页
      this.$router.go(-1); // 后退一页
      this.$router.back(); // 后退
      this.$router.forward(); // 前进
    }
  }
}

// Vue 3 Composition API
import { useRouter } from 'vue-router';

export default {
  setup() {
    const router = useRouter();
    
    const goToHome = () => {
      router.push('/home');
    };
    
    // 在 setup 中访问路由
    const route = useRoute();
    const userId = route.params.id;
    
    return { goToHome, userId };
  }
}
```

### 5. 路由元信息的使用？

**定义路由元信息**：

```javascript
const routes = [
  {
    path: '/admin',
    component: Admin,
    meta: {
      requiresAuth: true,
      roles: ['admin'],
      title: '管理员面板'
    }
  },
  {
    path: '/dashboard',
    component: Dashboard,
    meta: {
      requiresAuth: true,
      breadcrumb: '控制台'
    }
  }
];
```

**在导航守卫中使用**：

```javascript
router.beforeEach((to, from, next) => {
  // 检查是否需要认证
  if (to.meta.requiresAuth && !isAuthenticated()) {
    next('/login');
    return;
  }
  
  // 检查权限
  if (to.meta.roles && !hasRole(to.meta.roles)) {
    next('/forbidden');
    return;
  }
  
  next();
});
```

**在组件中访问**：

```vue
<template>
  <div>
    <h1>{{ pageTitle }}</h1>
  </div>
</template>

<script>
export default {
  computed: {
    pageTitle() {
      return this.$route.meta.title || '默认标题';
    }
  },
  
  watch: {
    // 监听路由变化更新标题
    $route(to, from) {
      document.title = to.meta.title || '默认标题';
    }
  },
  
  // Composition API
  setup() {
    import { useRoute } from 'vue-router';
    const route = useRoute();
    
    const pageTitle = computed(() => route.meta.title || '默认标题');
    
    return { pageTitle };
  }
}
</script>
```

**嵌套路由的元信息**：

```javascript
const routes = [
  {
    path: '/parent',
    component: Parent,
    meta: { requiresAuth: true },
    children: [
      {
        path: 'child',
        component: Child,
        meta: { roles: ['admin'] }
      }
    ]
  }
];

// 访问 /parent/child 时，meta 为：
// { requiresAuth: true, roles: ['admin'] }
```

## 6.7 性能优化

### 1. Vue 组件如何优化？

**1. 组件懒加载**

```javascript
// 路由懒加载
const User = () => import('./User.vue');

// 组件内懒加载
export default {
  components: {
    HeavyComponent: () => import('./HeavyComponent.vue')
  }
}
```

**2. 异步组件**

```javascript
// Vue 3
import { defineAsyncComponent } from 'vue';

const AsyncComponent = defineAsyncComponent({
  loader: () => import('./HeavyComponent.vue'),
  loadingComponent: LoadingSpinner,
  errorComponent: ErrorComponent,
  delay: 200,
  timeout: 3000
});
```

**3. 组件按需引入**

```javascript
// 第三方组件库按需引入
import { Button, Input } from 'element-ui';

// 或使用 babel-plugin-import 自动按需引入
```

**4. 避免不必要的重新渲染**

```vue
<template>
  <!-- 使用 v-once 渲染静态内容 -->
  <div v-once>静态内容，只渲染一次</div>
  
  <!-- 使用 v-memo 缓存模板 -->
  <div v-memo="[valueA, valueB]">
    依赖 valueA 和 valueB，只有它们变化时才重新渲染
  </div>
</template>
```

**5. 使用函数式组件处理简单渲染**

```javascript
// 无状态、无实例、无生命周期的组件
export default {
  functional: true,
  props: ['message'],
  render(h, context) {
    return h('div', context.props.message);
  }
}
```

**6. 合理使用 computed 和 watch**

```javascript
export default {
  computed: {
    // 使用 computed 缓存计算结果
    filteredList() {
      return this.list.filter(item => item.active);
    }
  },
  
  watch: {
    // 避免深度监听大数据结构
    items: {
      handler() { /* ... */ },
      deep: false // 尽量不使用 deep
    }
  }
}
```

### 2. 虚拟 DOM 的 diff 算法？

**Vue 的 diff 算法特点**：

1.  **同级比较**：只比较同一层级，不跨级比较
    
2.  **深度优先**：从根节点开始递归比较
    
3.  **双端比较**：Vue 2 使用双端比较算法
    
4.  **快速路径**：Vue 3 使用快速路径优化
    

**Vue 2 的 diff 算法（双端比较）**：

```javascript
function updateChildren(parentElm, oldCh, newCh) {
  let oldStartIdx = 0;
  let oldEndIdx = oldCh.length - 1;
  let newStartIdx = 0;
  let newEndIdx = newCh.length - 1;
  
  while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
    if (isSameVnode(oldStartVnode, newStartVnode)) {
      // 头头比较
      patchVnode(oldStartVnode, newStartVnode);
      oldStartIdx++;
      newStartIdx++;
    } else if (isSameVnode(oldEndVnode, newEndVnode)) {
      // 尾尾比较
      patchVnode(oldEndVnode, newEndVnode);
      oldEndIdx--;
      newEndIdx--;
    } else if (isSameVnode(oldStartVnode, newEndVnode)) {
      // 头尾比较
      patchVnode(oldStartVnode, newEndVnode);
      // 移动节点
      parentElm.insertBefore(oldStartVnode.elm, oldEndVnode.elm.nextSibling);
      oldStartIdx++;
      newEndIdx--;
    } else if (isSameVnode(oldEndVnode, newStartVnode)) {
      // 尾头比较
      patchVnode(oldEndVnode, newStartVnode);
      // 移动节点
      parentElm.insertBefore(oldEndVnode.elm, oldStartVnode.elm);
      oldEndIdx--;
      newStartIdx++;
    } else {
      // 使用 key 查找可复用的节点
      // ...
    }
  }
}
```

**Vue 3 的 diff 算法优化**：

1.  **Patch Flag**：标记动态节点类型
    
2.  **静态提升**：静态节点只创建一次
    
3.  **树结构打平**：减少嵌套
    
4.  **事件缓存**：缓存事件处理函数
    

```javascript
// Vue 3 的 Patch Flag 示例
const PatchFlags = {
  TEXT: 1,        // 动态文本节点
  CLASS: 2,       // 动态 class
  STYLE: 4,       // 动态 style
  PROPS: 8,       // 动态属性
  FULL_PROPS: 16, // 动态 key
  HYDRATE_EVENTS: 32,
  STABLE_FRAGMENT: 64,
  KEYED_FRAGMENT: 128,
  UNKEYED_FRAGMENT: 256,
  NEED_PATCH: 512,
  DYNAMIC_SLOTS: 1024,
  DEV_ROOT_FRAGMENT: 2048,
  HOISTED: -1,    // 静态提升
  BAIL: -2        // 差异算法退出
};
```

### 3. 异步组件和代码分割？

**Webpack 代码分割**：

```javascript
// 动态导入语法
const Home = () => import(/* webpackChunkName: "home" */ './views/Home.vue');
const About = () => import(/* webpackChunkName: "about" */ './views/About.vue');

// 分组打包（相同 chunkName 会打包到一起）
const User = () => import(/* webpackChunkName: "user" */ './views/User.vue');
const UserProfile = () => import(/* webpackChunkName: "user" */ './views/UserProfile.vue');
```

**Vite 代码分割**：

```javascript
// Vite 基于 ES 模块，原生支持动态导入
import('./module.js').then(module => {
  // 使用模块
});

// 手动预加载
const module = await import('./module.js');
```

**组件级代码分割**：

```vue
<script>
export default {
  components: {
    // 组件内异步加载
    HeavyComponent: () => import('./HeavyComponent.vue'),
    
    // 带加载状态的异步组件
    AsyncComponent: defineAsyncComponent({
      loader: () => import('./AsyncComponent.vue'),
      loadingComponent: LoadingComponent,
      delay: 200,
      timeout: 3000
    })
  }
}
</script>
```

**路由级代码分割**：

```javascript
const router = createRouter({
  routes: [
    {
      path: '/',
      component: () => import('./views/Home.vue')
    },
    {
      path: '/about',
      component: () => import('./views/About.vue'),
      // 路由独享的守卫
      beforeEnter: (to, from, next) => {
        // 可以在路由进入前预加载数据
        next();
      }
    }
  ]
});
```

### 4. 如何减少不必要的重新渲染？

**1. 使用 v-if 替代 v-show（对于不常切换的组件）**

```vue
<template>
  <!-- 使用 v-if，不渲染时完全销毁 -->
  <HeavyComponent v-if="show" />
  
  <!-- 使用 v-show，始终渲染只是切换 display -->
  <HeavyComponent v-show="show" />
</template>
```

**2. 使用 v-once 和 v-memo**

```vue
<template>
  <!-- v-once：只渲染一次 -->
  <div v-once>{{ staticContent }}</div>
  
  <!-- v-memo：依赖变化时才重新渲染 -->
  <div v-memo="[id, type]">
    复杂渲染逻辑
  </div>
</template>
```

**3. 合理使用 computed 缓存**

```javascript
export default {
  computed: {
    // 使用 computed 缓存，依赖不变不重新计算
    filteredItems() {
      return this.items.filter(item => item.active);
    }
  }
}
```

**4. 使用函数式组件处理无状态组件**

```javascript
export default {
  functional: true,
  props: ['item'],
  render(h, context) {
    return h('div', context.props.item.name);
  }
}
```

**5. 避免不必要的响应式数据**

```javascript
export default {
  data() {
    return {
      // 对于不会变化的数据，不需要响应式
      staticData: Object.freeze({
        version: '1.0.0',
        config: { /* ... */ }
      })
    }
  }
}
```

**6. 手动控制组件更新**

```javascript
export default {
  methods: {
    forceUpdateIfNeeded() {
      // 使用 $forceUpdate 强制更新
      this.$forceUpdate();
    }
  }
}
```

### 5. 使用 Object.freeze 优化性能？

**作用**：阻止修改现有属性的特性和值，并阻止添加新属性

**为什么能优化性能**：

*   Vue 无法为冻结的对象添加 getter/setter
    
*   减少响应式系统的开销
    
*   适合静态数据
    

**使用示例**：

```javascript
export default {
  data() {
    return {
      // 静态配置数据，使用 Object.freeze
      config: Object.freeze({
        version: '1.0.0',
        features: ['a', 'b', 'c'],
        settings: {
          theme: 'dark',
          language: 'zh-CN'
        }
      }),
      
      // 大量静态数据列表
      hugeList: Object.freeze([
        { id: 1, name: 'Item 1' },
        { id: 2, name: 'Item 2' },
        // ... 大量数据
      ])
    }
  },
  
  created() {
    // 尝试修改会静默失败（严格模式下报错）
    this.config.version = '2.0.0'; // 不会生效
    console.log(this.config.version); // '1.0.0'
    
    // 嵌套对象也需要冻结
    const deepFreeze = (obj) => {
      Object.freeze(obj);
      Object.keys(obj).forEach(key => {
        if (typeof obj[key] === 'object' && obj[key] !== null) {
          deepFreeze(obj[key]);
        }
      });
    };
  }
}
```

**适用场景**：

1.  静态配置数据
    
2.  常量数据
    
3.  不会变化的数据列表
    
4.  第三方库返回的只读数据
    

**注意**：

*   冻结对象后无法添加、删除、修改属性
    
*   嵌套对象需要递归冻结
    
*   冻结是浅层的，深冻结需要递归处理
    

## 6.8 工具与生态

### 1. Vue CLI 和 Vite 的区别？

| 特性  | Vue CLI | Vite |
| --- | --- | --- |
| 构建工具 | Webpack | Rollup + ESBuild |
| 启动速度 | 较慢（打包后启动） | 极快（ESM 原生加载） |
| 热更新 | 较慢（重新编译） | 极快（按需编译） |
| 配置复杂度 | 配置复杂 | 配置简单 |
| 插件生态 | 成熟  | 快速发展 |
| 适用项目 | 传统大型项目 | 现代项目 |

**Vue CLI 配置示例**：

```javascript
// vue.config.js
module.exports = {
  // 基础配置
  publicPath: process.env.NODE_ENV === 'production' ? '/app/' : '/',
  outputDir: 'dist',
  
  // 开发服务器
  devServer: {
    port: 8080,
    proxy: {
      '/api': {
        target: 'http://localhost:3000',
        changeOrigin: true
      }
    }
  },
  
  // Webpack 配置
  configureWebpack: {
    plugins: [
      new MyWebpackPlugin()
    ]
  },
  
  chainWebpack: config => {
    config.module
      .rule('svg')
      .exclude.add(resolve('src/icons'))
      .end();
  }
};
```

**Vite 配置示例**：

```javascript
// vite.config.js
import { defineConfig } from 'vite';
import vue from '@vitejs/plugin-vue';

export default defineConfig({
  // 插件
  plugins: [vue()],
  
  // 开发服务器
  server: {
    port: 3000,
    proxy: {
      '/api': {
        target: 'http://localhost:8080',
        changeOrigin: true
      }
    }
  },
  
  // 构建配置
  build: {
    rollupOptions: {
      output: {
        chunkFileNames: 'assets/js/[name]-[hash].js',
        entryFileNames: 'assets/js/[name]-[hash].js',
        assetFileNames: 'assets/[ext]/[name]-[hash].[ext]'
      }
    }
  },
  
  // 解析别名
  resolve: {
    alias: {
      '@': '/src'
    }
  }
});
```

### 2. Nuxt.js 的核心特性？

**核心特性**：

1.  **服务端渲染（SSR）**：更好的 SEO 和首屏加载
    
2.  **静态站点生成（SSG）**：预渲染为静态 HTML
    
3.  **自动路由**：基于文件结构自动生成路由
    
4.  **数据获取**：内置 asyncData、fetch 方法
    
5.  **模块系统**：可扩展的模块化架构
    

**Nuxt 3 项目结构**：

```text
├── nuxt.config.ts      # Nuxt 配置
├── app.vue            # 应用入口
├── pages/             # 页面目录（自动生成路由）
│   ├── index.vue
│   └── about.vue
├── components/        # 组件目录
├── layouts/          # 布局目录
├── composables/      # 可组合函数
├── middleware/       # 中间件
├── plugins/          # 插件
├── server/           # 服务端 API
└── public/           # 静态资源
```

**页面组件示例**：

```vue
<!-- pages/index.vue -->
<template>
  <div>
    <h1>{{ title }}</h1>
    <p>用户数: {{ users.length }}</p>
  </div>
</template>

<script setup>
// 服务端数据获取
const { data: users } = await useFetch('/api/users');

// SEO 配置
useHead({
  title: '首页',
  meta: [
    { name: 'description', content: '首页描述' }
  ]
});

const title = ref('欢迎来到 Nuxt 3');
</script>
```

**API 路由**：

```javascript
// server/api/users.js
export default defineEventHandler(async (event) => {
  // 从数据库获取数据
  const users = await db.user.findMany();
  
  return { 
    users,
    timestamp: new Date()
  };
});
```

### 3. Vue DevTools 的使用技巧？

**安装**：

```bash
# Chrome 商店安装 Vue DevTools
# 或手动安装
npm install -g @vue/devtools
```

**核心功能**：

1.  **组件树查看**
    
    *   查看组件层级结构
        
    *   查看组件 props、data、computed
        
    *   查看组件事件
        
2.  **Vuex/Pinia 调试**
    
    *   查看状态变化
        
    *   时间旅行调试
        
    *   状态快照
        
3.  **事件追踪**
    
    *   查看组件发出的事件
        
    *   查看全局事件总线事件
        
4.  **性能分析**
    
    *   组件渲染时间
        
    *   性能时间线
        

**实用技巧**：

1.  **快速定位组件**：
    
    *   点击组件树中的组件，在页面中高亮显示
        
    *   使用页面中的"选择组件"工具
        
2.  **编辑组件状态**：
    
    *   直接在 DevTools 中修改组件 data
        
    *   实时查看修改效果
        
3.  **路由调试**：
    
    *   查看当前路由信息
        
    *   手动触发路由跳转
        
4.  **自定义指令**：
    

```javascript
// 在组件中添加自定义 DevTools 标签
export default {
  name: 'MyComponent',
  // 自定义 DevTools 显示
  devtools: {
    hide: false, // 是否隐藏
    inspectOptions: {},
    labels: ['custom', 'labels']
  }
}
```

### 4. Vue Test Utils 的使用？

**安装**：

```bash
npm install @vue/test-utils jest vue-jest
```

**组件测试示例**：

```javascript
// Counter.vue
<template>
  <div>
    <span data-test="count">{{ count }}</span>
    <button @click="increment" data-test="increment-btn">增加</button>
  </div>
</template>

<script>
export default {
  data() {
    return { count: 0 };
  },
  methods: {
    increment() {
      this.count++;
      this.$emit('incremented', this.count);
    }
  }
};
</script>

// Counter.spec.js
import { mount } from '@vue/test-utils';
import Counter from './Counter.vue';

describe('Counter.vue', () => {
  test('渲染初始值', () => {
    const wrapper = mount(Counter);
    expect(wrapper.find('[data-test="count"]').text()).toBe('0');
  });
  
  test('点击按钮增加计数', async () => {
    const wrapper = mount(Counter);
    const button = wrapper.find('[data-test="increment-btn"]');
    
    await button.trigger('click');
    expect(wrapper.find('[data-test="count"]').text()).toBe('1');
  });
  
  test('触发 incremented 事件', async () => {
    const wrapper = mount(Counter);
    
    wrapper.vm.increment();
    await wrapper.vm.$nextTick();
    
    expect(wrapper.emitted().incremented).toBeTruthy();
    expect(wrapper.emitted().incremented[0]).toEqual([1]);
  });
  
  test('使用 props', () => {
    const wrapper = mount(Counter, {
      props: {
        initialCount: 10
      }
    });
    
    expect(wrapper.props('initialCount')).toBe(10);
  });
  
  test('模拟 API 调用', async () => {
    const mockApi = {
      fetchData: jest.fn(() => Promise.resolve({ data: 'test' }))
    };
    
    const wrapper = mount(Component, {
      global: {
        provide: {
          api: mockApi
        }
      }
    });
    
    await wrapper.vm.loadData();
    expect(mockApi.fetchData).toHaveBeenCalled();
  });
});
```

**测试工具函数**：

```javascript
import { shallowMount, mount, flushPromises } from '@vue/test-utils';

// shallowMount：浅渲染，不渲染子组件
const wrapper = shallowMount(Component);

// mount：完全渲染
const wrapper = mount(Component, {
  props: { msg: 'Hello' },
  data() {
    return { count: 1 };
  },
  global: {
    stubs: {
      // 存根子组件
      ChildComponent: true
    },
    mocks: {
      // 模拟全局对象
      $t: (key) => key
    },
    plugins: [
      // 使用插件
      router,
      store
    ]
  }
});

// 常用方法
wrapper.find('button'); // 查找元素
wrapper.findAll('li'); // 查找所有元素
wrapper.get('.class'); // 获取元素（找不到会报错）
wrapper.trigger('click'); // 触发事件
wrapper.setData({ count: 2 }); // 设置数据
wrapper.setProps({ msg: 'Hi' }); // 设置 props
wrapper.emitted(); // 获取触发的事件
wrapper.html(); // 获取 HTML
wrapper.text(); // 获取文本
```

## 6.9 进阶概念

### 1. 什么是渲染函数（render function）？

**渲染函数**：用 JavaScript 编写模板的替代方式，提供更灵活的模板控制

**模板 vs 渲染函数**：

```vue
<!-- 模板语法 -->
<template>
  <div>
    <h1 v-if="level === 1">
      <slot></slot>
    </h1>
    <h2 v-if="level === 2">
      <slot></slot>
    </h2>
  </div>
</template>

<script>
// 渲染函数实现
export default {
  props: ['level'],
  render(h) {
    return h(
      'h' + this.level, // 标签名
      {},               // 属性
      this.$slots.default // 子节点
    );
  }
}
</script>
```

**h 函数参数**：

```javascript
// 创建虚拟节点
h(
  'div',              // 标签名、组件或异步组件
  {                   // 属性/Props
    class: 'container',
    style: { color: 'red' },
    onClick: this.handleClick,
    // 特殊属性
    key: 'my-key',
    ref: 'myRef',
    refInFor: true
  },
  [                   // 子节点
    '文本内容',
    h('span', '子元素'),
    this.$slots.default()
  ]
)
```

**JSX 形式的渲染函数**：

```jsx
import { h } from 'vue';

export default {
  props: ['items'],
  setup(props) {
    return () => (
      <ul>
        {props.items.map(item => (
          <li key={item.id}>{item.name}</li>
        ))}
      </ul>
    );
  }
};
```

**使用场景**：

1.  动态标签名或组件
    
2.  高级组件模式（高阶组件）
    
3.  需要完全控制渲染逻辑时
    
4.  需要 JavaScript 的全部能力时
    

### 2. JSX 在 Vue 中的使用？

**配置**：

```bash
# Vue CLI
vue add babel-preset-jsx

# 或手动安装
npm install @vue/babel-plugin-jsx -D
```

```javascript
// babel.config.js
module.exports = {
  presets: ['@vue/cli-plugin-babel/preset'],
  plugins: ['@vue/babel-plugin-jsx']
};
```

**基本用法**：

```jsx
// Vue 2
export default {
  data() {
    return {
      count: 0
    };
  },
  methods: {
    increment() {
      this.count++;
    }
  },
  render() {
    return (
      <div>
        <button onClick={this.increment}>
          点击次数: {this.count}
        </button>
      </div>
    );
  }
};

// Vue 3 Composition API
import { ref } from 'vue';

export default {
  setup() {
    const count = ref(0);
    const increment = () => count.value++;
    
    return () => (
      <div>
        <button onClick={increment}>
          点击次数: {count.value}
        </button>
      </div>
    );
  }
};
```

**JSX 指令**：

```jsx
export default {
  setup() {
    const list = ref([1, 2, 3]);
    const isVisible = ref(true);
    
    return () => (
      <div>
        {/* v-if */}
        {isVisible.value && <div>显示内容</div>}
        
        {/* v-for */}
        {list.value.map(item => (
          <div key={item}>{item}</div>
        ))}
        
        {/* v-model */}
        <input vModel={text.value} />
        
        {/* 事件修饰符 */}
        <button onClickOnce={handleClick}>点击一次</button>
        
        {/* 插槽 */}
        <MyComponent>
          {{
            default: () => <div>默认插槽</div>,
            header: () => <h1>标题</h1>
          }}
        </MyComponent>
      </div>
    );
  }
};
```

### 3. 自定义渲染器（Custom Renderer）？

**作用**：允许 Vue 在不同的平台上运行

**Vue 3 自定义渲染器示例**：

```javascript
import { createRenderer } from 'vue';

// 自定义渲染器（用于 Canvas）
const { createApp } = createRenderer({
  // 创建元素
  createElement(type, props, children) {
    if (type === 'rect') {
      return {
        type: 'rect',
        props,
        children
      };
    }
    // 其他元素类型...
  },
  
  // 插入元素
  insert(el, parent) {
    if (parent.type === 'canvas') {
      // 在 Canvas 上绘制
      const ctx = parent.ctx;
      if (el.type === 'rect') {
        ctx.fillStyle = el.props.color || 'black';
        ctx.fillRect(
          el.props.x,
          el.props.y,
          el.props.width,
          el.props.height
        );
      }
    }
  },
  
  // 设置属性
  patchProp(el, key, prevValue, nextValue) {
    el.props[key] = nextValue;
  },
  
  // 设置文本
  setElementText(node, text) {
    node.textContent = text;
  },
  
  // 移除元素
  remove(child) {
    // 从 Canvas 中移除
  },
  
  // 创建文本节点
  createText(text) {
    return { type: 'text', text };
  },
  
  // 创建注释节点
  createComment(text) {
    return { type: 'comment', text };
  },
  
  // 父节点
  parentNode(node) {
    return node.parent;
  },
  
  // 兄弟节点
  nextSibling(node) {
    const children = node.parent?.children;
    const index = children?.indexOf(node);
    return children?.[index + 1];
  }
});

// 使用自定义渲染器
const app = createApp({
  setup() {
    const x = ref(0);
    const y = ref(0);
    
    const move = () => {
      x.value += 10;
      y.value += 10;
    };
    
    return () => [
      h('rect', { color: 'red', x: x.value, y: y.value, width: 100, height: 100 }),
      h('button', { onClick: move }, '移动')
    ];
  }
});

// 挂载到 Canvas
const canvas = document.getElementById('canvas');
app.mount(canvas);
```

**应用场景**：

1.  小程序渲染（uni-app、Taro）
    
2.  Canvas/SVG 渲染
    
3.  原生应用（Weex、NativeScript）
    
4.  终端应用（命令行界面）
    

### 4. Vue 的编译过程？

**完整编译流程**：

```text
模板字符串
    ↓
解析器（Parser）
    ↓
AST（抽象语法树）
    ↓
转换器（Transformer）
    ↓
优化后的 AST
    ↓
代码生成器（Codegen）
    ↓
渲染函数代码
    ↓
渲染函数
```

**解析阶段**：

```javascript
// 模板：<div id="app">{{ message }}</div>
const ast = {
  type: 1, // 元素节点
  tag: 'div',
  attrsList: [{ name: 'id', value: 'app' }],
  attrsMap: { id: 'app' },
  rawAttrsMap: {},
  parent: undefined,
  children: [{
    type: 2, // 表达式节点
    expression: '_s(message)',
    text: '{{ message }}',
    tokens: [{ '@binding': 'message' }]
  }]
};
```

**优化阶段**：

```javascript
function markStatic(node) {
  node.static = isStatic(node);
  if (node.type === 1) {
    for (let i = 0; i < node.children.length; i++) {
      const child = node.children[i];
      markStatic(child);
      if (!child.static) {
        node.static = false;
      }
    }
  }
}

function isStatic(node) {
  if (node.type === 2) { // 表达式
    return false;
  }
  if (node.type === 3) { // 文本
    return true;
  }
  // 检查元素节点...
}
```

**代码生成阶段**：

```javascript
function generate(ast, options) {
  const state = new CodegenState(options);
  const code = ast ? genElement(ast, state) : '_c("div")';
  
  return {
    render: `with(this){return ${code}}`,
    staticRenderFns: state.staticRenderFns
  };
}

function genElement(el, state) {
  if (el.staticRoot && !el.staticProcessed) {
    return genStatic(el, state);
  } else if (el.once && !el.onceProcessed) {
    return genOnce(el, state);
  } else if (el.for && !el.forProcessed) {
    return genFor(el, state);
  } else if (el.if && !el.ifProcessed) {
    return genIf(el, state);
  } else if (el.tag === 'template' && !el.slotTarget) {
    return genChildren(el, state) || 'void 0';
  } else if (el.tag === 'slot') {
    return genSlot(el, state);
  } else {
    // 组件或元素
    const code = el.component
      ? genComponent(el.component, el, state)
      : genData(el, state);
    
    const children = el.inlineTemplate ? null : genChildren(el, state, true);
    
    return `_c('${el.tag}'${
      code ? `,${code}` : ''
    }${
      children ? `,${children}` : ''
    })`;
  }
}
```

### 5. 插件开发规范？

**Vue 2 插件开发**：

```javascript
// my-plugin.js
const MyPlugin = {
  install(Vue, options) {
    // 1. 添加全局方法或属性
    Vue.myGlobalMethod = function() {
      console.log('全局方法');
    };
    
    // 2. 添加全局资源
    Vue.directive('my-directive', {
      bind(el, binding) {
        // 指令逻辑
      }
    });
    
    // 3. 注入组件选项
    Vue.mixin({
      created() {
        console.log('来自插件的 created 钩子');
      }
    });
    
    // 4. 添加实例方法
    Vue.prototype.$myMethod = function() {
      console.log('实例方法');
    };
  }
};

// 使用
import MyPlugin from './my-plugin';
Vue.use(MyPlugin, { someOption: true });
```

**Vue 3 插件开发**：

```javascript
// my-plugin.js
import { provide, inject } from 'vue';

// 创建注入的 key（唯一标识）
const StoreKey = Symbol('store');

export function createStore(options) {
  const store = reactive({
    state: options.state || {},
    // ...其他选项
  });
  
  return store;
}

export function useStore() {
  const store = inject(StoreKey);
  if (!store) {
    throw new Error('Store not provided');
  }
  return store;
}

export default {
  install(app, options) {
    // 创建 store 实例
    const store = createStore(options);
    
    // 提供全局状态
    app.provide(StoreKey, store);
    
    // 添加全局属性
    app.config.globalProperties.$store = store;
    
    // 添加全局组件
    app.component('MyComponent', {
      template: '<div>全局组件</div>'
    });
    
    // 添加全局指令
    app.directive('focus', {
      mounted(el) {
        el.focus();
      }
    });
    
    // 使用 mixin
    app.mixin({
      created() {
        console.log('来自插件的 mixin');
      }
    });
  }
};

// 使用
import { createApp } from 'vue';
import MyPlugin from './my-plugin';

const app = createApp(App);
app.use(MyPlugin, {
  state: { count: 0 }
});
app.mount('#app');
```

**插件最佳实践**：

1.  提供清晰的安装说明
    
2.  支持选项配置
    
3.  避免全局污染
    
4.  提供 TypeScript 类型定义
    
5.  保持向后兼容
    

## 6.10 原理深入

### 1. 依赖收集和派发更新的过程？

**完整流程**：

```text
数据劫持（defineProperty/Proxy）
    ↓
访问数据时触发 getter
    ↓
收集依赖（当前 Watcher/Effect）
    ↓
修改数据时触发 setter
    ↓
派发更新（通知所有依赖）
    ↓
依赖执行更新（重新渲染/执行回调）
```

**Vue 2 依赖收集**：

```javascript
class Dep {
  constructor() {
    this.subs = []; // 订阅者列表
  }
  
  addSub(sub) {
    this.subs.push(sub);
  }
  
  removeSub(sub) {
    const index = this.subs.indexOf(sub);
    if (index > -1) {
      this.subs.splice(index, 1);
    }
  }
  
  depend() {
    if (Dep.target) {
      Dep.target.addDep(this);
    }
  }
  
  notify() {
    const subs = this.subs.slice();
    for (let i = 0; i < subs.length; i++) {
      subs[i].update();
    }
  }
}

Dep.target = null; // 当前正在计算的 Watcher
```

**Watcher 类**：

```javascript
class Watcher {
  constructor(vm, expOrFn, cb, options) {
    this.vm = vm;
    this.cb = cb;
    this.deps = [];
    this.depIds = new Set();
    
    if (typeof expOrFn === 'function') {
      this.getter = expOrFn;
    } else {
      this.getter = parsePath(expOrFn);
    }
    
    this.value = this.get();
  }
  
  get() {
    Dep.target = this; // 设置当前 Watcher
    let value;
    try {
      value = this.getter.call(this.vm, this.vm);
    } finally {
      Dep.target = null; // 清除当前 Watcher
    }
    return value;
  }
  
  addDep(dep) {
    if (!this.depIds.has(dep.id)) {
      this.deps.push(dep);
      this.depIds.add(dep.id);
      dep.addSub(this);
    }
  }
  
  update() {
    // 异步更新队列
    queueWatcher(this);
  }
  
  run() {
    const value = this.get();
    if (value !== this.value) {
      const oldValue = this.value;
      this.value = value;
      this.cb.call(this.vm, value, oldValue);
    }
  }
}
```

**Vue 3 的响应式系统**：

```javascript
// 使用 Effect 跟踪依赖
let activeEffect;

class ReactiveEffect {
  constructor(fn) {
    this.fn = fn;
    this.deps = [];
  }
  
  run() {
    activeEffect = this;
    try {
      return this.fn();
    } finally {
      activeEffect = undefined;
    }
  }
  
  stop() {
    // 清理依赖
  }
}

// 依赖收集
function track(target, key) {
  if (activeEffect) {
    let depsMap = targetMap.get(target);
    if (!depsMap) {
      targetMap.set(target, (depsMap = new Map()));
    }
    
    let dep = depsMap.get(key);
    if (!dep) {
      depsMap.set(key, (dep = new Set()));
    }
    
    dep.add(activeEffect);
    activeEffect.deps.push(dep);
  }
}

// 派发更新
function trigger(target, key) {
  const depsMap = targetMap.get(target);
  if (!depsMap) return;
  
  const effects = depsMap.get(key);
  if (effects) {
    effects.forEach(effect => {
      if (effect !== activeEffect) {
        if (effect.scheduler) {
          effect.scheduler();
        } else {
          effect.run();
        }
      }
    });
  }
}
```

### 2. 虚拟 DOM 的优势？

**优势**：

1.  **性能优化**：减少直接操作 DOM 的次数
    
2.  **跨平台**：可以在不同平台渲染（Web、Native、Canvas）
    
3.  **声明式编程**：关注数据，不关注 DOM 操作细节
    
4.  **差异化更新**：只更新变化的部分
    

**虚拟 DOM 结构**：

```javascript
const vnode = {
  tag: 'div',
  data: {
    attrs: { id: 'app' },
    class: 'container',
    style: { color: 'red' },
    on: { click: handleClick }
  },
  children: [
    { tag: 'span', text: 'Hello' },
    { tag: 'button', children: ['Click'] }
  ],
  key: 'unique-key',
  elm: null, // 对应的真实 DOM
  context: {}, // 组件上下文
  componentOptions: {} // 组件选项
};
```

**虚拟 DOM 操作 vs 真实 DOM 操作**：

```javascript
// 真实 DOM 操作（昂贵）
document.getElementById('app').innerHTML = '<div>New Content</div>';

// 虚拟 DOM 操作
const oldVnode = { tag: 'div', children: ['Old'] };
const newVnode = { tag: 'div', children: ['New'] };

// 对比差异
const patches = diff(oldVnode, newVnode);
// 应用差异
patch(realDOM, patches);
```

**性能对比**：

```javascript
// 大量 DOM 更新场景
const items = [/* 1000个数据 */];

// 真实 DOM（性能差）
items.forEach(item => {
  const li = document.createElement('li');
  li.textContent = item;
  list.appendChild(li);
});

// 虚拟 DOM（性能好）
const vnode = h('ul', 
  items.map(item => h('li', item))
);
patch(oldVnode, vnode);
```

### 3. patch 算法的具体过程？

**patch 核心流程**：

```javascript
function patch(oldVnode, vnode) {
  // 没有旧节点，直接创建
  if (!oldVnode) {
    createElm(vnode);
  } 
  // 相同节点，进行更新
  else if (sameVnode(oldVnode, vnode)) {
    patchVnode(oldVnode, vnode);
  }
  // 不同节点，替换
  else {
    const oldEl = oldVnode.elm;
    const parentEl = oldEl.parentNode;
    
    // 创建新节点
    createElm(vnode);
    
    // 插入新节点，移除旧节点
    parentEl.insertBefore(vnode.elm, oldEl);
    parentEl.removeChild(oldEl);
  }
  
  return vnode.elm;
}

function patchVnode(oldVnode, vnode) {
  const elm = vnode.elm = oldVnode.elm;
  
  // 文本节点
  if (oldVnode.text && vnode.text) {
    if (oldVnode.text !== vnode.text) {
      elm.textContent = vnode.text;
    }
  }
  // 元素节点
  else {
    const oldCh = oldVnode.children;
    const ch = vnode.children;
    
    // 更新属性
    updateAttrs(elm, oldVnode.data, vnode.data);
    
    // 都有子节点
    if (oldCh && ch) {
      updateChildren(elm, oldCh, ch);
    }
    // 只有新节点有子节点
    else if (ch) {
      addVnodes(elm, null, ch, 0, ch.length - 1);
    }
    // 只有旧节点有子节点
    else if (oldCh) {
      removeVnodes(elm, oldCh, 0, oldCh.length - 1);
    }
  }
}

// Vue 2 的双端比较算法
function updateChildren(parentElm, oldCh, newCh) {
  let oldStartIdx = 0;
  let newStartIdx = 0;
  let oldEndIdx = oldCh.length - 1;
  let newEndIdx = newCh.length - 1;
  
  while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
    // 四种比较情况...
  }
  
  // 处理剩余节点
  if (oldStartIdx > oldEndIdx) {
    // 添加新节点
  } else if (newStartIdx > newEndIdx) {
    // 移除旧节点
  }
}
```

### 4. Vue 的批量更新策略？

**异步更新队列**：

```javascript
let queue = [];
let has = {};
let waiting = false;
let flushing = false;
let index = 0;

function queueWatcher(watcher) {
  const id = watcher.id;
  
  // 去重
  if (!has[id]) {
    has[id] = true;
    
    if (!flushing) {
      queue.push(watcher);
    } else {
      // 如果正在刷新队列，按 id 插入到正确位置
      let i = queue.length - 1;
      while (i > index && queue[i].id > watcher.id) {
        i--;
      }
      queue.splice(i + 1, 0, watcher);
    }
    
    // 等待下一轮更新
    if (!waiting) {
      waiting = true;
      nextTick(flushSchedulerQueue);
    }
  }
}

function flushSchedulerQueue() {
  flushing = true;
  
  // 排序，确保：
  // 1. 父组件先于子组件更新
  // 2. 用户 watcher 先于渲染 watcher
  // 3. 如果一个组件在父组件更新时被销毁，跳过它的 watcher
  queue.sort((a, b) => a.id - b.id);
  
  for (index = 0; index < queue.length; index++) {
    const watcher = queue[index];
    has[watcher.id] = null;
    watcher.run();
  }
  
  // 清理
  resetSchedulerState();
}

function resetSchedulerState() {
  index = queue.length = 0;
  has = {};
  waiting = flushing = false;
}
```

**为什么需要批量更新**：

1.  **性能优化**：避免频繁的 DOM 操作
    
2.  **保证一致性**：在一次事件循环中，多次数据变化只会触发一次更新
    
3.  **避免重复计算**：减少不必要的计算和渲染
    

**示例**：

```javascript
export default {
  data() {
    return {
      a: 1,
      b: 2,
      c: 3
    }
  },
  methods: {
    updateAll() {
      // 这三个更新会被合并
      this.a = 10;
      this.b = 20;
      this.c = 30;
      
      // DOM 还没有更新
      console.log(this.$el.textContent); // 旧值
      
      this.$nextTick(() => {
        // DOM 已经更新
        console.log(this.$el.textContent); // 新值
      });
    }
  }
}
```

## 6.11 新特性与趋势

### 1. Vue 3.3+ 新增了哪些特性？

**1. `<script setup>` 语法糖增强**

```vue
<script setup>
// 定义 props（更简洁）
const props = defineProps({
  title: String,
  count: { type: Number, default: 0 }
});

// 定义 emits
const emit = defineEmits(['update:title']);

// 定义 expose
defineExpose({
  someMethod() {
    console.log('暴露的方法');
  }
});

// 使用 options
defineOptions({
  name: 'MyComponent',
  inheritAttrs: false
});
</script>
```

**2. 泛型组件**

```vue
<script setup lang="ts" generic="T extends string | number">
import { ref } from 'vue';

const props = defineProps<{
  items: T[];
  selected: T;
}>();

const value = ref<T>();
</script>
```

**3. defineModel（实验性）**

```vue
<script setup>
// 双向绑定简化
const modelValue = defineModel();
// 或带选项
const title = defineModel('title', { required: true });

// 使用
const inputValue = ref('');
</script>

<template>
  <input v-model="inputValue" />
</template>
```

**4. 更好的 TypeScript 支持**

*   改进的 defineProps 类型推断
    
*   导入类型作为 props
    
*   更准确的 emit 类型
    

**5. 响应式 Props 解构**

```javascript
import { toRefs } from 'vue';

const props = defineProps<{ count: number }>();

// 保持响应性
const { count } = toRefs(props);
```

### 2. Vue 的组合式函数（Composables）最佳实践？

**命名约定**：

```javascript
// use + 驼峰命名
export function useMouse() { /* ... */ }
export function useFetch() { /* ... */ }
```

**基本结构**：

```javascript
// useCounter.js
import { ref, computed } from 'vue';

export function useCounter(initialValue = 0) {
  // 状态
  const count = ref(initialValue);
  
  // 计算属性
  const double = computed(() => count.value * 2);
  
  // 方法
  const increment = () => count.value++;
  const decrement = () => count.value--;
  const reset = () => count.value = initialValue;
  
  // 返回
  return {
    count,
    double,
    increment,
    decrement,
    reset
  };
}
```

**使用示例**：

```vue
<script setup>
import { useCounter } from './useCounter';

const { count, double, increment } = useCounter(10);
</script>

<template>
  <div>
    <p>Count: {{ count }}</p>
    <p>Double: {{ double }}</p>
    <button @click="increment">增加</button>
  </div>
</template>
```

**最佳实践**：

1.  **单一职责**：每个 composable 只关注一个功能
    
2.  **响应式数据**：使用 ref/reactive 返回响应式数据
    
3.  **清理副作用**：在 onUnmounted 中清理
    
4.  **参数化**：支持配置选项
    
5.  **TypeScript 支持**：提供完整的类型定义
    

**带副作用的 composable**：

```javascript
// useEventListener.js
import { onMounted, onUnmounted } from 'vue';

export function useEventListener(target, event, callback) {
  // 添加事件监听
  onMounted(() => {
    target.addEventListener(event, callback);
  });
  
  // 清理
  onUnmounted(() => {
    target.removeEventListener(event, callback);
  });
  
  // 返回清理函数（可选）
  return () => {
    target.removeEventListener(event, callback);
  };
}
```

### 3. Vue 的未来发展方向？

**近期重点**：

1.  **Vapor Mode**：更快的编译模式，减少虚拟 DOM 开销
    
2.  **服务端组件**：更好的 SSR 支持
    
3.  **Reactivity Transform**：简化响应式语法
    
4.  **性能优化**：更小的包体积，更快的渲染
    

**Vapor Mode 示例**：

```vue
<!-- 传统虚拟 DOM -->
<template>
  <div>{{ count }}</div>
</template>

<!-- Vapor Mode（概念） -->
<template vapor>
  <!-- 编译为更高效的命令式代码 -->
</template>
```

**生态发展**：

1.  **Vite 成为标准构建工具**
    
2.  **Pinia 作为官方推荐的状态管理**
    
3.  **Nuxt 3 的推广**
    
4.  **更多的官方工具和库**
    

### 4. 如何从 Vue 2 迁移到 Vue 3？

**迁移步骤**：

1.  **准备工作**
    
    ```bash
    # 安装迁移工具
    npm install @vue/compat
    ```
    
2.  **创建兼容版本**
    

    ```javascript
    // main.js
    import { createApp } from 'vue';
    import Vue from '@vue/compat';
    
    const app = createApp(App);
    app.mount('#app');
    ```
    
3.  **逐步迁移**
    
    *   从组件库开始
        
    *   更新 API 使用
        
    *   修复兼容性警告
        

**主要变化处理**：

**1. 全局 API 变化**

```javascript
// Vue 2
Vue.component('my-component', MyComponent);
Vue.directive('focus', FocusDirective);
Vue.mixin({ /* ... */ });
Vue.use(MyPlugin);

// Vue 3
const app = createApp(App);
app.component('my-component', MyComponent);
app.directive('focus', FocusDirective);
app.mixin({ /* ... */ });
app.use(MyPlugin);
```

**2. 事件 API 变化**

```javascript
// Vue 2
this.$on('event', handler);
this.$once('event', handler);
this.$off('event', handler);

// Vue 3（使用外部库如 mitt）
import mitt from 'mitt';
const emitter = mitt();
emitter.on('event', handler);
emitter.emit('event', data);
```

**3. 过滤器移除**

```javascript
// Vue 2
{{ message | capitalize }}

// Vue 3（使用计算属性或方法）
{{ capitalize(message) }}
```

**4. v-model 变化**

```javascript
// Vue 2
<ChildComponent v-model="value" />

// Vue 3
<ChildComponent v-model:title="pageTitle" />
<ChildComponent v-model:title="pageTitle" v-model:content="pageContent" />
```

**迁移工具**：

```bash
# 使用官方迁移构建
vue add vue-next

# 或使用 @vue/compat
```

## 6.12 实战与架构

### 1. 如何设计大型 Vue 项目结构？

**推荐的项目结构**：

```text
src/
├── assets/              # 静态资源
│   ├── images/
│   ├── fonts/
│   └── styles/
│       ├── variables.scss
│       ├── mixins.scss
│       └── global.scss
├── components/          # 公共组件
│   ├── common/         # 全局通用组件
│   ├── layout/         # 布局组件
│   └── ui/             # UI 基础组件
├── composables/         # 组合式函数
│   ├── useFetch.ts
│   ├── useStorage.ts
│   └── index.ts
├── directives/          # 自定义指令
├── router/              # 路由配置
│   ├── index.ts
│   ├── routes/         # 路由定义
│   └── guards/         # 导航守卫
├── store/               # 状态管理
│   ├── modules/        # 模块
│   └── index.ts
├── services/            # API 服务层
│   ├── api.ts          # axios 配置
│   ├── user.service.ts
│   └── product.service.ts
├── types/               # TypeScript 类型定义
├── utils/               # 工具函数
├── views/               # 页面组件
├── App.vue
└── main.ts
```

**模块化设计**：

```javascript
// 按功能模块组织
src/modules/
├── user/
│   ├── components/
│   ├── composables/
│   ├── services/
│   ├── types/
│   └── views/
├── product/
│   └── ...
└── order/
    └── ...
```

**配置管理**：

```javascript
// config/index.js
export default {
  // 开发环境
  development: {
    apiBaseUrl: 'http://localhost:3000',
    debug: true
  },
  
  // 生产环境
  production: {
    apiBaseUrl: 'https://api.example.com',
    debug: false
  }
}[process.env.NODE_ENV || 'development'];
```

**插件注册**：

```javascript
// plugins/index.js
import ElementPlus from 'element-plus';
import i18n from './i18n';

export const registerPlugins = (app) => {
  app.use(ElementPlus);
  app.use(i18n);
  
  // 注册全局组件
  const components = import.meta.glob('./components/common/*.vue');
  Object.entries(components).forEach(([path, component]) => {
    const name = path.split('/').pop().replace('.vue', '');
    app.component(name, defineAsyncComponent(component));
  });
};
```

### 2. 如何实现权限控制？

**1. 路由权限控制**

```javascript
// router/guards/auth.js
export function createAuthGuard(router, store) {
  router.beforeEach((to, from, next) => {
    const isAuthenticated = store.state.user.isAuthenticated;
    const requiresAuth = to.matched.some(record => record.meta.requiresAuth);
    const requiredRoles = to.meta.roles;
    
    // 需要登录但未登录
    if (requiresAuth && !isAuthenticated) {
      next('/login');
      return;
    }
    
    // 已登录但访问登录页
    if (to.path === '/login' && isAuthenticated) {
      next('/');
      return;
    }
    
    // 检查角色权限
    if (requiredRoles) {
      const userRole = store.state.user.role;
      if (!requiredRoles.includes(userRole)) {
        next('/forbidden');
        return;
      }
    }
    
    next();
  });
}
```

**2. 动态路由**

```javascript
// 根据权限动态添加路由
export function setupDynamicRoutes(router, userPermissions) {
  const dynamicRoutes = generateRoutes(userPermissions);
  
  dynamicRoutes.forEach(route => {
    if (!router.hasRoute(route.name)) {
      router.addRoute(route);
    }
  });
  
  // 移除无权限的路由
  // ...
}

// 生成路由
function generateRoutes(permissions) {
  const routes = [];
  
  if (permissions.includes('user:view')) {
    routes.push({
      path: '/users',
      component: () => import('@/views/UserList.vue'),
      meta: { title: '用户管理' }
    });
  }
  
  if (permissions.includes('product:view')) {
    routes.push({
      path: '/products',
      component: () => import('@/views/ProductList.vue'),
      meta: { title: '产品管理' }
    });
  }
  
  return routes;
}
```

**3. 组件级权限控制**

```vue
<!-- 权限指令 -->
<script>
export default {
  install(app) {
    app.directive('permission', {
      mounted(el, binding) {
        const { value } = binding;
        const permissions = store.state.user.permissions;
        
        if (value && !permissions.includes(value)) {
          el.parentNode?.removeChild(el);
        }
      }
    });
  }
};
</script>

<!-- 使用 -->
<template>
  <button v-permission="'user:create'">创建用户</button>
  <button v-permission="'user:delete'">删除用户</button>
</template>
```

**4. 权限混入**

```javascript
// mixins/permission.js
export default {
  computed: {
    hasPermission() {
      return (permission) => {
        return this.$store.state.user.permissions.includes(permission);
      };
    }
  },
  methods: {
    checkPermission(permission) {
      if (!this.hasPermission(permission)) {
        this.$message.error('无权限访问');
        return false;
      }
      return true;
    }
  }
};
```

### 3. 如何处理错误和异常？

**1. 全局错误处理**

```javascript
// Vue 2
Vue.config.errorHandler = (err, vm, info) => {
  console.error('全局错误:', err);
  console.error('组件:', vm);
  console.error('信息:', info);
  
  // 上报错误
  reportError(err);
};

// Vue 3
app.config.errorHandler = (err, vm, info) => {
  // 错误处理
};
```

**2. 错误边界组件**

```vue
<!-- ErrorBoundary.vue -->
<template>
  <slot v-if="!hasError" />
  <div v-else class="error-boundary">
    <h3>出错了</h3>
    <p>{{ errorMessage }}</p>
    <button @click="reset">重试</button>
  </div>
</template>

<script>
export default {
  name: 'ErrorBoundary',
  data() {
    return {
      hasError: false,
      errorMessage: ''
    };
  },
  errorCaptured(err, vm, info) {
    this.hasError = true;
    this.errorMessage = err.message;
    
    // 上报错误
    this.reportError(err);
    
    // 阻止错误继续向上传播
    return false;
  },
  methods: {
    reset() {
      this.hasError = false;
      this.errorMessage = '';
      this.$emit('retry');
    },
    reportError(err) {
      // 上报到监控系统
      console.error('捕获错误:', err);
    }
  }
};
</script>

<!-- 使用 -->
<ErrorBoundary>
  <UnstableComponent />
</ErrorBoundary>
```

**3. API 错误处理**

```javascript
// services/api.js
import axios from 'axios';

const service = axios.create({
  baseURL: process.env.VUE_APP_API_BASE_URL,
  timeout: 10000
});

// 请求拦截器
service.interceptors.request.use(
  config => {
    // 添加 token
    const token = store.state.user.token;
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  error => {
    return Promise.reject(error);
  }
);

// 响应拦截器
service.interceptors.response.use(
  response => {
    return response.data;
  },
  error => {
    const { response } = error;
    
    if (response) {
      switch (response.status) {
        case 401:
          // 未授权，跳转到登录页
          router.push('/login');
          break;
        case 403:
          // 权限不足
          message.error('权限不足');
          break;
        case 500:
          // 服务器错误
          message.error('服务器错误');
          break;
        default:
          message.error(error.message);
      }
    } else {
      // 网络错误
      message.error('网络连接失败');
    }
    
    return Promise.reject(error);
  }
);
```

**4. Promise 错误处理**

```javascript
// 统一处理异步错误
export function asyncHandler(promise) {
  return promise
    .then(data => [null, data])
    .catch(err => [err, null]);
}

// 使用
const [err, data] = await asyncHandler(api.getUser());
if (err) {
  // 处理错误
}
```

### 4. 如何进行单元测试？

**测试配置**：

```javascript
// jest.config.js
module.exports = {
  preset: '@vue/cli-plugin-unit-jest',
  testEnvironment: 'jsdom',
  moduleFileExtensions: ['js', 'jsx', 'json', 'vue'],
  transform: {
    '^.+\.vue$': 'vue-jest',
    '^.+\.js$': 'babel-jest'
  },
  moduleNameMapper: {
    '^@/(.*)$': '<rootDir>/src/$1'
  },
  collectCoverage: true,
  collectCoverageFrom: [
    'src/**/*.{js,vue}',
    '!src/main.js',
    '!src/router/index.js',
    '!**/node_modules/**'
  ],
  testMatch: [
    '**/tests/unit/**/*.spec.[jt]s?(x)',
    '**/__tests__/*.[jt]s?(x)'
  ]
};
```

**组件测试示例**：

```javascript
// components/LoginForm.spec.js
import { mount } from '@vue/test-utils';
import LoginForm from './LoginForm.vue';
import { createPinia, setActivePinia } from 'pinia';

describe('LoginForm', () => {
  let wrapper;
  let store;
  
  beforeEach(() => {
    setActivePinia(createPinia());
    store = useUserStore();
    
    wrapper = mount(LoginForm, {
      global: {
        plugins: [store],
        stubs: ['RouterLink']
      }
    });
  });
  
  test('渲染登录表单', () => {
    expect(wrapper.find('form').exists()).toBe(true);
    expect(wrapper.find('input[type="email"]').exists()).toBe(true);
    expect(wrapper.find('input[type="password"]').exists()).toBe(true);
    expect(wrapper.find('button[type="submit"]').exists()).toBe(true);
  });
  
  test('提交表单时调用登录方法', async () => {
    // 模拟 store 方法
    store.login = jest.fn();
    
    // 设置表单数据
    await wrapper.find('input[type="email"]').setValue('test@example.com');
    await wrapper.find('input[type="password"]').setValue('password');
    
    // 提交表单
    await wrapper.find('form').trigger('submit.prevent');
    
    // 验证登录方法被调用
    expect(store.login).toHaveBeenCalledWith({
      email: 'test@example.com',
      password: 'password'
    });
  });
  
  test('显示验证错误', async () => {
    // 设置空值
    await wrapper.find('input[type="email"]').setValue('');
    await wrapper.find('form').trigger('submit.prevent');
    
    // 验证错误信息显示
    expect(wrapper.text()).toContain('邮箱是必填项');
  });
  
  test('登录成功后的重定向', async () => {
    // 模拟登录成功
    store.login.mockResolvedValue({ success: true });
    
    // 提交表单
    await wrapper.find('input[type="email"]').setValue('test@example.com');
    await wrapper.find('input[type="password"]').setValue('password');
    await wrapper.find('form').trigger('submit.prevent');
    
    // 等待异步操作完成
    await wrapper.vm.$nextTick();
    
    // 验证重定向
    expect(wrapper.vm.$route.path).toBe('/dashboard');
  });
});
```

**组合式函数测试**：

```javascript
// composables/useCounter.spec.js
import { renderHook, act } from '@testing-library/vue-hooks';
import { useCounter } from './useCounter';

describe('useCounter', () => {
  test('使用初始值', () => {
    const { result } = renderHook(() => useCounter(10));
    
    expect(result.current.count.value).toBe(10);
    expect(result.current.double.value).toBe(20);
  });
  
  test('增加计数', () => {
    const { result } = renderHook(() => useCounter());
    
    act(() => {
      result.current.increment();
    });
    
    expect(result.current.count.value).toBe(1);
    expect(result.current.double.value).toBe(2);
  });
  
  test('重置计数', () => {
    const { result } = renderHook(() => useCounter(5));
    
    act(() => {
      result.current.increment();
      result.current.reset();
    });
    
    expect(result.current.count.value).toBe(5);
  });
});
```

**测试工具**：

*   **Jest**：测试框架
    
*   **Vue Test Utils**：Vue 组件测试工具
    
*   **Testing Library**：用户行为测试
    
*   **Cypress**：端到端测试
    
*   **Vitest**：Vite 原生测试框架
    

### 5. TypeScript 与 Vue 的结合？

**Vue 3 + TypeScript 配置**：

```json
// tsconfig.json
{
  "compilerOptions": {
    "target": "esnext",
    "module": "esnext",
    "strict": true,
    "jsx": "preserve",
    "moduleResolution": "node",
    "skipLibCheck": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "forceConsistentCasingInFileNames": true,
    "useDefineForClassFields": true,
    "sourceMap": true,
    "baseUrl": ".",
    "types": ["vite/client"],
    "paths": {
      "@/*": ["src/*"]
    },
    "lib": ["esnext", "dom", "dom.iterable", "scripthost"]
  },
  "include": [
    "src/**/*.ts",
    "src/**/*.d.ts",
    "src/**/*.tsx",
    "src/**/*.vue"
  ],
  "exclude": ["node_modules"]
}
```

**组件类型定义**：

```vue
<!-- 选项式 API -->
<script lang="ts">
import { defineComponent } from 'vue';

interface User {
  id: number;
  name: string;
  email: string;
}

export default defineComponent({
  name: 'UserProfile',
  
  props: {
    userId: {
      type: Number,
      required: true
    },
    showEmail: {
      type: Boolean,
      default: false
    }
  },
  
  data() {
    return {
      user: null as User | null
    };
  },
  
  computed: {
    userName(): string {
      return this.user?.name || 'Unknown';
    }
  },
  
  methods: {
    async fetchUser(): Promise<void> {
      try {
        this.user = await this.$api.getUser(this.userId);
      } catch (error) {
        console.error('获取用户失败:', error);
      }
    }
  },
  
  mounted() {
    this.fetchUser();
  }
});
</script>
```

**组合式 API + TypeScript**：

```vue
<script setup lang="ts">
import { ref, computed } from 'vue';

// 定义 Props 类型
interface Props {
  userId: number;
  showEmail?: boolean;
}

// 定义 Emits 类型
interface Emits {
  (e: 'update:userId', id: number): void;
  (e: 'success'): void;
}

// 定义响应式数据
const props = withDefaults(defineProps<Props>(), {
  showEmail: false
});

const emit = defineEmits<Emits>();

// 定义响应式数据
interface User {
  id: number;
  name: string;
  email: string;
}

const user = ref<User | null>(null);
const loading = ref(false);

// 计算属性
const userName = computed(() => user.value?.name || 'Unknown');

// 方法
async function fetchUser(): Promise<void> {
  loading.value = true;
  try {
    const response = await api.getUser(props.userId);
    user.value = response.data;
    emit('success');
  } catch (error) {
    console.error('获取用户失败:', error);
  } finally {
    loading.value = false;
  }
}

// 暴露给模板
defineExpose({
  fetchUser
});
</script>
```

**Pinia + TypeScript**：

```typescript
// stores/user.ts
import { defineStore } from 'pinia';

interface User {
  id: number;
  name: string;
  email: string;
  role: 'admin' | 'user';
}

interface UserState {
  currentUser: User | null;
  users: User[];
}

export const useUserStore = defineStore('user', {
  state: (): UserState => ({
    currentUser: null,
    users: []
  }),
  
  getters: {
    isAuthenticated: (state) => !!state.currentUser,
    isAdmin: (state) => state.currentUser?.role === 'admin',
    getUserById: (state) => {
      return (userId: number) => state.users.find(user => user.id === userId);
    }
  },
  
  actions: {
    async login(credentials: { email: string; password: string }): Promise<void> {
      const response = await api.login(credentials);
      this.currentUser = response.data.user;
    },
    
    async fetchUsers(): Promise<void> {
      const response = await api.getUsers();
      this.users = response.data;
    },
    
    async updateUser(userId: number, updates: Partial<User>): Promise<void> {
      await api.updateUser(userId, updates);
      
      const index = this.users.findIndex(u => u.id === userId);
      if (index !== -1) {
        this.users[index] = { ...this.users[index], ...updates };
      }
      
      if (this.currentUser?.id === userId) {
        this.currentUser = { ...this.currentUser, ...updates };
      }
    }
  }
});
```

**全局类型定义**：

```typescript
// types/global.d.ts
declare module '*.vue' {
  import { DefineComponent } from 'vue';
  const component: DefineComponent<{}, {}, any>;
  export default component;
}

// 扩展 Vue 全局属性
declare module '@vue/runtime-core' {
  interface ComponentCustomProperties {
    $api: typeof import('./services/api').default;
    $formatDate: (date: Date | string) => string;
  }
}

// 环境变量类型
interface ImportMetaEnv {
  VITE_API_BASE_URL: string;
  VITE_APP_TITLE: string;
}

interface ImportMeta {
  readonly env: ImportMetaEnv;
}
```

**TypeScript 最佳实践**：

1.  **严格模式**：开启所有严格类型检查
    
2.  **明确的类型**：避免使用 `any`
    
3.  **接口优先**：使用 interface 定义对象类型
    
4.  **泛型使用**：在可复用的组件和函数中使用泛型
    
5.  **工具类型**：使用 TypeScript 内置工具类型（`Partial`, `Pick`, `Omit`等）


