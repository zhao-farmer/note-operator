# 三、typeScript


## 3.1 基础类型

### 1. TypeScript 与 JavaScript 的主要区别？

**回答：**

*   **类型系统**：TS 是静态类型，JS 是动态类型
    
*   **编译检查**：TS 在编译时检查类型错误
    
*   **工具支持**：更好的 IDE 智能提示和重构支持
    
*   **新特性支持**：支持 ES6+ 特性，可编译到旧版本 JS
    
```typescript
// JavaScript（动态类型）
let jsVar = "hello";
jsVar = 123; // 运行时才能发现潜在问题

// TypeScript（静态类型）
let tsVar: string = "hello";
// tsVar = 123; // 编译时报错：不能将 number 分配给 string

// TS 提供更好的代码提示
interface User {
  name: string;
  age: number;
}

function greet(user: User) {
  console.log(`Hello, ${user.name}`); // IDE 会提示 name 属性
  // console.log(user.nam); // 编译时报错：属性 'nam' 不存在
}

// TS 支持现代 ES 特性，可编译到指定版本
const arr = [1, 2, 3];
const doubled = arr.map(x => x * 2); // ES6 箭头函数
// 可编译为 ES5 语法
```

### 2. TypeScript 有哪些基本类型？

**回答：** TS 包含 JS 的基本类型和 TS 特有的类型。
```typescript
// 1. JavaScript 基本类型
let isDone: boolean = false;
let count: number = 42;
let name: string = "TypeScript";
let list: number[] = [1, 2, 3];
let tuple: [string, number] = ["hello", 10];

// 2. TypeScript 特有类型
// any - 任意类型（谨慎使用）
let anyValue: any = "can be anything";
anyValue = 42;
anyValue = true;

// unknown - 类型安全的 any
let unknownValue: unknown = "unknown";
// unknownValue.toUpperCase(); // 错误：需要类型断言
(unknownValue as string).toUpperCase();

// void - 无返回值
function warn(): void {
  console.log("This is a warning");
}

// never - 永不返回
function error(message: string): never {
  throw new Error(message);
}

// 3. 枚举类型
enum Color {
  Red,
  Green,
  Blue
}
let c: Color = Color.Green;

// 4. 字面量类型
let direction: "north" | "south" | "east" | "west";
direction = "north"; // 只能取这四个值之一

// 5. 对象类型
let obj: object = { x: 1, y: 2 };
let point: { x: number; y: number } = { x: 10, y: 20 };
```

### 3. any、unknown、never、void 的区别？

**回答：**

*   **any**: 任意类型，跳过类型检查
    
*   **unknown**: 类型安全的 any，使用前需要类型检查或断言
    
*   **never**: 永不存在的值，用于永不返回的函数或抛出异常
    
*   **void**: 无返回值，用于函数无返回值的情况
    
```typescript
// 1. any - 跳过所有类型检查
let anyValue: any = "hello";
anyValue.toFixed(); // 运行时可能出错，但编译时不会报错
anyValue(); // 可以当作函数调用
anyValue.someProperty; // 可以访问任何属性

// 2. unknown - 类型安全的 any
let unknownValue: unknown = "world";
// unknownValue.toUpperCase(); // 错误：需要类型检查
if (typeof unknownValue === "string") {
  console.log(unknownValue.toUpperCase()); // 正确
}
// 或使用类型断言
console.log((unknownValue as string).toUpperCase());

// 3. void - 无返回值
function logMessage(): void {
  console.log("message logged");
  // 可以没有 return 语句
  // 或 return; 但不能 return 其他值
}

// 4. never - 永不存在的值
function throwError(message: string): never {
  throw new Error(message);
  // 函数永远不会返回
}

function infiniteLoop(): never {
  while (true) {
    // 无限循环
  }
}

// 用于处理不可能的情况
type Shape = "circle" | "square";

function getArea(shape: Shape): number {
  switch (shape) {
    case "circle":
      return Math.PI * 10 * 10;
    case "square":
      return 10 * 10;
    default:
      // shape 类型被穷尽检查，这里 shape 是 never
      const exhaustiveCheck: never = shape;
      return exhaustiveCheck;
  }
}

// 5. 对比示例
function processValue(value: any) {
  value.method(); // 不会报错（危险）
}

function processValue2(value: unknown) {
  // value.method(); // 报错：需要类型检查
  if (typeof value === "object" && value !== null && "method" in value) {
    (value as any).method(); // 安全地调用
  }
}
```

### 4. 类型断言有哪几种写法？

**回答：** 两种写法：`as` 语法和 `<Type>` 语法。
```typescript
// 1. as 语法（推荐）
let someValue: unknown = "this is a string";
let strLength: number = (someValue as string).length;

// 2. 尖括号语法（在 JSX 中可能与标签冲突）
let anotherValue: any = "another string";
let anotherLength: number = (<string>anotherValue).length;

// 3. 非空断言
interface User {
  name?: string;
}

function printUserName(user: User) {
  console.log(user.name!.toUpperCase()); // 告诉 TS name 一定存在
  // 等价于 console.log((user.name as string).toUpperCase());
}

// 4. 双重断言（谨慎使用）
let value: unknown = "hello";
// let str: string = value as string; // 正确
// let num: number = value as number; // 错误：unknown 不能直接断言为 number

// 双重断言：先断言为 any，再断言为目标类型
let num: number = (value as any) as number;

// 5. const 断言
let x = "hello" as const; // x 的类型是 "hello" 而不是 string
let y = [10, 20] as const; // y 的类型是 readonly [10, 20]

// 6. 类型断言的实际应用
// DOM 元素类型断言
const input = document.getElementById("myInput") as HTMLInputElement;
input.value = "Hello";

// 更安全的写法
const input2 = document.getElementById("myInput");
if (input2 instanceof HTMLInputElement) {
  input2.value = "World";
}

// 7. 类型断言与类型转换的区别
function isString(value: unknown): value is string {
  return typeof value === "string";
}

function process(value: unknown) {
  if (isString(value)) {
    // 这里 value 自动被推断为 string
    console.log(value.toUpperCase());
  }
}
```

### 5. 什么是类型推断？

**回答：** TypeScript 根据上下文自动推断变量或表达式的类型，无需显式声明。
```typescript
// 1. 变量类型推断
let x = 3; // TypeScript 推断 x 为 number
// x = "hello"; // 错误：不能将 string 分配给 number

let y; // 推断为 any
y = 3;
y = "hello"; // 可以，因为 y 是 any

// 2. 函数返回值类型推断
function add(a: number, b: number) {
  return a + b; // 推断返回值为 number
}

const result = add(1, 2); // result 被推断为 number

// 3. 上下文类型推断（根据使用位置推断）
window.onmousedown = function(mouseEvent) {
  console.log(mouseEvent.button); // 正确：mouseEvent 被推断为 MouseEvent
  // console.log(mouseEvent.kangaroo); // 错误：MouseEvent 没有 kangaroo 属性
};

// 4. 最佳公共类型推断
let arr = [0, 1, null]; // 推断为 (number | null)[]

class Animal {}
class Dog extends Animal {}
class Cat extends Animal {}

let pets = [new Dog(), new Cat()]; // 推断为 (Dog | Cat)[]

// 5. 根据赋值推断
let foo; // 推断为 any
foo = 123; // foo 仍然是 any
foo = "hello"; // 可以

// 与以下不同
let bar: number; // 明确声明为 number
bar = 123;
// bar = "hello"; // 错误

// 6. 对象字面量推断
const person = {
  name: "Alice",
  age: 30
}; // 推断为 { name: string; age: number; }

// person.location = "NY"; // 错误：location 不存在

// 7. 函数参数推断
type Callback = (error: Error, data: string) => void;

function fetchData(callback: Callback) {
  // ...
}

fetchData((err, data) => {
  // err 被推断为 Error，data 被推断为 string
  console.log(data.toUpperCase());
});

// 8. const 断言的类型推断
const j = { x: 3 }; // 推断为 { x: number }
const k = { x: 3 } as const; // 推断为 { readonly x: 3 }

// 9. 控制流分析（类型收窄）
function example(value: string | number) {
  if (typeof value === "string") {
    // 这里 value 被推断为 string
    return value.toUpperCase();
  } else {
    // 这里 value 被推断为 number
    return value.toFixed(2);
  }
}
```

## 3.2 接口与类型别名

### 1. interface 和 type 的区别？

**回答：**

*   **interface**: 主要用于定义对象结构，可扩展（继承），可合并
    
*   **type**: 可定义任何类型，包括联合、交叉、元组等，不能重复声明
    
```typescript
// 1. interface - 定义对象结构
interface Point {
  x: number;
  y: number;
}

// 可扩展
interface Point3D extends Point {
  z: number;
}

// 可重复声明（声明合并）
interface User {
  name: string;
}

interface User {
  age: number;
}

// 合并后相当于
// interface User {
//   name: string;
//   age: number;
// }

// 2. type - 可定义任何类型
type PointType = {
  x: number;
  y: number;
};

// 联合类型
type ID = string | number;

// 元组类型
type Data = [string, number];

// 交叉类型
type Named = { name: string };
type Aged = { age: number };
type Person = Named & Aged;

// 3. interface 和 type 的相互扩展
interface Animal {
  name: string;
}

type Dog = Animal & {
  breed: string;
};

interface Cat extends Animal {
  color: string;
}

// 4. 主要区别
// interface 可以重复声明（声明合并）
interface Config {
  host: string;
}

interface Config {
  port: number;
}
// 最终 Config 包含 host 和 port

// type 不能重复声明
// type ConfigType = { host: string }; // 错误：重复声明
// type ConfigType = { port: number };

// 5. 实际选择建议
// 定义对象结构时优先使用 interface（可扩展性更好）
// 需要联合、交叉、元组等类型时使用 type

// 6. 类实现
interface Serializable {
  serialize(): string;
}

class MyClass implements Serializable {
  serialize() {
    return JSON.stringify(this);
  }
}

// type 也可以被类实现
type Deserializable = {
  deserialize(data: string): void;
};

class AnotherClass implements Deserializable {
  deserialize(data: string) {
    // ...
  }
}
```

### 2. 如何定义可选属性和只读属性？

**回答：** 使用 `?` 定义可选属性，使用 `readonly` 定义只读属性。
```typescript
// 1. 可选属性
interface User {
  name: string;
  age?: number; // 可选属性
  email?: string;
}

const user1: User = { name: "Alice" }; // 可以，age 和 email 可选
const user2: User = { name: "Bob", age: 30 }; // 可以
// const user3: User = { name: "Charlie", phone: "123" }; // 错误：phone 不存在

// 2. 只读属性
interface Point {
  readonly x: number;
  readonly y: number;
}

const point: Point = { x: 10, y: 20 };
// point.x = 5; // 错误：只读属性不能修改

// 3. 只读数组
const numbers: readonly number[] = [1, 2, 3];
// numbers.push(4); // 错误：push 不存在于只读数组
// numbers[0] = 10; // 错误：索引签名只读

// 4. 结合使用
interface Config {
  readonly id: number;
  name: string;
  timeout?: number;
  readonly tags: readonly string[];
}

const config: Config = {
  id: 1,
  name: "app",
  tags: ["typescript", "javascript"]
};

// config.id = 2; // 错误：只读
// config.tags.push("nodejs"); // 错误：只读数组
config.name = "new app"; // 可以

// 5. 类型别名中的可选和只读
type Person = {
  readonly id: string;
  name: string;
  age?: number;
};

// 6. 使用泛型定义只读
function freeze<T>(obj: T): Readonly<T> {
  return Object.freeze(obj);
}

const frozen = freeze({ x: 10, y: 20 });
// frozen.x = 5; // 错误：只读

// 7. 可选属性在实际应用中的使用
interface ApiResponse<T> {
  success: boolean;
  data?: T; // 成功时有数据
  error?: string; // 失败时有错误信息
}

function handleResponse(response: ApiResponse<string>) {
  if (response.success) {
    console.log(response.data!.toUpperCase()); // 使用非空断言
  } else {
    console.error(response.error);
  }
}

// 8. 只读属性在不可变数据中的应用
interface ImmutableUser {
  readonly id: string;
  readonly name: string;
  readonly roles: readonly string[];
}

function createUser(id: string, name: string): ImmutableUser {
  return { id, name, roles: ["user"] };
}

const admin: ImmutableUser = {
  id: "1",
  name: "Admin",
  roles: ["admin", "user"] as const
};
```

### 3. 索引签名的作用？

**回答：** 定义对象中可以包含任意数量的属性，但属性的键和值需要符合指定的类型。
```typescript
// 1. 基本索引签名
interface StringDictionary {
  [key: string]: string;
}

const dict: StringDictionary = {
  name: "John",
  city: "New York"
  // age: 30 // 错误：值必须是 string
};

dict["country"] = "USA"; // 可以动态添加

// 2. 数字索引签名（用于类数组对象）
interface NumberArray {
  [index: number]: number;
}

const arr: NumberArray = [1, 2, 3];
console.log(arr[0]); // 1

// 3. 混合索引签名（需要满足 string 签名的类型是 number 签名的超类型）
interface MixedDictionary {
  [key: string]: string | number;
  [index: number]: string; // 必须是 string | number 的子类型
  name: string; // 必须符合 [key: string]: string | number
}

// 4. 只读索引签名
interface ReadonlyDictionary {
  readonly [key: string]: string;
}

const readonlyDict: ReadonlyDictionary = {
  key1: "value1"
};
// readonlyDict["key2"] = "value2"; // 错误：只读

// 5. 实际应用：处理动态属性
interface Cache {
  [key: string]: any;
}

const cache: Cache = {};
cache["user:1"] = { name: "Alice", age: 30 };
cache["product:42"] = { title: "Laptop", price: 999 };

// 6. 与已知属性结合
interface User {
  name: string;
  age: number;
  [key: string]: string | number; // 允许其他属性
}

const user: User = {
  name: "Bob",
  age: 25,
  city: "NY", // 可以
  score: 100 // 可以
  // isAdmin: true // 错误：必须是 string | number
};

// 7. 使用 Record 类型（替代索引签名）
type StringRecord = Record<string, string>;
type NumberRecord = Record<number, string>;

// 8. 索引签名在配置对象中的应用
interface AppConfig {
  api: {
    baseUrl: string;
    timeout: number;
  };
  features: {
    [featureName: string]: boolean;
  };
}

const config: AppConfig = {
  api: {
    baseUrl: "https://api.example.com",
    timeout: 5000
  },
  features: {
    darkMode: true,
    analytics: false,
    newUI: true
  }
};

// 9. 类型安全的动态属性访问
function getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {
  return obj[key];
}

const value = getProperty(user, "name"); // 类型安全
// const value2 = getProperty(user, "invalid"); // 错误
```

### 4. 如何实现接口的继承？

**回答：** 使用 `extends` 关键字，接口可以继承单个或多个接口。
```typescript
// 1. 单接口继承
interface Shape {
  color: string;
}

interface Circle extends Shape {
  radius: number;
}

const circle: Circle = {
  color: "red",
  radius: 10
};

// 2. 多接口继承
interface Printable {
  print(): void;
}

interface Circle extends Shape, Printable {
  radius: number;
}

const printableCircle: Circle = {
  color: "blue",
  radius: 5,
  print() {
    console.log(`Circle with radius ${this.radius}`);
  }
};

// 3. 继承类型别名
type Point = {
  x: number;
  y: number;
};

interface CircleWithCenter extends Point {
  radius: number;
}

// 4. 覆盖继承的属性
interface Base {
  id: number;
  name: string;
}

interface Derived extends Base {
  id: string; // 错误：id 类型不兼容
  // 可以覆盖，但类型必须兼容
}

// 5. 实际应用：组件 Props 继承
interface BaseProps {
  className?: string;
  style?: React.CSSProperties;
}

interface ButtonProps extends BaseProps {
  onClick: () => void;
  disabled?: boolean;
  children: React.ReactNode;
}

// 6. 多层继承
interface Animal {
  name: string;
}

interface Mammal extends Animal {
  hasFur: boolean;
}

interface Dog extends Mammal {
  breed: string;
  bark(): void;
}

const myDog: Dog = {
  name: "Buddy",
  hasFur: true,
  breed: "Golden Retriever",
  bark() {
    console.log("Woof!");
  }
};

// 7. 继承与实现结合
interface Logger {
  log(message: string): void;
}

class ConsoleLogger implements Logger {
  log(message: string) {
    console.log(message);
  }
}

interface TimestampLogger extends Logger {
  logWithTimestamp(message: string): void;
}

class AdvancedLogger extends ConsoleLogger implements TimestampLogger {
  logWithTimestamp(message: string) {
    console.log(`[${new Date().toISOString()}] ${message}`);
  }
}

// 8. 使用交叉类型实现类似继承的效果
type Person = {
  name: string;
  age: number;
};

type Employee = Person & {
  employeeId: string;
  department: string;
};

// 9. 接口继承 vs 类继承
interface BaseInterface {
  method(): void;
}

interface DerivedInterface extends BaseInterface {
  anotherMethod(): void;
}

class BaseClass {
  method() {}
}

class DerivedClass extends BaseClass {
  anotherMethod() {}
}
```

### 5. 声明合并是什么？

**回答：** TypeScript 中同名的接口、命名空间、函数等可以自动合并。
```typescript
// 1. 接口合并
interface Box {
  height: number;
  width: number;
}

interface Box {
  scale: number;
}

// 合并后相当于：
// interface Box {
//   height: number;
//   width: number;
//   scale: number;
// }

const box: Box = {
  height: 5,
  width: 6,
  scale: 10
};

// 2. 命名空间合并
namespace Validation {
  export interface StringValidator {
    isAcceptable(s: string): boolean;
  }
}

namespace Validation {
  export class LettersOnlyValidator implements StringValidator {
    isAcceptable(s: string) {
      return /^[A-Za-z]+$/.test(s);
    }
  }
}

// 3. 函数合并（函数重载）
function reverse(x: number): number;
function reverse(x: string): string;
function reverse(x: number | string): number | string {
  if (typeof x === "number") {
    return Number(x.toString().split("").reverse().join(""));
  } else {
    return x.split("").reverse().join("");
  }
}

// 4. 枚举合并
enum Direction {
  Up = 1,
  Down = 2
}

enum Direction {
  Left = 3,
  Right = 4
}

// 合并后相当于：
// enum Direction {
//   Up = 1,
//   Down = 2,
//   Left = 3,
//   Right = 4
// }

// 5. 类与接口合并（为类添加类型）
class Person {
  name: string = "";
}

interface Person {
  age: number;
  greet(): void;
}

// 需要实现接口中新增的方法
const person = new Person();
// person.greet(); // 运行时错误，需要在实际代码中实现

// 通过原型添加实现
Person.prototype.greet = function() {
  console.log(`Hello, I'm ${this.name}`);
};

// 6. 模块扩展（为第三方库添加类型）
// 假设我们扩展 Express 的 Request 接口
declare global {
  namespace Express {
    interface Request {
      user?: {
        id: string;
        name: string;
      };
    }
  }
}

// 7. 合并规则
// 非函数成员：同名属性必须类型相同，否则错误
interface Document {
  title: string;
}

// interface Document {
//   title: number; // 错误：类型冲突
// }

// 函数成员：每个同名函数声明都会被当作重载
interface Cloner {
  clone(animal: Animal): Animal;
}

interface Cloner {
  clone(animal: Sheep): Sheep;
}

// 合并后相当于：
// interface Cloner {
//   clone(animal: Animal): Animal;
//   clone(animal: Sheep): Sheep;
// }

// 8. 实际应用：扩展全局对象
interface Window {
  myApp: {
    version: string;
    init(): void;
  };
}

// 使用时
window.myApp = {
  version: "1.0.0",
  init() {
    console.log("App initialized");
  }
};

// 9. 避免声明合并的冲突
// 使用类型别名可以避免意外合并
type BoxType = {
  height: number;
  width: number;
};

// type BoxType = { // 错误：重复标识符
//   scale: number;
// };
```

## 3.3 泛型

### 1. 泛型的作用是什么？

**回答：** 创建可重用的组件，使组件可以支持多种类型而不丢失类型信息。
```typescript
// 1. 泛型函数 - 避免 any 类型
function identity<T>(arg: T): T {
  return arg;
}

// 使用类型参数推断
let output1 = identity("myString"); // output1 类型为 string
let output2 = identity(42); // output2 类型为 number

// 显式指定类型参数
let output3 = identity<number>(42);

// 2. 泛型接口
interface GenericIdentityFn<T> {
  (arg: T): T;
}

let myIdentity: GenericIdentityFn<number> = identity;

// 3. 泛型类
class GenericNumber<T> {
  zeroValue: T;
  add: (x: T, y: T) => T;
  
  constructor(zeroValue: T, add: (x: T, y: T) => T) {
    this.zeroValue = zeroValue;
    this.add = add;
  }
}

let myGenericNumber = new GenericNumber<number>(0, (x, y) => x + y);
let stringNumeric = new GenericNumber<string>("", (x, y) => x + y);

// 4. 泛型约束
interface Lengthwise {
  length: number;
}

function loggingIdentity<T extends Lengthwise>(arg: T): T {
  console.log(arg.length); // 现在知道 arg 有 length 属性
  return arg;
}

loggingIdentity([1, 2, 3]); // 可以
loggingIdentity("hello"); // 可以
// loggingIdentity(3); // 错误：number 没有 length 属性

// 5. 实际应用：API 响应包装
interface ApiResponse<T> {
  success: boolean;
  data: T;
  message?: string;
}

function createResponse<T>(data: T, message?: string): ApiResponse<T> {
  return {
    success: true,
    data,
    message
  };
}

const userResponse = createResponse({ id: 1, name: "Alice" });
const productResponse = createResponse({ id: 42, title: "Laptop" });

// 6. 实际应用：缓存系统
class Cache<T> {
  private data: Map<string, T> = new Map();
  
  set(key: string, value: T): void {
    this.data.set(key, value);
  }
  
  get(key: string): T | undefined {
    return this.data.get(key);
  }
  
  clear(): void {
    this.data.clear();
  }
}

const stringCache = new Cache<string>();
stringCache.set("user:1", "Alice");

const objectCache = new Cache<{ id: number; name: string }>();
objectCache.set("config", { id: 1, name: "app" });

// 7. 多个类型参数
function swap<T, U>(tuple: [T, U]): [U, T] {
  return [tuple[1], tuple[0]];
}

const swapped = swap([1, "hello"]); // 类型为 [string, number]

// 8. 泛型默认类型
interface PaginationParams<T = string> {
  page: number;
  limit: number;
  sortBy?: T;
}

const params1: PaginationParams = { page: 1, limit: 10 }; // sortBy 为 string
const params2: PaginationParams<number> = { page: 1, limit: 10, sortBy: 2 };
```

### 2. 泛型约束如何使用？

**回答：** 使用 `extends` 关键字限制泛型参数的类型范围。
```typescript
// 1. 基本约束
interface HasLength {
  length: number;
}

function logLength<T extends HasLength>(arg: T): void {
  console.log(arg.length);
}

logLength("hello"); // 5
logLength([1, 2, 3]); // 3
// logLength(42); // 错误：number 没有 length 属性

// 2. 约束为特定类型
function getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {
  return obj[key];
}

const person = { name: "Alice", age: 30 };
getProperty(person, "name"); // "Alice"
// getProperty(person, "gender"); // 错误："gender" 不存在

// 3. 约束为构造函数
class Animal {
  name: string;
  constructor(name: string) {
    this.name = name;
  }
}

function createInstance<T extends Animal>(AnimalClass: new (name: string) => T, name: string): T {
  return new AnimalClass(name);
}

const animal = createInstance(Animal, "Buddy");

// 4. 多个约束
interface Printable {
  print(): void;
}

interface Loggable {
  log(): void;
}

function process<T extends Printable & Loggable>(item: T): void {
  item.print();
  item.log();
}

class Document implements Printable, Loggable {
  print() {
    console.log("Printing...");
  }
  
  log() {
    console.log("Logging...");
  }
}

process(new Document());

// 5. 约束类型参数本身
function copyFields<T extends U, U>(target: T, source: U): T {
  for (let id in source) {
    target[id] = (source as any)[id];
  }
  return target;
}

let x = { a: 1, b: 2, c: 3, d: 4 };
copyFields(x, { b: 10, d: 20 });

// 6. 实际应用：数据库查询
interface Entity {
  id: number;
}

function findById<T extends Entity>(items: T[], id: number): T | undefined {
  return items.find(item => item.id === id);
}

const users = [
  { id: 1, name: "Alice" },
  { id: 2, name: "Bob" }
];

const user = findById(users, 1); // 类型推断正确

// 7. 约束为特定形状
interface Shape {
  area(): number;
}

function calculateTotalArea<T extends Shape>(shapes: T[]): number {
  return shapes.reduce((total, shape) => total + shape.area(), 0);
}

class Circle implements Shape {
  constructor(public radius: number) {}
  
  area() {
    return Math.PI * this.radius * this.radius;
  }
}

class Square implements Shape {
  constructor(public side: number) {}
  
  area() {
    return this.side * this.side;
  }
}

const shapes: Shape[] = [new Circle(5), new Square(10)];
calculateTotalArea(shapes);

// 8. 使用条件类型的约束
type ExtractStringKeys<T> = {
  [K in keyof T]: T[K] extends string ? K : never;
}[keyof T];

function getStringValues<T>(obj: T, keys: ExtractStringKeys<T>[]): string[] {
  return keys.map(key => obj[key] as string);
}

const data = { name: "John", age: 30, city: "NY" };
getStringValues(data, ["name", "city"]); // ["John", "NY"]
```

### 3. 什么是泛型默认类型？

**回答：** 为泛型参数提供默认类型，类似于函数参数的默认值。
```typescript
// 1. 泛型函数默认类型
function createArray<T = string>(length: number, value: T): T[] {
  return Array(length).fill(value);
}

const strArray = createArray(3, "hello"); // string[]
const numArray = createArray<number>(3, 42); // number[]

// 2. 泛型接口默认类型
interface PaginatedResponse<T = any> {
  data: T[];
  total: number;
  page: number;
  limit: number;
}

// 使用默认类型
const response1: PaginatedResponse = {
  data: [{ id: 1 }],
  total: 1,
  page: 1,
  limit: 10
};

// 指定类型
const response2: PaginatedResponse<{ id: number; name: string }> = {
  data: [{ id: 1, name: "Alice" }],
  total: 1,
  page: 1,
  limit: 10
};

// 3. 泛型类默认类型
class Container<T = string> {
  constructor(private value: T) {}
  
  getValue(): T {
    return this.value;
  }
}

const stringContainer = new Container("hello"); // Container<string>
const numberContainer = new Container<number>(42); // Container<number>
const defaultContainer = new Container({ id: 1 }); // Container<any>

// 4. 类型别名默认类型
type Callback<T = void> = (error: Error | null, result?: T) => void;

const callback1: Callback = (error) => {}; // Callback<void>
const callback2: Callback<string> = (error, result) => {}; // Callback<string>

// 5. 多个泛型参数的默认类型
interface Pair<T = string, U = number> {
  first: T;
  second: U;
}

const pair1: Pair = { first: "hello", second: 42 }; // Pair<string, number>
const pair2: Pair<number> = { first: 1, second: 2 }; // Pair<number, number>
const pair3: Pair<boolean, string> = { first: true, second: "yes" };

// 6. 带约束的默认类型
interface EntityWithId<T = string> {
  id: T;
  name: string;
}

const entity1: EntityWithId = { id: "abc", name: "Test" }; // id 为 string
const entity2: EntityWithId<number> = { id: 123, name: "Test" }; // id 为 number

// 7. 实际应用：配置对象
interface AppConfig<T = Record<string, any>> {
  env: "development" | "production";
  api: {
    baseUrl: string;
    timeout: number;
  };
  features: T;
}

// 默认配置
const config1: AppConfig = {
  env: "development",
  api: { baseUrl: "http://localhost", timeout: 5000 },
  features: {} // 类型为 Record<string, any>
};

// 类型安全的配置
const config2: AppConfig<{
  darkMode: boolean;
  analytics: boolean;
}> = {
  env: "production",
  api: { baseUrl: "https://api.example.com", timeout: 10000 },
  features: {
    darkMode: true,
    analytics: false
    // newFeature: true // 错误：未在类型中定义
  }
};

// 8. 函数重载中的默认类型
function parseJSON<T = any>(text: string): T;
function parseJSON<T = any>(text: string, reviver?: (key: string, value: any) => any): T;
function parseJSON(text: string, reviver?: any): any {
  return JSON.parse(text, reviver);
}

const data1 = parseJSON('{"id": 1}'); // any
const data2 = parseJSON<{ id: number }>('{"id": 1}'); // { id: number }
```

### 4. 条件类型是什么？

**回答：** 根据条件决定类型的类型，语法为 `T extends U ? X : Y`。
```typescript
// 1. 基本条件类型
type IsString<T> = T extends string ? true : false;

type A = IsString<string>; // true
type B = IsString<number>; // false

// 2. 类型提取
type ExtractString<T> = T extends string ? T : never;

type C = ExtractString<string | number | boolean>; // string

// 3. 排除类型
type ExcludeString<T> = T extends string ? never : T;

type D = ExcludeString<string | number | boolean>; // number | boolean

// 4. 内置条件类型：Exclude、Extract
type T0 = Exclude<"a" | "b" | "c", "a">; // "b" | "c"
type T1 = Extract<"a" | "b" | "c", "a" | "f">; // "a"

// 5. 内置条件类型：NonNullable
type T2 = NonNullable<string | number | null | undefined>; // string | number

// 6. 条件类型中的 infer 关键字
type ReturnType<T> = T extends (...args: any[]) => infer R ? R : any;

function getUser() {
  return { id: 1, name: "Alice" };
}

type User = ReturnType<typeof getUser>; // { id: number; name: string }

// 7. 提取数组元素类型
type ArrayElement<T> = T extends (infer U)[] ? U : never;

type Element = ArrayElement<string[]>; // string
type Element2 = ArrayElement<[string, number]>; // string | number

// 8. 提取 Promise 类型
type UnwrapPromise<T> = T extends Promise<infer U> ? U : T;

type PromiseResult = UnwrapPromise<Promise<string>>; // string
type NonPromise = UnwrapPromise<string>; // string

// 9. 递归条件类型
type DeepReadonly<T> = {
  readonly [P in keyof T]: T[P] extends object ? DeepReadonly<T[P]> : T[P];
};

interface Company {
  name: string;
  address: {
    street: string;
    city: string;
  };
}

type ReadonlyCompany = DeepReadonly<Company>;
// 等价于：
// {
//   readonly name: string;
//   readonly address: {
//     readonly street: string;
//     readonly city: string;
//   };
// }

// 10. 分布式条件类型
type ToArray<T> = T extends any ? T[] : never;

type StrArrOrNumArr = ToArray<string | number>; // string[] | number[]

// 注意：下面的写法不同
type ToArray2<T> = T[]; // (string | number)[]

// 11. 实际应用：根据输入类型决定输出类型
type Override<T, U> = {
  [P in keyof T]: P extends keyof U ? U[P] : T[P];
};

interface Base {
  id: number;
  name: string;
  createdAt: Date;
}

interface Update {
  name?: string;
  updatedAt: Date;
}

type Updated = Override<Base, Update>;
// 等价于：
// {
//   id: number;
//   name?: string; // 可选，来自 Update
//   createdAt: Date;
//   updatedAt: Date; // 新增
// }
```

### 5. keyof 和 typeof 操作符的作用？

**回答：**

*   **keyof**: 获取对象类型的所有键的联合类型
    
*   **typeof**: 获取变量或属性的类型
    
```typescript
// 1. keyof 操作符
interface Person {
  name: string;
  age: number;
  city: string;
}

type PersonKeys = keyof Person; // "name" | "age" | "city"

function getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {
  return obj[key];
}

const person: Person = { name: "Alice", age: 30, city: "NY" };
getProperty(person, "name"); // string
// getProperty(person, "gender"); // 错误

// 2. typeof 操作符
const user = {
  name: "John",
  age: 25,
  address: {
    city: "LA",
    zip: "90001"
  }
};

type UserType = typeof user;
// 等价于：
// {
//   name: string;
//   age: number;
//   address: {
//     city: string;
//     zip: string;
//   };
// }

// 3. keyof 和 typeof 结合使用
const colors = {
  red: "#ff0000",
  green: "#00ff00",
  blue: "#0000ff"
};

type Colors = typeof colors;
type ColorKeys = keyof Colors; // "red" | "green" | "blue"
type ColorValues = Colors[keyof Colors]; // "#ff0000" | "#00ff00" | "#0000ff"

// 4. 获取函数类型
function createUser(name: string, age: number) {
  return { name, age };
}

type CreateUserFn = typeof createUser; // (name: string, age: number) => { name: string; age: number; }

// 5. 获取类类型
class Animal {
  constructor(public name: string) {}
  speak() {
    console.log(`${this.name} makes a noise`);
  }
}

type AnimalClass = typeof Animal; // typeof Animal (构造函数类型)
type AnimalInstance = InstanceType<AnimalClass>; // Animal

// 6. 枚举的 keyof
enum Status {
  Pending,
  Active,
  Inactive
}

type StatusKeys = keyof typeof Status; // "Pending" | "Active" | "Inactive"

// 7. 实际应用：创建类型安全的配置
const config = {
  api: {
    baseUrl: "https://api.example.com",
    timeout: 5000
  },
  features: {
    darkMode: true,
    analytics: false
  }
} as const; // 使用 as const 获得字面量类型

type Config = typeof config;
// {
//   readonly api: {
//     readonly baseUrl: "https://api.example.com";
//     readonly timeout: 5000;
//   };
//   readonly features: {
//     readonly darkMode: true;
//     readonly analytics: false;
//   };
// }

type FeatureKeys = keyof typeof config.features; // "darkMode" | "analytics"

// 8. 实际应用：表单验证
interface FormValues {
  email: string;
  password: string;
  rememberMe: boolean;
}

function createValidator<T>(validators: {
  [K in keyof T]?: (value: T[K]) => string | null;
}) {
  return validators;
}

const validator = createValidator<FormValues>({
  email: (value) => value.includes("@") ? null : "Invalid email",
  password: (value) => value.length >= 6 ? null : "Too short"
});

// 9. keyof 和映射类型结合
type Readonly<T> = {
  readonly [K in keyof T]: T[K];
};

type Partial<T> = {
  [K in keyof T]?: T[K];
};

// 10. 获取数组元素的类型
const users = [
  { id: 1, name: "Alice" },
  { id: 2, name: "Bob" }
] as const;

type User = typeof users[number]; // { readonly id: 1; readonly name: "Alice"; } | { readonly id: 2; readonly name: "Bob"; }
```

## 3.4 高级类型

### 1. 联合类型和交叉类型的区别？

**回答：**

*   **联合类型**: `TypeA | TypeB` - 可以是 TypeA 或 TypeB
    
*   **交叉类型**: `TypeA & TypeB` - 同时是 TypeA 和 TypeB
    
```typescript
// 1. 联合类型
type StringOrNumber = string | number;

function process(value: StringOrNumber) {
  if (typeof value === "string") {
    return value.toUpperCase();
  } else {
    return value.toFixed(2);
  }
}

// 2. 交叉类型
interface Named {
  name: string;
}

interface Aged {
  age: number;
}

type Person = Named & Aged; // 必须有 name 和 age

const person: Person = {
  name: "Alice",
  age: 30
  // 缺少 name 或 age 都会报错
};

// 3. 联合类型的实际应用
type Response = SuccessResponse | ErrorResponse;

interface SuccessResponse {
  success: true;
  data: any;
}

interface ErrorResponse {
  success: false;
  error: string;
}

function handleResponse(response: Response) {
  if (response.success) {
    console.log(response.data);
  } else {
    console.error(response.error);
  }
}

// 4. 交叉类型的实际应用
interface ComponentProps {
  className?: string;
  style?: React.CSSProperties;
}

interface ButtonProps {
  onClick: () => void;
  disabled?: boolean;
}

type FullButtonProps = ComponentProps & ButtonProps;

// 5. 联合类型和交叉类型的结合
type Serializable = string | number | boolean;
type JsonObject = { [key: string]: JsonValue };
type JsonArray = JsonValue[];
type JsonValue = Serializable | JsonObject | JsonArray | null;

// 6. 联合类型的类型收缩
type Shape = Circle | Square;

interface Circle {
  kind: "circle";
  radius: number;
}

interface Square {
  kind: "square";
  sideLength: number;
}

function getArea(shape: Shape) {
  switch (shape.kind) {
    case "circle":
      return Math.PI * shape.radius ** 2;
    case "square":
      return shape.sideLength ** 2;
  }
}

// 7. 交叉类型与泛型结合
function merge<T, U>(obj1: T, obj2: U): T & U {
  return { ...obj1, ...obj2 };
}

const merged = merge({ a: 1 }, { b: "hello" }); // { a: number; b: string; }

// 8. 联合类型的分布式特性
type ToArray<T> = T extends any ? T[] : never;

type StrArrOrNumArr = ToArray<string | number>; // string[] | number[]

// 9. 交叉类型的实际应用：Mixin 模式
class Disposable {
  isDisposed = false;
  dispose() {
    this.isDisposed = true;
  }
}

class Activatable {
  isActive = false;
  activate() {
    this.isActive = true;
  }
  deactivate() {
    this.isActive = false;
  }
}

type SmartObject = Disposable & Activatable;

// 10. 联合类型的实际应用：状态管理
type State = 
  | { status: "idle" }
  | { status: "loading" }
  | { status: "success"; data: string }
  | { status: "error"; error: Error };

function handleState(state: State) {
  switch (state.status) {
    case "idle":
      console.log("Ready to load");
      break;
    case "loading":
      console.log("Loading...");
      break;
    case "success":
      console.log("Data:", state.data); // 这里可以访问 data
      break;
    case "error":
      console.error("Error:", state.error.message); // 这里可以访问 error
      break;
  }
}
```

### 2. 类型保护有哪些方式？

**回答：** 用于在运行时检查类型，缩小类型范围。
```typescript
// 1. typeof 类型保护
function padLeft(value: string, padding: string | number) {
  if (typeof padding === "number") {
    return " ".repeat(padding) + value;
  }
  return padding + value;
}

// 2. instanceof 类型保护
class Bird {
  fly() {
    console.log("flying");
  }
}

class Fish {
  swim() {
    console.log("swimming");
  }
}

function move(pet: Bird | Fish) {
  if (pet instanceof Bird) {
    pet.fly();
  } else {
    pet.swim();
  }
}

// 3. in 操作符类型保护
interface Admin {
  adminId: number;
  privileges: string[];
}

interface Employee {
  employeeId: number;
  department: string;
}

function printInfo(person: Admin | Employee) {
  if ("privileges" in person) {
    console.log("Admin:", person.privileges);
  } else {
    console.log("Employee:", person.department);
  }
}

// 4. 自定义类型保护函数
function isString(value: any): value is string {
  return typeof value === "string";
}

function process(value: string | number) {
  if (isString(value)) {
    console.log(value.toUpperCase());
  } else {
    console.log(value.toFixed(2));
  }
}

// 5. 可辨识联合（Discriminated Unions）
type NetworkState =
  | { state: "loading" }
  | { state: "success"; response: string }
  | { state: "failed"; error: string };

function handleNetworkState(state: NetworkState) {
  switch (state.state) {
    case "loading":
      console.log("Loading...");
      break;
    case "success":
      console.log("Response:", state.response);
      break;
    case "failed":
      console.error("Error:", state.error);
      break;
  }
}

// 6. 类型断言函数
function assertIsString(value: any): asserts value is string {
  if (typeof value !== "string") {
    throw new Error("Not a string");
  }
}

function doSomething(value: string | number) {
  assertIsString(value);
  console.log(value.toUpperCase()); // value 现在是 string
}

// 7. 实际应用：API 响应处理
interface ApiResponse<T = any> {
  code: number;
  data: T;
}

function isSuccessResponse<T>(
  response: ApiResponse<T>
): response is ApiResponse<T> & { code: 200 } {
  return response.code === 200;
}

function handleApiResponse(response: ApiResponse) {
  if (isSuccessResponse(response)) {
    console.log("Success:", response.data);
  } else {
    console.error("Error code:", response.code);
  }
}

// 8. 实际应用：表单验证
interface ValidationResult {
  isValid: boolean;
  message?: string;
}

function isValidationSuccess(
  result: ValidationResult
): result is ValidationResult & { isValid: true } {
  return result.isValid;
}

function validateForm(results: ValidationResult[]) {
  for (const result of results) {
    if (!isValidationSuccess(result)) {
      console.error("Validation failed:", result.message);
      return false;
    }
  }
  return true;
}

// 9. 类型保护与条件类型结合
type ExtractString<T> = T extends string ? T : never;

function extractStrings<T>(values: T[]): ExtractString<T>[] {
  return values.filter((v): v is ExtractString<T> => typeof v === "string") as any;
}

// 10. 使用类型谓词处理复杂类型
interface Cat {
  type: "cat";
  meow(): void;
}

interface Dog {
  type: "dog";
  bark(): void;
}

function isCat(pet: Cat | Dog): pet is Cat {
  return pet.type === "cat";
}

function handlePet(pet: Cat | Dog) {
  if (isCat(pet)) {
    pet.meow();
  } else {
    pet.bark();
  }
}
```

### 3. 字面量类型的使用场景？

**回答：** 限制变量只能取特定的值，增强类型安全性。
```typescript
// 1. 字符串字面量类型
type Direction = "north" | "south" | "east" | "west";

function move(direction: Direction) {
  console.log(`Moving ${direction}`);
}

move("north"); // 正确
// move("up"); // 错误：参数类型不符

// 2. 数字字面量类型
type DiceRoll = 1 | 2 | 3 | 4 | 5 | 6;

function rollDice(): DiceRoll {
  return Math.floor(Math.random() * 6 + 1) as DiceRoll;
}

// 3. 布尔字面量类型
type Truthy = true;

function assert(condition: boolean): asserts condition is true {
  if (!condition) {
    throw new Error("Assertion failed");
  }
}

// 4. 对象字面量类型
const config = {
  env: "production",
  debug: false
} as const; // 使用 as const 获得字面量类型

type Config = typeof config;
// {
//   readonly env: "production";
//   readonly debug: false;
// }

// 5. 实际应用：Redux Action Types
type ActionType = 
  | "USER_LOGIN"
  | "USER_LOGOUT"
  | "USER_UPDATE_PROFILE";

interface Action {
  type: ActionType;
  payload?: any;
}

function reducer(state: any, action: Action) {
  switch (action.type) {
    case "USER_LOGIN":
      return { ...state, user: action.payload };
    case "USER_LOGOUT":
      return { ...state, user: null };
    case "USER_UPDATE_PROFILE":
      return { ...state, profile: action.payload };
  }
}

// 6. 实际应用：HTTP 方法
type HttpMethod = "GET" | "POST" | "PUT" | "DELETE" | "PATCH";

function request(method: HttpMethod, url: string) {
  console.log(`Making ${method} request to ${url}`);
}

// 7. 实际应用：CSS 单位
type CssUnit = "px" | "em" | "rem" | "%" | "vh" | "vw";

function setSize(element: HTMLElement, value: number, unit: CssUnit) {
  element.style.width = `${value}${unit}`;
}

// 8. 实际应用：状态机
type State = "idle" | "loading" | "success" | "error";

class Component {
  private state: State = "idle";
  
  setState(newState: State) {
    this.state = newState;
  }
  
  canTransitionTo(target: State): boolean {
    const transitions: Record<State, State[]> = {
      idle: ["loading"],
      loading: ["success", "error"],
      success: ["idle"],
      error: ["idle", "loading"]
    };
    return transitions[this.state].includes(target);
  }
}

// 9. 字面量类型与泛型结合
function createLiteralArray<T extends string>(...args: T[]): T[] {
  return args;
}

const directions = createLiteralArray("north", "south", "east", "west");
// directions 类型为 ("north" | "south" | "east" | "west")[]

// 10. 模板字面量类型
type EventName = `on${Capitalize<string>}`;

const event1: EventName = "onClick"; // 正确
const event2: EventName = "onChange"; // 正确
// const event3: EventName = "click"; // 错误
```

### 4. 映射类型是什么？

**回答：** 基于旧类型创建新类型，批量转换类型的属性。
```typescript
// 1. 基本映射类型
type Readonly<T> = {
  readonly [P in keyof T]: T[P];
};

interface Point {
  x: number;
  y: number;
}

type ReadonlyPoint = Readonly<Point>;
// 等价于：
// {
//   readonly x: number;
//   readonly y: number;
// }

// 2. Partial 映射类型
type Partial<T> = {
  [P in keyof T]?: T[P];
};

type PartialPoint = Partial<Point>;
// {
//   x?: number;
//   y?: number;
// }

// 3. Required 映射类型
type Required<T> = {
  [P in keyof T]-?: T[P];
};

interface OptionalPoint {
  x?: number;
  y?: number;
}

type RequiredPoint = Required<OptionalPoint>;
// {
//   x: number;
//   y: number;
// }

// 4. Pick 映射类型
type Pick<T, K extends keyof T> = {
  [P in K]: T[P];
};

type PointX = Pick<Point, "x">; // { x: number; }

// 5. Record 映射类型
type Record<K extends keyof any, T> = {
  [P in K]: T;
};

type ThreeD = Record<"x" | "y" | "z", number>;
// {
//   x: number;
//   y: number;
//   z: number;
// }

// 6. 实际应用：将属性变为可空
type Nullable<T> = {
  [P in keyof T]: T[P] | null;
};

interface User {
  name: string;
  age: number;
}

type NullableUser = Nullable<User>;
// {
//   name: string | null;
//   age: number | null;
// }

// 7. 实际应用：将属性变为函数
type FunctionProperty<T> = {
  [P in keyof T]: (arg: T[P]) => void;
};

type UserFunctions = FunctionProperty<User>;
// {
//   name: (arg: string) => void;
//   age: (arg: number) => void;
// }

// 8. 实际应用：属性名重映射
type Getters<T> = {
  [P in keyof T as `get${Capitalize<string & P>}`]: () => T[P];
};

type UserGetters = Getters<User>;
// {
//   getName: () => string;
//   getAge: () => number;
// }

// 9. 过滤属性
type FilterProperties<T, U> = {
  [P in keyof T as T[P] extends U ? P : never]: T[P];
};

interface MixedProps {
  id: number;
  name: string;
  age: number;
  email: string;
}

type StringProps = FilterProperties<MixedProps, string>;
// {
//   name: string;
//   email: string;
// }

// 10. 复杂映射类型：深度只读
type DeepReadonly<T> = {
  readonly [P in keyof T]: T[P] extends object ? DeepReadonly<T[P]> : T[P];
};

interface Company {
  name: string;
  address: {
    street: string;
    city: string;
  };
}

type ReadonlyCompany = DeepReadonly<Company>;
// {
//   readonly name: string;
//   readonly address: {
//     readonly street: string;
//     readonly city: string;
//   };
// }

// 11. 映射类型与条件类型结合
type ExcludeMethods<T> = {
  [K in keyof T as T[K] extends Function ? never : K]: T[K];
};

class MyClass {
  name: string = "";
  age: number = 0;
  greet() {
    console.log("Hello");
  }
}

type DataOnly = ExcludeMethods<MyClass>;
// {
//   name: string;
//   age: number;
// }
```

### 5. 模板字面量类型如何使用？

**回答：** 使用模板字符串语法创建类型，常用于模式匹配和字符串操作。
```typescript
// 1. 基本模板字面量类型
type Greeting = `Hello, ${string}`;

const greeting1: Greeting = "Hello, World"; // 正确
const greeting2: Greeting = "Hello, TypeScript"; // 正确
// const greeting3: Greeting = "Hi there"; // 错误

// 2. 与联合类型结合
type Color = "red" | "green" | "blue";
type ColorEvent = `on${Capitalize<Color>}`;

const event1: ColorEvent = "onRed"; // 正确
const event2: ColorEvent = "onGreen"; // 正确
// const event3: ColorEvent = "onYellow"; // 错误

// 3. 多个占位符
type Path = `/${string}/${string}`;

const path1: Path = "/users/profile"; // 正确
const path2: Path = "/products/123"; // 正确
// const path3: Path = "/home"; // 错误：需要两个部分

// 4. 实际应用：CSS 类名
type Size = "small" | "medium" | "large";
type Variant = "primary" | "secondary" | "danger";
type ButtonClass = `btn btn-${Size} btn-${Variant}`;

const btnClass: ButtonClass = "btn btn-medium btn-primary";

// 5. 实际应用：API 端点
type HttpMethod = "GET" | "POST" | "PUT" | "DELETE";
type Resource = "users" | "products" | "orders";
type ApiEndpoint = `${HttpMethod} /api/${Resource}/${string}`;

const endpoint1: ApiEndpoint = "GET /api/users/123";
const endpoint2: ApiEndpoint = "POST /api/products";
// const endpoint3: ApiEndpoint = "PATCH /api/orders"; // 错误：PATCH 不在 HttpMethod 中

// 6. 实际应用：事件处理器
type EventType = "click" | "change" | "input";
type HandlerName = `handle${Capitalize<EventType>}`;

type EventHandlers = {
  [K in HandlerName]?: (event: Event) => void;
};

const handlers: EventHandlers = {
  handleClick: (e) => console.log("clicked"),
  handleChange: (e) => console.log("changed")
};

// 7. 模板字面量类型推断
type ExtractRouteParams<T extends string> =
  T extends `${string}/:${infer Param}/${infer Rest}`
    ? Param | ExtractRouteParams<`/${Rest}`>
    : T extends `${string}/:${infer Param}`
    ? Param
    : never;

type Params = ExtractRouteParams<"/users/:userId/posts/:postId">;
// "userId" | "postId"

// 8. 字符串操作类型
type Uppercase<S extends string> = intrinsic; // 内置类型
type Lowercase<S extends string> = intrinsic;
type Capitalize<S extends string> = intrinsic;
type Uncapitalize<S extends string> = intrinsic;

type T1 = Uppercase<"hello">; // "HELLO"
type T2 = Lowercase<"WORLD">; // "world"
type T3 = Capitalize<"typescript">; // "Typescript"
type T4 = Uncapitalize<"TypeScript">; // "typeScript"

// 9. 复杂的模板类型：构建查询字符串
type QueryString<T extends Record<string, any>> = {
  [K in keyof T]: `${string & K}=${string}`;
}[keyof T];

type Query = QueryString<{ id: number; name: string }>;
// "id=${string}" | "name=${string}"

// 10. 实际应用：类型安全的国际化
type Language = "en" | "fr" | "de";
type TranslationKey = `${Language}.${string}`;

const translations: Record<TranslationKey, string> = {
  "en.welcome": "Welcome",
  "en.goodbye": "Goodbye",
  "fr.welcome": "Bienvenue",
  "fr.goodbye": "Au revoir"
  // "es.hola": "Hola" // 错误：es 不在 Language 中
};

function t(key: TranslationKey): string {
  return translations[key];
}

// 11. 模板类型与条件类型结合
type IsApiEndpoint<T> = T extends `${infer Method} /api/${infer Rest}`
  ? Method extends "GET" | "POST" | "PUT" | "DELETE"
    ? true
    : false
  : false;

type Test1 = IsApiEndpoint<"GET /api/users">; // true
type Test2 = IsApiEndpoint<"PATCH /api/products">; // false
```

## 3.5 类与面向对象

### 1. TypeScript 中类的访问修饰符有哪些？

**回答：** `public`、`private`、`protected`、`readonly`。
```typescript
// 1. public（默认）：任何地方都可以访问
class Animal {
  public name: string;
  
  constructor(name: string) {
    this.name = name;
  }
  
  public move(distance: number) {
    console.log(`${this.name} moved ${distance}m.`);
  }
}

const animal = new Animal("Cat");
console.log(animal.name); // 可以访问
animal.move(10); // 可以调用

// 2. private：只能在类内部访问
class Animal2 {
  private secret: string = "secret";
  
  public revealSecret() {
    return this.secret; // 可以在类内部访问
  }
}

const animal2 = new Animal2();
// console.log(animal2.secret); // 错误：secret 是私有的
console.log(animal2.revealSecret()); // 通过公共方法访问

// 3. protected：可以在类内部和子类中访问
class Person {
  protected name: string;
  
  constructor(name: string) {
    this.name = name;
  }
}

class Employee extends Person {
  private department: string;
  
  constructor(name: string, department: string) {
    super(name);
    this.department = department;
  }
  
  public getElevatorPitch() {
    return `Hello, my name is ${this.name} and I work in ${this.department}.`; // 可以访问 protected 属性
  }
}

const employee = new Employee("Alice", "Sales");
console.log(employee.getElevatorPitch());
// console.log(employee.name); // 错误：name 是 protected

// 4. readonly：只读属性，必须在声明时或构造函数中初始化
class Octopus {
  readonly name: string;
  readonly numberOfLegs: number = 8;
  
  constructor(name: string) {
    this.name = name;
  }
}

const octopus = new Octopus("Man with the 8 strong legs");
console.log(octopus.name);
// octopus.name = "new name"; // 错误：只读属性

// 5. 参数属性：在构造函数参数中直接定义属性
class Animal3 {
  constructor(
    public name: string,
    private age: number,
    protected species: string
  ) {}
  
  public getInfo() {
    return `${this.name} is a ${this.species} aged ${this.age}`;
  }
}

const animal3 = new Animal3("Buddy", 5, "Dog");
console.log(animal3.name); // 可以访问
// console.log(animal3.age); // 错误：private
// console.log(animal3.species); // 错误：protected

// 6. 静态属性/方法
class Grid {
  static origin = { x: 0, y: 0 };
  
  constructor(public scale: number) {}
  
  calculateDistance(point: { x: number; y: number }) {
    const xDist = point.x - Grid.origin.x; // 通过类名访问静态属性
    const yDist = point.y - Grid.origin.y;
    return Math.sqrt(xDist * xDist + yDist * yDist) / this.scale;
  }
  
  static createDefaultGrid() {
    return new Grid(1.0);
  }
}

console.log(Grid.origin); // { x: 0, y: 0 }
const grid = Grid.createDefaultGrid();

// 7. 实际应用：封装实现细节
class BankAccount {
  private balance: number = 0;
  
  public deposit(amount: number): void {
    if (amount > 0) {
      this.balance += amount;
    }
  }
  
  public withdraw(amount: number): boolean {
    if (amount > 0 && amount <= this.balance) {
      this.balance -= amount;
      return true;
    }
    return false;
  }
  
  public getBalance(): number {
    return this.balance;
  }
}

const account = new BankAccount();
account.deposit(100);
account.withdraw(30);
console.log(account.getBalance()); // 70
// console.log(account.balance); // 错误：private
```

### 2. 抽象类和接口的区别？

**回答：**

*   **抽象类**：可以有具体实现，可以包含抽象方法，使用 `extends` 继承
    
*   **接口**：只有定义没有实现，可以多重实现，使用 `implements` 实现
    
```typescript
// 1. 抽象类
abstract class Animal {
  protected name: string;
  
  constructor(name: string) {
    this.name = name;
  }
  
  // 抽象方法：子类必须实现
  abstract makeSound(): void;
  
  // 具体方法：子类可以直接使用或覆盖
  move(distance: number = 0) {
    console.log(`${this.name} moved ${distance}m.`);
  }
}

// 不能直接实例化抽象类
// const animal = new Animal("Pet"); // 错误：无法创建抽象类的实例

class Dog extends Animal {
  constructor(name: string) {
    super(name);
  }
  
  // 必须实现抽象方法
  makeSound() {
    console.log("Woof! Woof!");
  }
  
  // 可以覆盖父类方法
  move(distance: number = 5) {
    console.log("Running...");
    super.move(distance);
  }
}

const dog = new Dog("Buddy");
dog.makeSound(); // "Woof! Woof!"
dog.move(10);

// 2. 接口
interface Flyable {
  fly(): void;
}

interface Swimmable {
  swim(): void;
}

// 类可以实现多个接口
class Duck implements Flyable, Swimmable {
  fly() {
    console.log("Duck is flying");
  }
  
  swim() {
    console.log("Duck is swimming");
  }
}

// 3. 接口可以扩展
interface Vehicle {
  speed: number;
  accelerate(): void;
}

interface Car extends Vehicle {
  wheels: number;
  brake(): void;
}

class SportsCar implements Car {
  speed: number = 0;
  wheels: number = 4;
  
  accelerate() {
    this.speed += 10;
  }
  
  brake() {
    this.speed = Math.max(0, this.speed - 10);
  }
}

// 4. 抽象类可以有构造函数和属性初始化
abstract class Shape {
  protected color: string;
  
  constructor(color: string) {
    this.color = color;
  }
  
  abstract getArea(): number;
  abstract getPerimeter(): number;
  
  describe() {
    console.log(`This is a ${this.color} shape`);
  }
}

class Circle extends Shape {
  constructor(color: string, private radius: number) {
    super(color);
  }
  
  getArea() {
    return Math.PI * this.radius * this.radius;
  }
  
  getPerimeter() {
    return 2 * Math.PI * this.radius;
  }
}

// 5. 接口可以声明合并，抽象类不能
interface User {
  name: string;
}

interface User {
  age: number;
}

// 合并后：{ name: string; age: number; }

// 6. 实际应用：策略模式（接口）
interface PaymentStrategy {
  pay(amount: number): void;
}

class CreditCardPayment implements PaymentStrategy {
  pay(amount: number) {
    console.log(`Paid $${amount} using Credit Card`);
  }
}

class PayPalPayment implements PaymentStrategy {
  pay(amount: number) {
    console.log(`Paid $${amount} using PayPal`);
  }
}

class ShoppingCart {
  constructor(private paymentStrategy: PaymentStrategy) {}
  
  checkout(amount: number) {
    this.paymentStrategy.pay(amount);
  }
}

// 7. 实际应用：模板方法模式（抽象类）
abstract class DataProcessor {
  // 模板方法：定义算法骨架
  process() {
    this.loadData();
    this.transformData();
    this.saveData();
  }
  
  protected abstract loadData(): void;
  protected abstract transformData(): void;
  
  protected saveData() {
    console.log("Saving data..."); // 可以有默认实现
  }
}

class CsvProcessor extends DataProcessor {
  protected loadData() {
    console.log("Loading CSV data...");
  }
  
  protected transformData() {
    console.log("Transforming CSV data...");
  }
  
  // 可以覆盖默认实现
  protected saveData() {
    console.log("Saving to database...");
    super.saveData();
  }
}
```

### 3. 类中的 getter 和 setter 如何使用？

**回答：** 用于控制对类属性的访问，提供封装和验证。
```typescript
// 1. 基本的 getter 和 setter
class Person {
  private _age: number = 0;
  private _firstName: string = "";
  private _lastName: string = "";
  
  // getter：访问属性
  get age(): number {
    return this._age;
  }
  
  // setter：设置属性（可以添加验证）
  set age(value: number) {
    if (value >= 0 && value <= 120) {
      this._age = value;
    } else {
      throw new Error("Invalid age");
    }
  }
  
  // 计算属性（只有 getter）
  get fullName(): string {
    return `${this._firstName} ${this._lastName}`;
  }
  
  // 只有 setter
  set name(value: string) {
    const [firstName, lastName] = value.split(" ");
    this._firstName = firstName || "";
    this._lastName = lastName || "";
  }
}

const person = new Person();
person.age = 25; // 使用 setter
console.log(person.age); // 25，使用 getter
person.name = "John Doe";
console.log(person.fullName); // "John Doe"

// person.age = 150; // 抛出错误

// 2. 实际应用：温度转换
class Temperature {
  private _celsius: number = 0;
  
  get celsius(): number {
    return this._celsius;
  }
  
  set celsius(value: number) {
    this._celsius = value;
  }
  
  get fahrenheit(): number {
    return this._celsius * 9/5 + 32;
  }
  
  set fahrenheit(value: number) {
    this._celsius = (value - 32) * 5/9;
  }
  
  get kelvin(): number {
    return this._celsius + 273.15;
  }
  
  set kelvin(value: number) {
    this._celsius = value - 273.15;
  }
}

const temp = new Temperature();
temp.celsius = 25;
console.log(`Celsius: ${temp.celsius}`); // 25
console.log(`Fahrenheit: ${temp.fahrenheit}`); // 77
console.log(`Kelvin: ${temp.kelvin}`); // 298.15

temp.fahrenheit = 100;
console.log(`Celsius: ${temp.celsius}`); // 37.777...

// 3. 实际应用：表单字段验证
class FormField {
  private _value: string = "";
  private _errors: string[] = [];
  
  constructor(private validator?: (value: string) => string[]) {}
  
  get value(): string {
    return this._value;
  }
  
  set value(newValue: string) {
    this._value = newValue;
    this._errors = this.validator ? this.validator(newValue) : [];
  }
  
  get errors(): string[] {
    return this._errors;
  }
  
  get isValid(): boolean {
    return this._errors.length === 0;
  }
}

const emailField = new FormField((value) => {
  const errors: string[] = [];
  if (!value.includes("@")) {
    errors.push("Invalid email format");
  }
  if (value.length < 5) {
    errors.push("Email too short");
  }
  return errors;
});

emailField.value = "test@example.com";
console.log(emailField.isValid); // true
console.log(emailField.errors); // []

emailField.value = "invalid";
console.log(emailField.isValid); // false
console.log(emailField.errors); // ["Invalid email format", "Email too short"]

// 4. getter/setter 与继承
class Base {
  protected _value: number = 0;
  
  get value(): number {
    return this._value;
  }
  
  set value(v: number) {
    this._value = v;
  }
}

class Derived extends Base {
  // 可以覆盖 getter/setter
  get value(): number {
    return super.value * 2;
  }
  
  set value(v: number) {
    super.value = v / 2;
  }
}

const derived = new Derived();
derived.value = 10;
console.log(derived.value); // 10（实际上存储的是 5）

// 5. 使用 getter/setter 实现数据绑定
class Observable<T> {
  private _value: T;
  private listeners: ((value: T) => void)[] = [];
  
  constructor(initialValue: T) {
    this._value = initialValue;
  }
  
  get value(): T {
    return this._value;
  }
  
  set value(newValue: T) {
    if (this._value !== newValue) {
      this._value = newValue;
      this.notifyListeners();
    }
  }
  
  subscribe(listener: (value: T) => void): () => void {
    this.listeners.push(listener);
    return () => {
      const index = this.listeners.indexOf(listener);
      if (index > -1) {
        this.listeners.splice(index, 1);
      }
    };
  }
  
  private notifyListeners() {
    for (const listener of this.listeners) {
      listener(this._value);
    }
  }
}

const obs = new Observable("initial");
const unsubscribe = obs.subscribe((value) => {
  console.log("Value changed:", value);
});

obs.value = "updated"; // 触发监听器
obs.value = "updated"; // 不会触发（值相同）
unsubscribe();
obs.value = "final"; // 不会触发（已取消订阅）
```

### 4. 如何实现单例模式？

**回答：** 确保一个类只有一个实例，并提供全局访问点。
```typescript
// 1. 经典的单例模式实现
class Singleton {
  private static instance: Singleton;
  private data: string;
  
  // 私有构造函数，防止外部实例化
  private constructor(data: string) {
    this.data = data;
  }
  
  // 全局访问点
  public static getInstance(data: string = "default"): Singleton {
    if (!Singleton.instance) {
      Singleton.instance = new Singleton(data);
    }
    return Singleton.instance;
  }
  
  public getData(): string {
    return this.data;
  }
  
  public setData(data: string): void {
    this.data = data;
  }
}

// 使用
const singleton1 = Singleton.getInstance("first");
const singleton2 = Singleton.getInstance("second");

console.log(singleton1.getData()); // "first"
console.log(singleton2.getData()); // "first"（同一个实例）
console.log(singleton1 === singleton2); // true

// 2. 使用静态属性和私有构造函数
class Database {
  private static _instance: Database;
  private connection: string;
  
  private constructor(connectionString: string) {
    this.connection = connectionString;
    console.log("Database connected:", connectionString);
  }
  
  public static get instance(): Database {
    if (!Database._instance) {
      Database._instance = new Database("default-connection");
    }
    return Database._instance;
  }
  
  public query(sql: string): any[] {
    console.log(`Executing query: ${sql}`);
    return [];
  }
  
  public disconnect(): void {
    console.log("Database disconnected");
  }
}

// 使用属性访问器
const db1 = Database.instance;
const db2 = Database.instance;
console.log(db1 === db2); // true

db1.query("SELECT * FROM users");

// 3. 延迟初始化单例
class LazySingleton {
  private static _instance: LazySingleton;
  
  private constructor() {}
  
  public static getInstance(): LazySingleton {
    if (!LazySingleton._instance) {
      LazySingleton._instance = new LazySingleton();
    }
    return LazySingleton._instance;
  }
  
  public doSomething(): void {
    console.log("Doing something...");
  }
}

// 4. 线程安全单例（考虑并发）
class ThreadSafeSingleton {
  private static instance: ThreadSafeSingleton;
  private static lock = false;
  
  private constructor() {}
  
  public static getInstance(): ThreadSafeSingleton {
    if (!ThreadSafeSingleton.instance) {
      ThreadSafeSingleton.lock = true;
      if (!ThreadSafeSingleton.instance) {
        ThreadSafeSingleton.instance = new ThreadSafeSingleton();
      }
      ThreadSafeSingleton.lock = false;
    }
    return ThreadSafeSingleton.instance;
  }
}

// 5. 实际应用：配置管理器
class ConfigManager {
  private static _instance: ConfigManager;
  private config: Record<string, any> = {};
  
  private constructor() {
    // 加载配置
    this.config = {
      apiUrl: process.env.API_URL || "http://localhost:3000",
      timeout: parseInt(process.env.TIMEOUT || "5000"),
      debug: process.env.DEBUG === "true"
    };
  }
  
  public static get instance(): ConfigManager {
    if (!ConfigManager._instance) {
      ConfigManager._instance = new ConfigManager();
    }
    return ConfigManager._instance;
  }
  
  public get<T>(key: string): T | undefined {
    return this.config[key] as T;
  }
  
  public set<T>(key: string, value: T): void {
    this.config[key] = value;
  }
}

// 在整个应用中使用同一个配置实例
const config = ConfigManager.instance;
console.log(config.get<string>("apiUrl"));

// 6. 实际应用：日志管理器
class Logger {
  private static _instance: Logger;
  private logs: string[] = [];
  
  private constructor() {}
  
  public static get instance(): Logger {
    if (!Logger._instance) {
      Logger._instance = new Logger();
    }
    return Logger._instance;
  }
  
  public log(message: string): void {
    const timestamp = new Date().toISOString();
    const logMessage = `[${timestamp}] ${message}`;
    this.logs.push(logMessage);
    console.log(logMessage);
  }
  
  public getLogs(): string[] {
    return [...this.logs]; // 返回副本
  }
  
  public clear(): void {
    this.logs = [];
  }
}

// 在不同模块中使用同一个日志实例
Logger.instance.log("Application started");
Logger.instance.log("User logged in");

// 7. 使用 namespace 实现单例模式（模块模式）
namespace AppState {
  export interface State {
    user?: { id: number; name: string };
    theme: "light" | "dark";
    isLoading: boolean;
  }
  
  let state: State = {
    theme: "light",
    isLoading: false
  };
  
  export function getState(): State {
    return { ...state }; // 返回副本
  }
  
  export function setState(newState: Partial<State>): void {
    state = { ...state, ...newState };
  }
  
  export function subscribe(listener: () => void): () => void {
    // 简单实现，实际应用中会有更完整的实现
    return () => {};
  }
}

// 使用
AppState.setState({ theme: "dark" });
console.log(AppState.getState());
```

### 5. 什么是混入？

**回答：** 一种重用类功能的模式，可以将多个类的功能组合到一个类中。
```typescript
// 1. 构造函数类型
type Constructor<T = {}> = new (...args: any[]) => T;

// 2. 混入函数
function TimestampMixin<TBase extends Constructor>(Base: TBase) {
  return class extends Base {
    createdAt = new Date();
    updatedAt = new Date();
    
    updateTimestamp() {
      this.updatedAt = new Date();
    }
  };
}

function LoggableMixin<TBase extends Constructor>(Base: TBase) {
  return class extends Base {
    log(message: string) {
      console.log(`[${this.constructor.name}] ${message}`);
    }
  };
}

// 3. 基础类
class User {
  constructor(public name: string, public email: string) {}
  
  display() {
    console.log(`User: ${this.name}, Email: ${this.email}`);
  }
}

// 4. 应用混入
const TimestampedUser = TimestampMixin(User);
const LoggableTimestampedUser = LoggableMixin(TimestampedUser);

const user = new LoggableTimestampedUser("Alice", "alice@example.com");
user.display(); // User: Alice, Email: alice@example.com
console.log(user.createdAt); // 当前时间
user.log("User created"); // [LoggableTimestampedUser] User created

// 5. 实际应用：可序列化混入
function SerializableMixin<TBase extends Constructor>(Base: TBase) {
  return class extends Base {
    serialize(): string {
      return JSON.stringify(this);
    }
    
    static deserialize<T>(this: new (...args: any[]) => T, json: string): T {
      const data = JSON.parse(json);
      const instance = new this();
      Object.assign(instance, data);
      return instance;
    }
  };
}

class Product {
  constructor(public id: number, public name: string, public price: number) {}
}

const SerializableProduct = SerializableMixin(Product);
const product = new SerializableProduct(1, "Laptop", 999);
const json = product.serialize();
console.log(json); // {"id":1,"name":"Laptop","price":999}

const restored = SerializableProduct.deserialize(json);
console.log(restored instanceof Product); // true

// 6. 实际应用：验证混入
function ValidatableMixin<TBase extends Constructor>(Base: TBase) {
  return class extends Base {
    private _errors: Record<string, string[]> = {};
    
    get errors(): Record<string, string[]> {
      return { ...this._errors };
    }
    
    get isValid(): boolean {
      return Object.keys(this._errors).length === 0;
    }
    
    validate(): boolean {
      this._errors = {};
      this.runValidations();
      return this.isValid;
    }
    
    protected runValidations(): void {
      // 子类实现具体的验证逻辑
    }
    
    protected addError(field: string, message: string): void {
      if (!this._errors[field]) {
        this._errors[field] = [];
      }
      this._errors[field].push(message);
    }
  };
}

class ValidatableUser extends ValidatableMixin(User) {
  protected runValidations(): void {
    if (!this.name) {
      this.addError("name", "Name is required");
    }
    if (!this.email.includes("@")) {
      this.addError("email", "Invalid email format");
    }
  }
}

const validatableUser = new ValidatableUser("", "invalid-email");
validatableUser.validate();
console.log(validatableUser.isValid); // false
console.log(validatableUser.errors);
// { name: ["Name is required"], email: ["Invalid email format"] }

// 7. 多重混入
function applyMixins(derivedCtor: any, baseCtors: any[]) {
  baseCtors.forEach(baseCtor => {
    Object.getOwnPropertyNames(baseCtor.prototype).forEach(name => {
      Object.defineProperty(
        derivedCtor.prototype,
        name,
        Object.getOwnPropertyDescriptor(baseCtor.prototype, name)!
      );
    });
  });
}

class Disposable {
  isDisposed = false;
  dispose() {
    this.isDisposed = true;
  }
}

class Activatable {
  isActive = false;
  activate() {
    this.isActive = true;
  }
  deactivate() {
    this.isActive = false;
  }
}

class SmartObject implements Disposable, Activatable {
  // Disposable
  isDisposed: boolean = false;
  dispose!: () => void;
  
  // Activatable
  isActive: boolean = false;
  activate!: () => void;
  deactivate!: () => void;
  
  interact() {
    this.activate();
  }
}

applyMixins(SmartObject, [Disposable, Activatable]);

const smartObj = new SmartObject();
smartObj.interact();
console.log(smartObj.isActive); // true
smartObj.dispose();
console.log(smartObj.isDisposed); // true
```

## 3.6 模块与命名空间

### 1. namespace 和 module 的区别？

**回答：**

*   **namespace**: 组织代码，防止命名冲突，主要用于内部模块
    
*   **module**: ES6 模块，用于组织代码和依赖，推荐使用
    
```typescript
// 1. namespace（内部模块）
namespace Validation {
  export interface StringValidator {
    isAcceptable(s: string): boolean;
  }
  
  const lettersRegexp = /^[A-Za-z]+$/;
  const numberRegexp = /^[0-9]+$/;
  
  export class LettersOnlyValidator implements StringValidator {
    isAcceptable(s: string) {
      return lettersRegexp.test(s);
    }
  }
  
  export class ZipCodeValidator implements StringValidator {
    isAcceptable(s: string) {
      return s.length === 5 && numberRegexp.test(s);
    }
  }
}

// 使用 namespace
let validators: { [s: string]: Validation.StringValidator } = {};
validators["ZIP code"] = new Validation.ZipCodeValidator();
validators["Letters only"] = new Validation.LettersOnlyValidator();

// 2. namespace 嵌套
namespace Shapes {
  export namespace Polygons {
    export class Triangle {}
    export class Square {}
  }
  
  export class Circle {}
}

// 使用嵌套 namespace
const triangle = new Shapes.Polygons.Triangle();

// 3. namespace 分割（多文件）
// validation.ts
namespace Validation {
  export interface StringValidator {
    isAcceptable(s: string): boolean;
  }
}

// letters-validator.ts
/// <reference path="validation.ts" />
namespace Validation {
  const lettersRegexp = /^[A-Za-z]+$/;
  export class LettersOnlyValidator implements StringValidator {
    isAcceptable(s: string) {
      return lettersRegexp.test(s);
    }
  }
}

// 4. module（ES6 模块）- 推荐使用
// validation.ts
export interface StringValidator {
  isAcceptable(s: string): boolean;
}

const lettersRegexp = /^[A-Za-z]+$/;
export class LettersOnlyValidator implements StringValidator {
  isAcceptable(s: string) {
    return lettersRegexp.test(s);
  }
}

// app.ts
import { StringValidator, LettersOnlyValidator } from './validation';

let validators: StringValidator[] = [];
validators.push(new LettersOnlyValidator());

// 5. module 重命名
import { LettersOnlyValidator as LetterValidator } from './validation';

// 6. 导入整个模块
import * as Validation from './validation';
const validator = new Validation.LettersOnlyValidator();

// 7. 默认导出
// logger.ts
export default class Logger {
  log(message: string) {
    console.log(message);
  }
}

// app.ts
import Logger from './logger';
const logger = new Logger();

// 8. 区别总结：
// - namespace 主要用于组织内部代码，避免全局污染
// - module 是 ES6 标准，支持静态分析和 tree shaking
// - 现代 TypeScript 项目推荐使用 module

// 9. 实际应用：第三方库声明
// 使用 namespace 声明第三方库
declare namespace $ {
  function ajax(url: string, settings?: any): void;
  const version: string;
}

// 使用
$.ajax("/api/data");

// 10. 实际应用：模块 vs 命名空间选择
// 对于应用代码，使用 module（ES6 模块）
// 对于类型定义文件（.d.ts），使用 namespace 或 module
```

### 2. 如何声明全局类型？

**回答：** 在 `.d.ts` 文件中使用 `declare global` 或直接声明。
```typescript
// 1. 在 .d.ts 文件中声明全局类型
// global.d.ts
declare global {
  interface Window {
    myApp: {
      version: string;
      init(): void;
    };
  }
  
  interface Document {
    myCustomMethod(): void;
  }
  
  const APP_VERSION: string;
  function myGlobalFunction(): void;
}

// 2. 使用 declare 声明全局变量
// global-vars.d.ts
declare const __DEV__: boolean;
declare const __VERSION__: string;

// 使用
if (__DEV__) {
  console.log("Development mode");
}

// 3. 声明全局函数
// global-functions.d.ts
declare function formatDate(date: Date): string;
declare function calculateDistance(x1: number, y1: number, x2: number, y2: number): number;

// 4. 声明全局类
// global-classes.d.ts
declare class MyGlobalClass {
  constructor(name: string);
  greet(): void;
}

// 5. 扩展内置类型
// extend-builtins.d.ts
interface String {
  toTitleCase(): string;
  truncate(maxLength: number): string;
}

interface Array<T> {
  shuffle(): T[];
  unique(): T[];
}

// 实现（在 .ts 文件中）
String.prototype.toTitleCase = function() {
  return this.replace(/\w\S*/g, (txt) => 
    txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase()
  );
};

Array.prototype.shuffle = function() {
  const arr = [...this];
  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
};

// 6. 实际应用：环境变量类型
// env.d.ts
declare namespace NodeJS {
  interface ProcessEnv {
    NODE_ENV: 'development' | 'production' | 'test';
    API_URL: string;
    PORT?: string;
    DB_HOST: string;
    DB_PORT: string;
    DB_USER: string;
    DB_PASSWORD: string;
    DB_NAME: string;
  }
}

// 使用
const apiUrl = process.env.API_URL;

// 7. 实际应用：Web API 扩展
// web-api.d.ts
interface Navigator {
  getUserMedia?: (
    constraints: MediaStreamConstraints,
    success: (stream: MediaStream) => void,
    error: (error: Error) => void
  ) => void;
}

interface Performance {
  memory?: {
    usedJSHeapSize: number;
    totalJSHeapSize: number;
    jsHeapSizeLimit: number;
  };
}

// 8. 实际应用：自定义事件
// custom-events.d.ts
declare global {
  interface WindowEventMap {
    'app:ready': CustomEvent<{ version: string }>;
    'user:login': CustomEvent<{ userId: string; name: string }>;
    'user:logout': CustomEvent;
  }
}

// 使用
window.addEventListener('app:ready', (event) => {
  console.log(`App ${event.detail.version} is ready`);
});

// 9. 模块中的全局声明
// 在模块中声明全局类型
export {}; // 确保这是模块

declare global {
  interface GlobalType {
    id: number;
    name: string;
  }
}

// 10. 类型合并
// types.d.ts
interface AppConfig {
  version: string;
  environment: string;
}

// 在其他文件中可以扩展
interface AppConfig {
  features: string[];
}

// 最终 AppConfig 包含 version、environment 和 features
```

### 3. declare 关键字的作用？

**回答：** 声明类型而不包含实现，用于描述已存在的变量、函数、类等。
```typescript
// 1. 声明变量
declare const VERSION: string;
declare let DEBUG: boolean;

// 2. 声明函数
declare function greet(name: string): void;
declare function calculate(a: number, b: number): number;

// 3. 声明类
declare class MyLibrary {
  constructor(config: any);
  method(): void;
  static staticMethod(): string;
}

// 4. 声明命名空间
declare namespace MyApp {
  interface Config {
    apiUrl: string;
    timeout: number;
  }
  
  function initialize(config: Config): void;
  const version: string;
}

// 5. 声明模块
declare module "my-module" {
  export function doSomething(): void;
  export const importantValue: number;
}

// 6. 声明全局扩展
declare global {
  interface Window {
    myGlobal: any;
  }
  
  interface String {
    padZero(length: number): string;
  }
}

// 7. 声明三斜线指令
/// <reference path="jquery.d.ts" />
/// <reference types="node" />

// 8. 实际应用：描述第三方库
// jquery.d.ts
declare namespace JQuery {
  interface AjaxSettings {
    url: string;
    type?: string;
    data?: any;
    success?: (data: any) => void;
  }
}

declare const $: {
  ajax(settings: JQuery.AjaxSettings): void;
  (selector: string): any;
  fn: any;
};

// 9. 实际应用：描述没有 TypeScript 定义的库
// custom.d.ts
declare module "some-library-without-types" {
  const lib: {
    doSomething(): void;
    value: string;
  };
  export default lib;
}

// 使用
import lib from "some-library-without-types";
lib.doSomething();

// 10. 实际应用：环境声明
// node.d.ts
declare module "process" {
  export = process;
}

declare module "fs" {
  export function readFileSync(path: string): Buffer;
  export function writeFileSync(path: string, data: Buffer): void;
}

// 11. 条件类型声明
declare module "*.module.css" {
  const classes: { [key: string]: string };
  export default classes;
}

declare module "*.png" {
  const value: string;
  export default value;
}

declare module "*.svg" {
  import React = require("react");
  export const ReactComponent: React.FC<React.SVGProps<SVGSVGElement>>;
  const src: string;
  export default src;
}

// 12. 类型声明合并
interface User {
  name: string;
  age: number;
}

// 扩展接口
declare interface User {
  email?: string;
}

// 13. 函数重载声明
declare function createElement(tag: "div"): HTMLDivElement;
declare function createElement(tag: "span"): HTMLSpanElement;
declare function createElement(tag: string): HTMLElement;

// 14. 使用 declare 避免运行时错误
// 描述已存在的全局变量
declare const process: {
  env: {
    NODE_ENV: string;
    [key: string]: string | undefined;
  };
};

if (process.env.NODE_ENV === "development") {
  console.log("Dev mode");
}
```

### 4. 模块解析策略有哪些？

**回答：** TypeScript 支持两种模块解析策略：`classic` 和 `node`。
```typescript
// tsconfig.json 配置
{
  "compilerOptions": {
    // 模块解析策略
    "moduleResolution": "node", // 或 "classic"
    
    // 影响模块解析的其他配置
    "baseUrl": "./", // 基础目录
    "paths": { // 路径映射
      "@/*": ["src/*"],
      "components/*": ["src/components/*"]
    },
    "rootDirs": ["src", "generated"], // 虚拟目录
    "typeRoots": ["./types", "./node_modules/@types"] // 类型声明位置
  }
}

// 1. Classic 解析策略（已过时）
// 相对模块：相对于当前文件
// import { x } from "./moduleB"; // 查找 ./moduleB.ts、./moduleB.d.ts

// 非相对模块：从包含导入文件的目录开始向上查找
// import { x } from "moduleA"; 
// 查找顺序：
// 1. ./moduleA.ts
// 2. ./moduleA.d.ts
// 3. ../moduleA.ts
// 4. ../moduleA.d.ts
// 5. ../../moduleA.ts
// ...

// 2. Node 解析策略（推荐）
// 模拟 Node.js 的模块解析机制
// import { x } from "moduleA";
// 查找顺序：
// 1. 检查当前目录的 node_modules/moduleA
// 2. 检查父目录的 node_modules/moduleA
// 3. 一直向上检查直到根目录

// 具体文件查找：
// 1. moduleA.ts
// 2. moduleA.tsx
// 3. moduleA.d.ts
// 4. 查看 package.json 中的 "types" 或 "typings" 字段
// 5. 查看 package.json 中的 "main" 字段
// 6. 查找 index.ts、index.tsx、index.d.ts

// 3. 相对路径导入
// src/utils/math.ts
export function add(a: number, b: number): number {
  return a + b;
}

// src/app.ts
import { add } from "./utils/math"; // 正确
// import { add } from "utils/math"; // 错误：非相对路径需要配置

// 4. 使用 baseUrl
// tsconfig.json
{
  "compilerOptions": {
    "baseUrl": "./src"
  }
}

// 现在可以从 baseUrl 开始导入
// src/app.ts
import { add } from "utils/math"; // 查找 ./src/utils/math.ts

// 5. 使用 paths 路径映射
// tsconfig.json
{
  "compilerOptions": {
    "baseUrl": "./",
    "paths": {
      "@/*": ["src/*"],
      "utils/*": ["src/utils/*"],
      "components/*": ["src/components/*"]
    }
  }
}

// 使用路径别名
// src/app.ts
import { add } from "utils/math"; // 解析为 ./src/utils/math.ts
import { Button } from "@/components/Button"; // 解析为 ./src/components/Button.ts

// 6. rootDirs 虚拟目录
// tsconfig.json
{
  "compilerOptions": {
    "rootDirs": ["src/views", "generated/views"]
  }
}

// 可以将多个目录视为同一个根目录
// src/views/home.ts 和 generated/views/home.ts 可以互相导入

// 7. 类型查找
// TypeScript 查找类型声明的顺序：
// 1. 当前文件的 .d.ts 声明
// 2. 查找 node_modules/@types 目录
// 3. 查找 typeRoots 指定的目录
// 4. 查找 node_modules 中的 package.json 的 types/typings 字段

// 8. 实际应用：monorepo 配置
// tsconfig.base.json
{
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@myapp/*": ["packages/*/src"],
      "@shared/*": ["packages/shared/src/*"]
    }
  }
}

// packages/app/src/index.ts
import { utils } from "@shared/utils"; // 解析为 packages/shared/src/utils.ts

// 9. 实际应用：自定义类型声明
// types/ 目录结构：
// types/
//   my-library/
//     index.d.ts
//   global.d.ts

// tsconfig.json
{
  "compilerOptions": {
    "typeRoots": ["./node_modules/@types", "./types"]
  }
}

// 10. 模块解析错误排查
// 常见问题：
// - 找不到模块：检查路径是否正确，baseUrl/paths 配置
// - 类型错误：检查类型声明文件是否存在
// - 循环依赖：重构代码或使用 import() 动态导入

// 11. 动态导入（运行时解析）
async function loadModule() {
  // 动态导入，返回 Promise
  const module = await import("./dynamic-module");
  module.doSomething();
}

// 12. 外部模块声明
// 描述没有 .d.ts 文件的模块
declare module "*.json" {
  const value: any;
  export default value;
}

declare module "*.css" {
  const content: { [className: string]: string };
  export default content;
}
```

### 5. 如何扩展第三方库的类型声明？

**回答：** 通过声明合并、模块增强或创建 `.d.ts` 文件。
```typescript
// 1. 扩展全局变量（如 window）
// global.d.ts 或任何 .d.ts 文件
declare global {
  interface Window {
    myAppConfig: {
      version: string;
      debug: boolean;
    };
    // 添加自定义方法
    myCustomMethod(): void;
  }
}

// 使用
window.myAppConfig = {
  version: "1.0.0",
  debug: true
};

window.myCustomMethod = function() {
  console.log("Custom method called");
};

// 2. 扩展第三方库的类型
// 假设我们使用 axios，并想添加自定义配置
import { AxiosRequestConfig } from 'axios';

declare module 'axios' {
  export interface AxiosRequestConfig {
    // 添加自定义配置
    customConfig?: {
      retryTimes: number;
      showLoading: boolean;
    };
    // 添加自定义头
    headers?: {
      'X-Custom-Header'?: string;
      [key: string]: any;
    };
  }
  
  // 如果需要，也可以扩展响应类型
  export interface AxiosResponse<T = any> {
    customField?: string;
  }
}

// 使用
import axios from 'axios';

const config: AxiosRequestConfig = {
  url: '/api/data',
  customConfig: {
    retryTimes: 3,
    showLoading: true
  },
  headers: {
    'X-Custom-Header': 'value'
  }
};

axios(config);

// 3. 扩展 Express 的 Request 对象
// types/express.d.ts
import { Request } from 'express';

declare global {
  namespace Express {
    interface Request {
      // 添加自定义属性
      user?: {
        id: string;
        name: string;
        role: string;
      };
      // 添加自定义方法
      getClientInfo(): {
        ip: string;
        userAgent: string;
      };
    }
  }
}

// 4. 扩展 React 组件 Props
// types/react.d.ts
import 'react';

declare module 'react' {
  interface HTMLAttributes<T> extends AriaAttributes, DOMAttributes<T> {
    // 添加自定义属性
    'data-custom'?: string;
    'aria-custom'?: string;
  }
  
  interface CSSProperties {
    // 添加自定义 CSS 属性
    '--custom-color'?: string;
    '--custom-size'?: string;
  }
}

// 5. 为没有类型定义的库创建声明
// types/custom-library.d.ts
declare module 'custom-library' {
  // 导出类型
  export interface CustomOptions {
    timeout?: number;
    retry?: boolean;
  }
  
  // 导出函数
  export function init(options: CustomOptions): void;
  export function doSomething(): Promise<string>;
  
  // 默认导出
  const defaultExport: {
    init: typeof init;
    doSomething: typeof doSomething;
    version: string;
  };
  
  export default defaultExport;
}

// 6. 扩展 Date 原型
// types/date-extensions.d.ts
interface Date {
  // 添加自定义方法
  format(pattern: string): string;
  addDays(days: number): Date;
  isToday(): boolean;
}

// 实现（在 .ts 文件中）
Date.prototype.format = function(pattern: string): string {
  // 实现格式化逻辑
  return pattern; // 简化示例
};

Date.prototype.addDays = function(days: number): Date {
  const date = new Date(this);
  date.setDate(date.getDate() + days);
  return date;
};

// 7. 合并多个声明文件
// 如果第三方库有多个部分需要扩展，可以在不同文件中声明
// types/library-part1.d.ts
declare module 'some-library' {
  export interface Part1 {
    method1(): void;
  }
}

// types/library-part2.d.ts  
declare module 'some-library' {
  export interface Part2 {
    method2(): void;
  }
}

// 最终合并为一个模块

// 8. 使用三斜线指令引用
// main.d.ts
/// <reference path="./custom-types.d.ts" />
/// <reference types="node" />

// 9. 实际应用：扩展 Vue 3 的全局属性
// vue-shim.d.ts
import { ComponentCustomProperties } from 'vue';

declare module '@vue/runtime-core' {
  interface ComponentCustomProperties {
    $filters: {
      formatCurrency(value: number): string;
      formatDate(date: Date): string;
    };
    $api: {
      getUser(id: string): Promise<any>;
      updateUser(id: string, data: any): Promise<any>;
    };
  }
}

// 10. 实际应用：扩展 Next.js 的类型
// next-env.d.ts
/// <reference types="next" />
/// <reference types="next/image-types/global" />

// 扩展 NextPage 类型
import { NextPage } from 'next';

declare module 'next' {
  export type NextPageWithLayout<P = {}, IP = P> = NextPage<P, IP> & {
    getLayout?: (page: ReactElement) => ReactNode;
  };
}

// 11. 条件类型扩展
// 根据环境扩展不同的类型
declare global {
  interface ProcessEnv {
    NODE_ENV: 'development' | 'production' | 'test';
    // 开发环境特定的变量
    DEV_API_URL?: string;
    // 生产环境特定的变量
    PROD_API_URL?: string;
  }
}

// 12. 使用 declare namespace 扩展
// 扩展现有的命名空间
declare namespace SomeNamespace {
  // 添加新接口
  export interface ExtendedOptions {
    newOption: string;
  }
  
  // 添加新函数
  export function newFunction(): void;
}
```

## 3.7 工具类型

### 1. Partial、Required、Readonly 的作用？

**回答：** 内置工具类型，用于转换对象类型的属性。
```typescript
// 1. Partial<T> - 将所有属性变为可选
interface User {
  id: number;
  name: string;
  age: number;
  email: string;
}

type PartialUser = Partial<User>;
// 等价于：
// {
//   id?: number;
//   name?: string;
//   age?: number;
//   email?: string;
// }

// 使用场景：更新对象的部分属性
function updateUser(id: number, updates: Partial<User>) {
  // 只更新提供的属性
}

updateUser(1, { name: "Alice" }); // 只更新 name
updateUser(2, { age: 30, email: "alice@example.com" }); // 更新多个属性

// 2. Required<T> - 将所有属性变为必选
interface OptionalUser {
  id?: number;
  name?: string;
  age?: number;
}

type RequiredUser = Required<OptionalUser>;
// 等价于：
// {
//   id: number;
//   name: string;
//   age: number;
// }

// 使用场景：确保所有属性都有值
function createUser(user: RequiredUser) {
  // 确保所有属性都存在
}

createUser({ id: 1, name: "Alice", age: 30 }); // 必须提供所有属性

// 3. Readonly<T> - 将所有属性变为只读
type ReadonlyUser = Readonly<User>;
// 等价于：
// {
//   readonly id: number;
//   readonly name: string;
//   readonly age: number;
//   readonly email: string;
// }

const user: ReadonlyUser = {
  id: 1,
  name: "Alice",
  age: 30,
  email: "alice@example.com"
};

// user.name = "Bob"; // 错误：只读属性

// 4. 实际应用：不可变状态
interface AppState {
  user: User;
  theme: "light" | "dark";
  isLoading: boolean;
}

function reducer(state: Readonly<AppState>, action: any): AppState {
  // state 是只读的，不能直接修改
  // return { ...state, user: action.payload }; // 必须返回新对象
  return state;
}

// 5. 实际应用：表单验证
interface FormData {
  username?: string;
  password?: string;
  email?: string;
}

function validateForm(data: Required<FormData>): boolean {
  // 这里可以确保所有字段都有值
  return !!(data.username && data.password && data.email);
}

// 6. 实际应用：配置合并
interface DefaultConfig {
  host: string;
  port: number;
  timeout: number;
}

function createConfig(overrides: Partial<DefaultConfig>): DefaultConfig {
  const defaults: DefaultConfig = {
    host: "localhost",
    port: 3000,
    timeout: 5000
  };
  
  return { ...defaults, ...overrides };
}

const config = createConfig({ port: 8080 });
// { host: "localhost", port: 8080, timeout: 5000 }

// 7. 深度 Partial（自定义）
type DeepPartial<T> = {
  [P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P];
};

interface NestedData {
  user: {
    name: string;
    address: {
      city: string;
      country: string;
    };
  };
  settings: {
    theme: string;
    notifications: boolean;
  };
}

type PartialNestedData = DeepPartial<NestedData>;
// 所有层级都是可选的

// 8. 实际应用：API 请求和响应
interface ApiRequest {
  method: string;
  url: string;
  headers?: Record<string, string>;
  body?: any;
}

type ApiResponse<T = any> = {
  success: boolean;
  data?: T;
  error?: string;
};

function makeRequest(config: Required<Pick<ApiRequest, 'method' | 'url'>> & 
                     Partial<Omit<ApiRequest, 'method' | 'url'>>) {
  // method 和 url 是必需的，其他是可选的
}

// 9. 组合使用工具类型
type UserUpdate = Partial<Pick<User, 'name' | 'age' | 'email'>> & {
  id: number; // id 是必需的
};

function updateUserProfile(update: UserUpdate) {
  // 必须有 id，其他属性可选
}

// 10. 使用映射类型实现这些工具类型
type MyPartial<T> = {
  [P in keyof T]?: T[P];
};

type MyRequired<T> = {
  [P in keyof T]-?: T[P];
};

type MyReadonly<T> = {
  readonly [P in keyof T]: T[P];
};
```

### 2. Pick、Omit、Exclude、Extract 的区别？

**回答：** 用于从类型中选择或排除属性/成员。
```typescript
// 1. Pick<T, K> - 从 T 中选择指定属性 K
interface User {
  id: number;
  name: string;
  age: number;
  email: string;
  password: string;
}

type PublicUser = Pick<User, 'id' | 'name' | 'email'>;
// 等价于：
// {
//   id: number;
//   name: string;
//   email: string;
// }

// 使用场景：创建只包含必要属性的类型
function getUserProfile(user: User): PublicUser {
  const { id, name, email } = user;
  return { id, name, email };
}

// 2. Omit<T, K> - 从 T 中排除指定属性 K
type UserWithoutPassword = Omit<User, 'password'>;
// 等价于：
// {
//   id: number;
//   name: string;
//   age: number;
//   email: string;
// }

type SensitiveUser = Omit<User, 'password' | 'email'>;
// 排除多个属性

// 3. Exclude<T, U> - 从联合类型 T 中排除可以赋值给 U 的类型
type T0 = Exclude<'a' | 'b' | 'c', 'a'>; // 'b' | 'c'
type T1 = Exclude<string | number | (() => void), Function>; // string | number
type T2 = Exclude<'a' | 'b' | 'c', 'a' | 'b'>; // 'c'

// 使用场景：过滤类型
type Primitive = string | number | boolean | symbol | null | undefined;
type NonPrimitive = Exclude<any, Primitive>; // 非原始类型

// 4. Extract<T, U> - 从联合类型 T 中提取可以赋值给 U 的类型
type T3 = Extract<'a' | 'b' | 'c', 'a' | 'f'>; // 'a'
type T4 = Extract<string | number | (() => void), Function>; // () => void

// 使用场景：提取特定类型
type FunctionProps<T> = {
  [K in keyof T]: T[K] extends Function ? K : never;
}[keyof T];

type UserFunctionProps = FunctionProps<User>; // never（User 没有函数属性）

// 5. 实际应用：组件 Props
interface BaseProps {
  className?: string;
  style?: React.CSSProperties;
  children?: React.ReactNode;
}

interface ButtonProps extends BaseProps {
  onClick: () => void;
  disabled?: boolean;
  type?: 'button' | 'submit' | 'reset';
}

// 提取事件处理器类型
type EventHandlers = Extract<keyof ButtonProps, `on${string}`>; // "onClick"

// 6. 实际应用：表单处理
interface FormValues {
  username: string;
  password: string;
  rememberMe: boolean;
  email: string;
}

// 只验证某些字段
type ValidationFields = Pick<FormValues, 'username' | 'password'>;
// 排除某些字段
type AutoFillFields = Omit<FormValues, 'password'>;

// 7. 实际应用：API 端点
type HttpMethod = 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH' | 'HEAD';
type SafeMethod = Extract<HttpMethod, 'GET' | 'HEAD'>; // 'GET' | 'HEAD'
type MutatingMethod = Exclude<HttpMethod, 'GET' | 'HEAD'>; // 'POST' | 'PUT' | 'DELETE' | 'PATCH'

// 8. 实际应用：类型安全的路由
type Route = 
  | { path: '/'; component: Home }
  | { path: '/about'; component: About }
  | { path: '/contact'; component: Contact }
  | { path: '/admin'; component: Admin; requiresAuth: true };

// 提取需要认证的路由
type AuthRoute = Extract<Route, { requiresAuth: true }>;
// 提取不需要认证的路由  
type PublicRoute = Exclude<Route, { requiresAuth: true }>;

// 9. 自定义工具类型
// 选择多个属性
type MyPick<T, K extends keyof T> = {
  [P in K]: T[P];
};

// 排除多个属性
type MyOmit<T, K extends keyof any> = Pick<T, Exclude<keyof T, K>>;

// 10. 组合使用
type UserSummary = Pick<User, 'id' | 'name'> & {
  profileUrl: string;
};

type UserUpdateData = Omit<User, 'id' | 'password'> & {
  id: number; // 重新添加 id
};

// 11. 使用条件类型实现
type ExtractStringKeys<T> = {
  [K in keyof T]: T[K] extends string ? K : never;
}[keyof T];

type StringProps<T> = Pick<T, ExtractStringKeys<T>>;

type UserStringProps = StringProps<User>; // Pick<User, "name" | "email">
```

### 3. Record、NonNullable、ReturnType 的作用？

**回答：** 创建映射类型、排除空值和获取函数返回类型。
```typescript
// 1. Record<K, T> - 创建键为 K，值为 T 的对象类型
type ThreeD = Record<'x' | 'y' | 'z', number>;
// 等价于：
// {
//   x: number;
//   y: number;
//   z: number;
// }

// 使用场景：创建字典/映射
type UserRoles = Record<string, 'admin' | 'user' | 'guest'>;

const roles: UserRoles = {
  'user:1': 'admin',
  'user:2': 'user',
  'user:3': 'guest'
};

// 2. NonNullable<T> - 从 T 中排除 null 和 undefined
type T0 = NonNullable<string | number | null | undefined>; // string | number
type T1 = NonNullable<string[] | null | undefined>; // string[]

// 使用场景：确保值不为空
function processValue<T>(value: T): NonNullable<T> {
  if (value == null) {
    throw new Error("Value cannot be null or undefined");
  }
  return value as NonNullable<T>;
}

// 3. ReturnType<T> - 获取函数类型 T 的返回值类型
function getUser() {
  return { id: 1, name: 'Alice' };
}

type User = ReturnType<typeof getUser>; // { id: number; name: string }

type T2 = ReturnType<() => string>; // string
type T3 = ReturnType<<T>() => T>; // unknown
type T4 = ReturnType<<T extends U, U extends number[]>() => T>; // number[]

// 4. 实际应用：配置对象
type Config = Record<string, any>;

const appConfig: Config = {
  api: {
    baseUrl: 'https://api.example.com',
    timeout: 5000
  },
  features: {
    darkMode: true,
    analytics: false
  }
};

// 5. 实际应用：API 响应包装器
function createApiResponse<T extends (...args: any[]) => any>(
  handler: T
): {
  handler: T;
  returnType: ReturnType<T>;
} {
  return {
    handler,
    returnType: undefined as any // 实际使用时会有值
  };
}

const api = createApiResponse(() => ({ success: true, data: 'test' }));
type ApiResponse = typeof api.returnType; // { success: boolean; data: string; }

// 6. 实际应用：表单字段定义
type FormField<T> = {
  value: T;
  error?: string;
  touched: boolean;
};

type FormFields<T extends Record<string, any>> = {
  [K in keyof T]: FormField<T[K]>;
};

interface LoginForm {
  username: string;
  password: string;
  rememberMe: boolean;
}

type LoginFormFields = FormFields<LoginForm>;
// 等价于：
// {
//   username: FormField<string>;
//   password: FormField<string>;
//   rememberMe: FormField<boolean>;
// }

// 7. 实际应用：工具函数类型推断
function createSelector<T extends (...args: any[]) => any>(
  selector: T
): (...args: Parameters<T>) => ReturnType<T> {
  return selector;
}

const selectUser = createSelector((state: any) => state.user);
// selectUser 类型: (state: any) => any

// 8. 实际应用：深度 NonNullable
type DeepNonNullable<T> = {
  [P in keyof T]-?: T[P] extends object ? DeepNonNullable<T[P]> : NonNullable<T[P]>;
};

interface Nested {
  a?: {
    b?: {
      c?: string | null;
    } | null;
  } | null;
  d?: string | null;
}

type RequiredNested = DeepNonNullable<Nested>;
// {
//   a: {
//     b: {
//       c: string;
//     };
//   };
//   d: string;
// }

// 9. 实际应用：事件映射
type EventMap = Record<string, (...args: any[]) => void>;

class EventEmitter {
  private events: EventMap = {};
  
  on<T extends keyof EventMap>(event: T, handler: EventMap[T]) {
    this.events[event] = handler;
  }
  
  emit<T extends keyof EventMap>(event: T, ...args: Parameters<EventMap[T]>) {
    this.events[event]?.(...args);
  }
}

// 10. 组合使用
function safelyCall<T extends (...args: any[]) => any>(
  fn: T,
  ...args: Parameters<T>
): ReturnType<T> | null {
  try {
    return fn(...args);
  } catch {
    return null;
  }
}

// 11. 使用映射类型实现 Record
type MyRecord<K extends keyof any, T> = {
  [P in K]: T;
};

// 12. 获取构造函数返回类型
class Animal {
  constructor(public name: string) {}
}

type AnimalInstance = InstanceType<typeof Animal>; // Animal
type AnimalConstructor = ConstructorParameters<typeof Animal>; // [string]
```

### 4. 如何获取函数的参数类型？

**回答：** 使用 `Parameters<T>` 工具类型。
```typescript
// 1. Parameters<T> - 获取函数类型的参数类型元组
function getUser(id: number, name: string, options?: { active: boolean }) {
  return { id, name };
}

type UserParams = Parameters<typeof getUser>;
// 等价于：[number, string, { active: boolean }?]

// 使用场景：包装函数
function wrapFunction<T extends (...args: any[]) => any>(
  fn: T,
  ...args: Parameters<T>
): ReturnType<T> {
  console.log("Calling function with args:", args);
  return fn(...args);
}

wrapFunction(getUser, 1, "Alice", { active: true });

// 2. 获取第一个参数类型
type FirstParam<T> = T extends (first: infer First, ...rest: any[]) => any 
  ? First 
  : never;

type First = FirstParam<typeof getUser>; // number

// 3. 获取剩余参数类型
type RestParams<T> = T extends (first: any, ...rest: infer Rest) => any 
  ? Rest 
  : never;

type Rest = RestParams<typeof getUser>; // [string, { active: boolean }?]

// 4. 实际应用：高阶函数
function debounce<T extends (...args: any[]) => any>(
  fn: T,
  delay: number
): (...args: Parameters<T>) => void {
  let timeoutId: NodeJS.Timeout;
  
  return (...args: Parameters<T>) => {
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => fn(...args), delay);
  };
}

const debouncedGetUser = debounce(getUser, 300);
debouncedGetUser(1, "Alice"); // 类型正确

// 5. 实际应用：日志装饰器
function logCall<T extends (...args: any[]) => any>(
  fn: T
): (...args: Parameters<T>) => ReturnType<T> {
  return (...args: Parameters<T>) => {
    console.log(`Calling ${fn.name} with:`, args);
    const result = fn(...args);
    console.log(`Result:`, result);
    return result;
  };
}

const loggedGetUser = logCall(getUser);
loggedGetUser(1, "Alice");

// 6. 实际应用：参数验证
function validateArgs<T extends (...args: any[]) => any>(
  fn: T,
  validators: {
    [K in keyof Parameters<T>]: (arg: Parameters<T>[K]) => boolean;
  }
): T {
  return ((...args: Parameters<T>) => {
    args.forEach((arg, index) => {
      if (validators[index] && !validators[index](arg)) {
        throw new Error(`Argument at index ${index} is invalid`);
      }
    });
    return fn(...args);
  }) as T;
}

const validatedGetUser = validateArgs(getUser, [
  (id) => id > 0, // 验证 id
  (name) => name.length > 0 // 验证 name
]);

// 7. 实际应用：API 客户端
type ApiFunction = (url: string, options?: RequestInit) => Promise<any>;

function createApiClient<T extends Record<string, ApiFunction>>(
  api: T
): {
  [K in keyof T]: (...args: Parameters<T[K]>) => Promise<ReturnType<T[K]>>;
} {
  // 实现 API 客户端
  return {} as any;
}

const api = {
  getUser: (id: number) => Promise.resolve({ id, name: "Alice" }),
  createUser: (data: { name: string }) => Promise.resolve({ id: 1, ...data })
};

const client = createApiClient(api);
client.getUser(1); // 类型正确

// 8. 实际应用：Redux action creator
type ActionCreator<T extends (...args: any[]) => any> = 
  (...args: Parameters<T>) => {
    type: string;
    payload: ReturnType<T>;
  };

function createAction<T extends (...args: any[]) => any>(
  type: string,
  creator: T
): ActionCreator<T> {
  return (...args: Parameters<T>) => ({
    type,
    payload: creator(...args)
  });
}

const addUser = createAction('ADD_USER', (name: string, age: number) => ({
  id: Date.now(),
  name,
  age
}));

const action = addUser("Alice", 30);
// action 类型：{ type: string; payload: { id: number; name: string; age: number; } }

// 9. 获取构造函数参数
class User {
  constructor(public id: number, public name: string) {}
}

type UserConstructorParams = ConstructorParameters<typeof User>; // [number, string]

// 10. 实际应用：依赖注入
type Dependencies<T> = {
  [K in keyof T]: T[K] extends new (...args: any[]) => any 
    ? ConstructorParameters<T[K]> 
    : never;
};

class Container {
  private instances = new Map();
  
  register<T>(token: new (...args: any[]) => T, ...args: ConstructorParameters<typeof token>) {
    this.instances.set(token, new token(...args));
  }
  
  resolve<T>(token: new (...args: any[]) => T): T {
    return this.instances.get(token);
  }
}

// 11. 使用 infer 关键字自定义
type MyParameters<T> = T extends (...args: infer P) => any ? P : never;
type MyConstructorParameters<T> = T extends new (...args: infer P) => any ? P : never;
```

### 5. infer 关键字的作用？

**回答：** 在条件类型中推断类型，提取嵌套类型信息。
```typescript
// 1. 基本用法：推断函数返回类型
type ReturnType<T> = T extends (...args: any[]) => infer R ? R : any;

function getUser() {
  return { id: 1, name: 'Alice' };
}

type User = ReturnType<typeof getUser>; // { id: number; name: string }

// 2. 推断函数参数类型
type Parameters<T> = T extends (...args: infer P) => any ? P : never;

type Params = Parameters<typeof getUser>; // []

// 3. 推断数组/元组元素类型
type ElementType<T> = T extends (infer U)[] ? U : never;

type Arr = ElementType<string[]>; // string
type Tuple = ElementType<[string, number]>; // string | number

// 4. 推断 Promise 类型
type UnwrapPromise<T> = T extends Promise<infer U> ? U : T;

type PromiseResult = UnwrapPromise<Promise<string>>; // string

// 5. 推断第一个参数类型
type FirstArg<T> = T extends (first: infer First, ...rest: any[]) => any 
  ? First 
  : never;

function greet(name: string, greeting: string = "Hello") {
  return `${greeting}, ${name}!`;
}

type Name = FirstArg<typeof greet>; // string

// 6. 实际应用：提取 React 组件 Props
type PropsOf<T> = T extends React.ComponentType<infer P> ? P : never;

const MyComponent: React.FC<{ name: string; age: number }> = () => null;
type MyProps = PropsOf<typeof MyComponent>; // { name: string; age: number }

// 7. 实际应用：提取事件类型
type EventType<T> = T extends (event: infer E) => any ? E : never;

type ClickEvent = EventType<(event: React.MouseEvent) => void>; // React.MouseEvent

// 8. 实际应用：深度提取
type DeepUnwrap<T> = 
  T extends Promise<infer U> ? DeepUnwrap<U> :
  T extends (infer U)[] ? DeepUnwrap<U>[] :
  T extends object ? { [K in keyof T]: DeepUnwrap<T[K]> } :
  T;

type Complex = Promise<{ data: string[] }>;
type Unwrapped = DeepUnwrap<Complex>; // { data: string[] }

// 9. 实际应用：条件类型分发
type DistributedInfer<T> = T extends (infer U)[] ? U : T;

type Result1 = DistributedInfer<string | number[]>; // string | number
type Result2 = DistributedInfer<(string | number)[]>; // string | number

// 10. 多个 infer 位置
type Zip<T, U> = T extends [infer A, ...infer RestT]
  ? U extends [infer B, ...infer RestU]
    ? [[A, B], ...Zip<RestT, RestU>]
    : []
  : [];

type Zipped = Zip<[1, 2, 3], ['a', 'b', 'c']>;
// [[1, "a"], [2, "b"], [3, "c"]]

// 11. 实际应用：提取函数重载的返回类型
type OverloadReturnType<T> = 
  T extends {
    (...args: any[]): infer R;
    (...args: any[]): infer R;
    (...args: any[]): infer R;
  } ? R : never;

// 12. 实际应用：提取键值对类型
type ExtractKeyValue<T> = T extends [infer K, infer V] 
  ? K extends string 
    ? Record<K, V> 
    : never 
  : never;

type Pair = ['name', string];
type KeyValue = ExtractKeyValue<Pair>; // { name: string }

// 13. 实际应用：路由参数提取
type ExtractRouteParams<Path> = 
  Path extends `${string}:${infer Param}/${infer Rest}`
    ? Param | ExtractRouteParams<`/${Rest}`>
    : Path extends `${string}:${infer Param}`
    ? Param
    : never;

type Params = ExtractRouteParams<'/users/:userId/posts/:postId'>;
// "userId" | "postId"

// 14. 实际应用：递归类型推断
type DeepReadonly<T> = {
  readonly [K in keyof T]: T[K] extends object ? DeepReadonly<T[K]> : T[K];
};

type Nested = {
  a: {
    b: {
      c: string;
    };
  };
};

type ReadonlyNested = DeepReadonly<Nested>;
// {
//   readonly a: {
//     readonly b: {
//       readonly c: string;
//     };
//   };
// }

// 15. infer 在模板字面量类型中的应用
type ParseTemplate<T> = 
  T extends `${infer Start}{${infer Var}}${infer Rest}`
    ? { [K in Var | keyof ParseTemplate<Rest>]: string }
    : {};

type Template = ParseTemplate<'Hello {name}, welcome to {city}!'>;
// { name: string; city: string; }
```

## 3.8 装饰器

### 1. 装饰器有哪些类型？

**回答：** 类装饰器、方法装饰器、访问器装饰器、属性装饰器、参数装饰器。
```typescript
// 需要在 tsconfig.json 中启用装饰器
// {
//   "compilerOptions": {
//     "experimentalDecorators": true,
//     "emitDecoratorMetadata": true
//   }
// }

// 1. 类装饰器 - 应用于类构造函数
function ClassDecorator(constructor: Function) {
  console.log(`Class decorator called for: ${constructor.name}`);
  
  // 可以修改类
  constructor.prototype.customProperty = "added by decorator";
  constructor.staticProperty = "static value";
}

@ClassDecorator
class MyClass {
  static staticProperty: string;
  
  method() {
    console.log((this as any).customProperty); // "added by decorator"
  }
}

const instance = new MyClass();
instance.method();
console.log(MyClass.staticProperty); // "static value"

// 2. 方法装饰器 - 应用于类方法
function MethodDecorator(
  target: any,
  propertyKey: string,
  descriptor: PropertyDescriptor
) {
  console.log(`Method decorator called for: ${propertyKey}`);
  
  const originalMethod = descriptor.value;
  
  // 修改方法行为
  descriptor.value = function(...args: any[]) {
    console.log(`Calling method: ${propertyKey} with args:`, args);
    const result = originalMethod.apply(this, args);
    console.log(`Method ${propertyKey} returned:`, result);
    return result;
  };
}

class Calculator {
  @MethodDecorator
  add(a: number, b: number): number {
    return a + b;
  }
}

const calc = new Calculator();
calc.add(2, 3); // 输出调用日志和返回日志

// 3. 访问器装饰器 - 应用于 getter/setter
function AccessorDecorator(
  target: any,
  propertyKey: string,
  descriptor: PropertyDescriptor
) {
  console.log(`Accessor decorator called for: ${propertyKey}`);
  
  const originalGet = descriptor.get;
  const originalSet = descriptor.set;
  
  if (originalGet) {
    descriptor.get = function() {
      console.log(`Getting ${propertyKey}`);
      return originalGet.call(this);
    };
  }
  
  if (originalSet) {
    descriptor.set = function(value: any) {
      console.log(`Setting ${propertyKey} to:`, value);
      return originalSet.call(this, value);
    };
  }
}

class Person {
  private _name: string = "";
  
  @AccessorDecorator
  get name(): string {
    return this._name;
  }
  
  set name(value: string) {
    this._name = value;
  }
}

const person = new Person();
person.name = "Alice"; // 输出: Setting name to: Alice
console.log(person.name); // 输出: Getting name, 然后 "Alice"

// 4. 属性装饰器 - 应用于类属性
function PropertyDecorator(target: any, propertyKey: string) {
  console.log(`Property decorator called for: ${propertyKey}`);
  
  // 可以修改属性的元数据，但不能直接修改属性值
  const metadataKey = `__${propertyKey}_metadata`;
  target[metadataKey] = { decorated: true };
}

class Product {
  @PropertyDecorator
  name: string = "";
  
  price: number = 0;
}

const product = new Product();
console.log((product as any).__name_metadata); // { decorated: true }

// 5. 参数装饰器 - 应用于方法参数
function ParameterDecorator(
  target: any,
  propertyKey: string,
  parameterIndex: number
) {
  console.log(`Parameter decorator called for: ${propertyKey}, index: ${parameterIndex}`);
  
  // 记录参数信息
  const metadataKey = `${propertyKey}_parameters`;
  if (!target[metadataKey]) {
    target[metadataKey] = [];
  }
  target[metadataKey].push(parameterIndex);
}

class Service {
  connect(
    @ParameterDecorator host: string,
    @ParameterDecorator port: number
  ) {
    console.log(`Connecting to ${host}:${port}`);
  }
}

const service = new Service();
console.log((service as any).connect_parameters); // [0, 1]

// 6. 装饰器工厂 - 返回装饰器函数的函数
function Log(message: string) {
  return function(target: any, propertyKey?: string, descriptor?: PropertyDescriptor) {
    console.log(`${message} - ${propertyKey || target.name}`);
  };
}

@Log("Class decorated")
class Example {
  @Log("Method decorated")
  exampleMethod() {}
}

// 7. 装饰器组合 - 多个装饰器应用于同一个目标
function First() {
  console.log("First decorator factory");
  return function(target: any) {
    console.log("First decorator applied");
  };
}

function Second() {
  console.log("Second decorator factory");
  return function(target: any) {
    console.log("Second decorator applied");
  };
}

@First()
@Second()
class MultiDecoratedClass {}
// 输出顺序：
// First decorator factory
// Second decorator factory
// Second decorator applied
// First decorator applied
```

### 2. 类装饰器、方法装饰器如何使用？

**回答：** 类装饰器接收构造函数，方法装饰器接收目标对象、属性名和属性描述符。
```typescript
// 1. 类装饰器 - 修改或扩展类
function Sealed(constructor: Function) {
  Object.seal(constructor);
  Object.seal(constructor.prototype);
}

@Sealed
class Greeter {
  greeting: string;
  
  constructor(message: string) {
    this.greeting = message;
  }
  
  greet() {
    return "Hello, " + this.greeting;
  }
}

// 尝试修改类（在严格模式下会失败）
// Greeter.prototype.greet = function() { return "MODIFIED"; };

// 2. 类装饰器工厂 - 带参数的装饰器
function Component(options: { selector: string; template: string }) {
  return function<T extends { new(...args: any[]): {} }>(constructor: T) {
    return class extends constructor {
      selector = options.selector;
      template = options.template;
      
      render() {
        console.log(`Rendering ${this.selector} with template: ${this.template}`);
      }
    };
  };
}

@Component({
  selector: "app-root",
  template: "<h1>Hello World</h1>"
})
class AppComponent {
  name = "App";
}

const app = new AppComponent();
console.log((app as any).selector); // "app-root"
console.log((app as any).template); // "<h1>Hello World</h1>"
(app as any).render(); // "Rendering app-root with template: <h1>Hello World</h1>"

// 3. 方法装饰器 - 修改方法行为
function LogExecutionTime() {
  return function(
    target: any,
    propertyKey: string,
    descriptor: PropertyDescriptor
  ) {
    const originalMethod = descriptor.value;
    
    descriptor.value = async function(...args: any[]) {
      const start = performance.now();
      try {
        const result = await originalMethod.apply(this, args);
        const end = performance.now();
        console.log(`${propertyKey} executed in ${end - start}ms`);
        return result;
      } catch (error) {
        const end = performance.now();
        console.error(`${propertyKey} failed after ${end - start}ms:`, error);
        throw error;
      }
    };
    
    return descriptor;
  };
}

class DataService {
  @LogExecutionTime()
  async fetchData(url: string): Promise<any> {
    // 模拟网络请求
    await new Promise(resolve => setTimeout(resolve, 100));
    return { data: "some data" };
  }
}

const service = new DataService();
service.fetchData("/api/data").then(console.log);

// 4. 方法装饰器 - 自动重试
function Retry(maxRetries: number = 3) {
  return function(
    target: any,
    propertyKey: string,
    descriptor: PropertyDescriptor
  ) {
    const originalMethod = descriptor.value;
    
    descriptor.value = async function(...args: any[]) {
      let lastError: Error;
      
      for (let i = 0; i < maxRetries; i++) {
        try {
          return await originalMethod.apply(this, args);
        } catch (error) {
          lastError = error as Error;
          console.log(`Attempt ${i + 1} failed for ${propertyKey}:`, error);
          
          if (i < maxRetries - 1) {
            // 等待指数退避时间
            await new Promise(resolve => setTimeout(resolve, 100 * Math.pow(2, i)));
          }
        }
      }
      
      throw lastError!;
    };
    
    return descriptor;
  };
}

class ApiService {
  private attemptCount = 0;
  
  @Retry(3)
  async callApi(): Promise<string> {
    this.attemptCount++;
    
    if (this.attemptCount < 3) {
      throw new Error("API temporarily unavailable");
    }
    
    return "Success";
  }
}

const api = new ApiService();
api.callApi().then(console.log).catch(console.error);

// 5. 方法装饰器 - 权限检查
function RequireRole(role: string) {
  return function(
    target: any,
    propertyKey: string,
    descriptor: PropertyDescriptor
  ) {
    const originalMethod = descriptor.value;
    
    descriptor.value = function(...args: any[]) {
      const user = (this as any).currentUser;
      
      if (!user || user.role !== role) {
        throw new Error(`Access denied. Required role: ${role}`);
      }
      
      return originalMethod.apply(this, args);
    };
    
    return descriptor;
  };
}

class AdminService {
  currentUser = { role: "user", name: "Alice" };
  
  @RequireRole("admin")
  deleteUser(userId: string) {
    console.log(`Deleting user ${userId}`);
    return true;
  }
  
  @RequireRole("user")
  viewProfile() {
    console.log("Viewing profile");
    return { name: "Profile" };
  }
}

const admin = new AdminService();
try {
  admin.deleteUser("123"); // 抛出错误：Access denied
} catch (error) {
  console.error(error.message);
}

admin.viewProfile(); // 成功执行

// 6. 类装饰器和方法的组合使用
function Injectable() {
  return function<T extends { new(...args: any[]): {} }>(constructor: T) {
    // 注册到依赖注入容器
    console.log(`Registered: ${constructor.name}`);
    return class extends constructor {
      // 可以添加注入逻辑
    };
  };
}

function LogMethodCall() {
  return function(
    target: any,
    propertyKey: string,
    descriptor: PropertyDescriptor
  ) {
    console.log(`Method registered: ${propertyKey} in ${target.constructor.name}`);
    return descriptor;
  };
}

@Injectable()
class UserService {
  @LogMethodCall()
  getUsers() {
    return ["Alice", "Bob"];
  }
  
  @LogMethodCall()
  createUser(name: string) {
    return { id: 1, name };
  }
}
```

### 3. 装饰器的执行顺序？

**回答：** 装饰器按特定顺序应用：参数装饰器 → 方法装饰器 → 访问器装饰器 → 属性装饰器 → 类装饰器。
```typescript
// 1. 单个装饰器的执行顺序演示
function DecoratorFactory(name: string) {
  console.log(`${name} factory evaluated`);
  
  return function(...args: any[]) {
    console.log(`${name} decorator called with:`, args.map(arg => 
      typeof arg === 'function' ? arg.name : 
      typeof arg === 'string' ? `"${arg}"` : 
      typeof arg === 'object' ? 'descriptor' : 
      arg
    ));
  };
}

@DecoratorFactory("Class")
class ExampleClass {
  @DecoratorFactory("Property")
  property: string = "";
  
  @DecoratorFactory("Accessor Get")
  get accessor(): string {
    return this.property;
  }
  
  @DecoratorFactory("Accessor Set")
  set accessor(value: string) {
    this.property = value;
  }
  
  @DecoratorFactory("Method")
  method(
    @DecoratorFactory("Parameter") param: string
  ) {}
}

// 输出顺序：
// Property factory evaluated
// Accessor Get factory evaluated
// Accessor Set factory evaluated
// Method factory evaluated
// Parameter factory evaluated
// Class factory evaluated
// Parameter decorator called with: [ExampleClass, "method", 0]
// Method decorator called with: [ExampleClass, "method", descriptor]
// Accessor Set decorator called with: [ExampleClass, "accessor", descriptor]
// Accessor Get decorator called with: [ExampleClass, "accessor", descriptor]
// Property decorator called with: [ExampleClass, "property"]
// Class decorator called with: [ExampleClass]

// 2. 多个装饰器的执行顺序
function A() {
  console.log("A factory");
  return function() { console.log("A applied"); };
}

function B() {
  console.log("B factory");
  return function() { console.log("B applied"); };
}

function C() {
  console.log("C factory");
  return function() { console.log("C applied"); };
}

@A()
@B()
@C()
class MultiDecorated {
  @A()
  @B()
  @C()
  method() {}
}

// 输出顺序：
// A factory (property)
// B factory (property)
// C factory (property)
// A factory (class)
// B factory (class)
// C factory (class)
// C applied (property)
// B applied (property)
// A applied (property)
// C applied (class)
// B applied (class)
// A applied (class)

// 3. 装饰器执行顺序总结：
// 1. 参数装饰器（方法参数）→ 从最后一个参数到第一个参数
// 2. 方法装饰器
// 3. 访问器装饰器（先 setter 后 getter）
// 4. 属性装饰器
// 5. 类装饰器（从离类最近的装饰器开始）
// 对于同一类型的多个装饰器：从下到上应用（离目标最近的先执行）

// 4. 实际应用中的顺序控制
function Order(order: number) {
  return function(
    target: any,
    propertyKey?: string,
    descriptor?: PropertyDescriptor | number
  ) {
    console.log(`Order ${order} executed`);
  };
}

class OrderedExample {
  @Order(1)
  @Order(2)
  @Order(3)
  method() {}
  // 输出：
  // Order 3 executed
  // Order 2 executed
  // Order 1 executed
}

// 5. 使用装饰器元数据控制顺序
function Priority(priority: number) {
  return function(
    target: any,
    propertyKey: string,
    descriptor: PropertyDescriptor
  ) {
    const originalMethod = descriptor.value;
    
    descriptor.value = function(...args: any[]) {
      console.log(`[Priority ${priority}] ${propertyKey} called`);
      return originalMethod.apply(this, args);
    };
    
    return descriptor;
  };
}

class PrioritizedService {
  @Priority(3)
  lowPriority() {
    console.log("Low priority task");
  }
  
  @Priority(1)
  highPriority() {
    console.log("High priority task");
  }
  
  @Priority(2)
  mediumPriority() {
    console.log("Medium priority task");
  }
}

const service = new PrioritizedService();
service.highPriority(); // [Priority 1] highPriority called
service.mediumPriority(); // [Priority 2] mediumPriority called
service.lowPriority(); // [Priority 3] lowPriority called

// 6. 装饰器在继承中的执行
function LogInheritance() {
  return function(constructor: Function) {
    console.log(`${constructor.name} decorated`);
  };
}

@LogInheritance()
class Parent {
  @LogInheritance()
  parentMethod() {}
}

@LogInheritance()
class Child extends Parent {
  @LogInheritance()
  childMethod() {}
}

// 输出：
// parentMethod decorated (Parent)
// Parent decorated
// childMethod decorated (Child)
// Child decorated
```

### 4. 如何实现自定义装饰器？

**回答：** 创建装饰器工厂函数，根据需求返回相应的装饰器函数。
```typescript
// 1. 日志装饰器 - 记录方法调用
function LogCall() {
  return function(
    target: any,
    propertyKey: string,
    descriptor: PropertyDescriptor
  ) {
    const originalMethod = descriptor.value;
    const className = target.constructor.name;
    
    descriptor.value = function(...args: any[]) {
      console.log(`[${className}.${propertyKey}] called with:`, args);
      const result = originalMethod.apply(this, args);
      console.log(`[${className}.${propertyKey}] returned:`, result);
      return result;
    };
    
    return descriptor;
  };
}

class Calculator {
  @LogCall()
  add(a: number, b: number): number {
    return a + b;
  }
  
  @LogCall()
  multiply(a: number, b: number): number {
    return a * b;
  }
}

const calc = new Calculator();
calc.add(2, 3);
calc.multiply(4, 5);

// 2. 验证装饰器 - 验证方法参数
function Validate(
  ...validators: Array<(arg: any) => boolean>
) {
  return function(
    target: any,
    propertyKey: string,
    descriptor: PropertyDescriptor
  ) {
    const originalMethod = descriptor.value;
    
    descriptor.value = function(...args: any[]) {
      // 验证每个参数
      args.forEach((arg, index) => {
        if (validators[index] && !validators[index](arg)) {
          throw new Error(
            `Argument at index ${index} failed validation in ${propertyKey}`
          );
        }
      });
      
      return originalMethod.apply(this, args);
    };
    
    return descriptor;
  };
}

class UserService {
  @Validate(
    (name) => typeof name === 'string' && name.length > 0,
    (age) => typeof age === 'number' && age >= 0
  )
  createUser(name: string, age: number) {
    return { id: Date.now(), name, age };
  }
}

const userService = new UserService();
try {
  userService.createUser("", -5); // 抛出验证错误
} catch (error) {
  console.error(error.message);
}

userService.createUser("Alice", 30); // 成功

// 3. 缓存装饰器 - 缓存方法结果
function Cache(ttl: number = 60000) {
  return function(
    target: any,
    propertyKey: string,
    descriptor: PropertyDescriptor
  ) {
    const originalMethod = descriptor.value;
    const cache = new Map<string, { value: any; expires: number }>();
    
    descriptor.value = function(...args: any[]) {
      const key = JSON.stringify(args);
      const cached = cache.get(key);
      
      if (cached && Date.now() < cached.expires) {
        console.log(`Cache hit for ${propertyKey}`);
        return cached.value;
      }
      
      console.log(`Cache miss for ${propertyKey}`);
      const result = originalMethod.apply(this, args);
      cache.set(key, {
        value: result,
        expires: Date.now() + ttl
      });
      
      return result;
    };
    
    return descriptor;
  };
}

class DataService {
  @Cache(5000) // 缓存5秒
  async fetchData(id: number): Promise<any> {
    console.log(`Fetching data for id: ${id}`);
    await new Promise(resolve => setTimeout(resolve, 100));
    return { id, data: `Data for ${id}` };
  }
}

const dataService = new DataService();
dataService.fetchData(1).then(console.log); // 实际获取
dataService.fetchData(1).then(console.log); // 从缓存获取
setTimeout(() => dataService.fetchData(1).then(console.log), 6000); // 缓存过期，重新获取

// 4. 节流装饰器 - 限制方法调用频率
function Throttle(delay: number) {
  return function(
    target: any,
    propertyKey: string,
    descriptor: PropertyDescriptor
  ) {
    const originalMethod = descriptor.value;
    let lastCall = 0;
    let timeoutId: NodeJS.Timeout | null = null;
    
    descriptor.value = function(...args: any[]) {
      const now = Date.now();
      const timeSinceLastCall = now - lastCall;
      
      if (timeSinceLastCall >= delay) {
        lastCall = now;
        return originalMethod.apply(this, args);
      } else if (!timeoutId) {
        timeoutId = setTimeout(() => {
          lastCall = Date.now();
          originalMethod.apply(this, args);
          timeoutId = null;
        }, delay - timeSinceLastCall);
      }
    };
    
    return descriptor;
  };
}

class EventHandler {
  @Throttle(1000) // 最多每秒调用一次
  handleScroll() {
    console.log("Handling scroll event", Date.now());
  }
}

const handler = new EventHandler();
// 快速多次调用
handler.handleScroll();
handler.handleScroll();
handler.handleScroll();
setTimeout(() => handler.handleScroll(), 1100);

// 5. 依赖注入装饰器
function Inject(token: string) {
  return function(target: any, propertyKey: string) {
    // 在实际的 DI 容器中，这里会记录依赖关系
    console.log(`Property ${propertyKey} needs ${token}`);
    
    // 可以通过属性描述符或元数据来记录
    const metadataKey = `__inject_${propertyKey}`;
    target[metadataKey] = token;
  };
}

class Container {
  private services = new Map();
  
  register(token: string, instance: any) {
    this.services.set(token, instance);
  }
  
  resolve<T>(target: new (...args: any[]) => T): T {
    const instance = new target();
    
    // 查找需要注入的属性
    for (const key in instance) {
      const metadataKey = `__inject_${key}`;
      const token = (target.prototype as any)[metadataKey];
      
      if (token && this.services.has(token)) {
        (instance as any)[key] = this.services.get(token);
      }
    }
    
    return instance;
  }
}

class Logger {
  log(message: string) {
    console.log(`[LOG] ${message}`);
  }
}

class AppService {
  @Inject("logger")
  private logger!: Logger;
  
  doSomething() {
    this.logger.log("Doing something");
  }
}

const container = new Container();
container.register("logger", new Logger());
const app = container.resolve(AppService);
app.doSomething();
```

## 3.9 配置文件

### 1. tsconfig.json 常用配置项有哪些？

**回答：** 配置 TypeScript 编译选项，包括目标版本、模块系统、严格模式等。
```typescript
// tsconfig.json 示例
{
  // 1. 编译选项
  "compilerOptions": {
    // 目标 JavaScript 版本
    "target": "ES2020", // 或 "ES5", "ES6", "ES2015", "ES2020", "ESNext"
    
    // 模块系统
    "module": "commonjs", // 或 "es6", "es2015", "umd", "amd", "system"
    "moduleResolution": "node", // 或 "classic"
    
    // 输出目录和文件
    "outDir": "./dist", // 输出目录
    "rootDir": "./src", // 源文件根目录
    "outFile": "./dist/bundle.js", // 将输出合并为单个文件（仅适用于 amd 或 system）
    
    // 严格类型检查
    "strict": true, // 启用所有严格类型检查选项
    "noImplicitAny": true, // 禁止隐式的 any 类型
    "strictNullChecks": true, // 严格的 null 检查
    "strictFunctionTypes": true, // 严格的函数类型检查
    "strictBindCallApply": true, // 严格的 bind/call/apply 检查
    "strictPropertyInitialization": true, // 严格的属性初始化检查
    "noImplicitThis": true, // 禁止隐式的 this
    "alwaysStrict": true, // 以严格模式解析并输出 "use strict"
    
    // 额外的检查
    "noUnusedLocals": true, // 报告未使用的局部变量
    "noUnusedParameters": true, // 报告未使用的参数
    "noImplicitReturns": true, // 检查函数是否有隐式返回
    "noFallthroughCasesInSwitch": true, // 检查 switch 语句是否完整
    
    // 模块解析
    "baseUrl": "./", // 基础目录
    "paths": { // 路径映射
      "@/*": ["src/*"],
      "components/*": ["src/components/*"]
    },
    "typeRoots": ["./node_modules/@types"], // 类型声明文件位置
    "types": ["node", "jest"], // 包含的类型声明包
    
    // 源映射
    "sourceMap": true, // 生成 source map 文件
    "inlineSources": true, // 将源代码包含到 source maps 中
    "sourceRoot": "/", // 指定调试器定位 TypeScript 文件的位置
    
    // 实验性功能
    "experimentalDecorators": true, // 启用装饰器
    "emitDecoratorMetadata": true, // 为装饰器生成元数据
    
    // 其他
    "declaration": true, // 生成 .d.ts 声明文件
    "declarationMap": true, // 为 .d.ts 文件生成 source map
    "removeComments": true, // 移除注释
    "preserveConstEnums": true, // 保留 const enum 声明
    
    // JS 相关
    "allowJs": true, // 允许编译 JavaScript 文件
    "checkJs": true, // 在 .js 文件中报告错误
    "jsx": "react", // 支持 JSX
    "jsxFactory": "React.createElement", // JSX 工厂函数
    
    // 库文件
    "lib": ["ES2020", "DOM"], // 编译时包含的库文件
    
    // 兼容性
    "downlevelIteration": true, // 为迭代器提供更好的兼容性
    "esModuleInterop": true, // 改善 CommonJS/ES6 模块的互操作性
    "allowSyntheticDefaultImports": true, // 允许从没有默认导出的模块进行默认导入
    
    // 性能
    "incremental": true, // 启用增量编译
    "tsBuildInfoFile": "./build/.tsbuildinfo" // 增量编译信息文件位置
  },
  
  // 2. 包含的文件
  "include": [
    "src/**/*" // 包含 src 目录下的所有文件
  ],
  
  // 3. 排除的文件
  "exclude": [
    "node_modules", // 排除 node_modules
    "dist", // 排除输出目录
    "**/*.test.ts", // 排除测试文件
    "**/*.spec.ts"
  ],
  
  // 4. 继承配置
  "extends": "./tsconfig.base.json", // 继承基础配置
  
  // 5. 文件引用
  "files": [ // 明确指定要编译的文件
    "src/main.ts",
    "src/app.ts"
  ],
  
  // 6. 编译选项引用
  "references": [ // 项目引用（用于 monorepo）
    { "path": "./packages/shared" },
    { "path": "./packages/core" }
  ]
}

// 7. 实际应用：不同环境的配置
// tsconfig.base.json（基础配置）
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "commonjs",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true
  }
}

// tsconfig.json（开发配置）
{
  "extends": "./tsconfig.base.json",
  "compilerOptions": {
    "sourceMap": true,
    "outDir": "./dist",
    "declaration": true,
    "declarationMap": true
  },
  "include": ["src/**/*"]
}

// tsconfig.prod.json（生产配置）
{
  "extends": "./tsconfig.base.json",
  "compilerOptions": {
    "outDir": "./dist",
    "removeComments": true,
    "sourceMap": false,
    "declaration": false
  },
  "include": ["src/**/*"]
}

// 8. 实际应用：monorepo 配置
// packages/app/tsconfig.json
{
  "extends": "../../tsconfig.base.json",
  "compilerOptions": {
    "outDir": "./dist",
    "rootDir": "./src",
    "composite": true, // 启用项目引用
    "declaration": true,
    "declarationMap": true
  },
  "references": [
    { "path": "../shared" } // 引用共享包
  ],
  "include": ["src/**/*"]
}

// 9. 实际应用：React 项目配置
{
  "compilerOptions": {
    "target": "es5",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noFallthroughCasesInSwitch": true,
    "module": "esnext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true, // 让打包工具处理输出
    "jsx": "react-jsx"
  },
  "include": ["src"]
}

// 10. 使用命令行编译
// tsc --project tsconfig.json
// tsc --build // 构建项目引用
// tsc --watch // 监视模式
```

### 2. 编译目标和模块的区别？

**回答：** `target` 指定输出的 JavaScript 版本，`module` 指定模块系统。
```typescript
// 1. target - 输出 JavaScript 版本
// tsconfig.json
{
  "compilerOptions": {
    // ES5: 支持 IE11 等旧浏览器
    "target": "ES5",
    
    // ES6/ES2015: 支持现代浏览器，Node.js 6+
    // "target": "ES6",
    
    // ES2020: 支持最新特性
    // "target": "ES2020",
    
    // ESNext: 最新的 ECMAScript 特性
    // "target": "ESNext"
  }
}

// TypeScript 代码
class Person {
  private name: string;
  
  constructor(name: string) {
    this.name = name;
  }
  
  greet() {
    return `Hello, ${this.name}!`;
  }
}

// 编译为 ES5 输出
// var Person = /** @class */ (function () {
//     function Person(name) {
//         this.name = name;
//     }
//     Person.prototype.greet = function () {
//         return "Hello, " + this.name + "!";
//     };
//     return Person;
// }());

// 编译为 ES6+ 输出
// class Person {
//     constructor(name) {
//         this.name = name;
//     }
//     greet() {
//         return `Hello, ${this.name}!`;
//     }
// }

// 2. module - 模块系统
{
  "compilerOptions": {
    // CommonJS: Node.js 默认模块系统
    "module": "commonjs",
    
    // ES6/ES2015: 现代 JavaScript 模块
    // "module": "es6",
    
    // AMD: 浏览器异步模块定义
    // "module": "amd",
    
    // UMD: 通用模块定义
    // "module": "umd",
    
    // System: SystemJS 模块
    // "module": "system",
    
    // ESNext: 最新的模块特性
    // "module": "esnext"
  }
}

// TypeScript 模块代码
// math.ts
export function add(a: number, b: number): number {
  return a + b;
}

export const PI = 3.14159;

// app.ts
import { add, PI } from './math';

console.log(add(2, 3));

// 编译为 CommonJS 输出
// math.js
// exports.add = function(a, b) { return a + b; };
// exports.PI = 3.14159;

// app.js
// const math_1 = require("./math");
// console.log(math_1.add(2, 3));

// 编译为 ES6 模块输出
// math.js
// export function add(a, b) { return a + b; }
// export const PI = 3.14159;

// app.js
// import { add, PI } from './math';
// console.log(add(2, 3));

// 3. target 和 module 的组合
{
  "compilerOptions": {
    // 现代浏览器/Node.js 14+
    "target": "ES2020",
    "module": "ES2020",
    
    // Node.js 应用
    "target": "ES2020",
    "module": "commonjs",
    
    // 浏览器库（UMD）
    "target": "ES5",
    "module": "umd",
    
    // 现代前端应用（使用打包工具）
    "target": "ES2015",
    "module": "esnext"
  }
}

// 4. 实际应用：Node.js 项目
// tsconfig.json
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "commonjs", // Node.js 使用 CommonJS
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true
  }
}

// 5. 实际应用：浏览器库
{
  "compilerOptions": {
    "target": "ES5", // 兼容旧浏览器
    "module": "umd", // 支持多种模块系统
    "outDir": "./dist",
    "declaration": true,
    "lib": ["dom", "es5", "es2015.promise"]
  }
}

// 6. 实际应用：现代前端应用（使用 Webpack/Vite）
{
  "compilerOptions": {
    "target": "ES2015", // 现代浏览器支持
    "module": "ESNext", // 让打包工具处理模块
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true, // 更好的打包性能
    "noEmit": true // 让打包工具处理输出
  }
}

// 7. moduleResolution - 模块解析策略
{
  "compilerOptions": {
    "moduleResolution": "node", // 推荐：模拟 Node.js 的模块解析
    
    // "moduleResolution": "classic", // 传统方式（已过时）
  }
}

// 8. esModuleInterop - 改善模块互操作性
{
  "compilerOptions": {
    "esModuleInterop": true, // 推荐：改善 CommonJS/ES6 模块的互操作
    "allowSyntheticDefaultImports": true // 允许从没有默认导出的模块进行默认导入
  }
}

// 没有 esModuleInterop 时：
// import * as React from 'react'; // 正确
// import React from 'react'; // 错误：React 没有默认导出

// 有 esModuleInterop 时：
// import React from 'react'; // 正确：自动创建默认导出

// 9. 实际应用：根据环境选择配置
// package.json
{
  "scripts": {
    "build": "tsc",
    "build:prod": "tsc --project tsconfig.prod.json",
    "build:esm": "tsc --project tsconfig.esm.json"
  }
}

// tsconfig.esm.json (ES 模块)
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "module": "ES2020",
    "outDir": "./dist/esm"
  }
}

// tsconfig.cjs.json (CommonJS)
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "module": "commonjs",
    "outDir": "./dist/cjs"
  }
}
```

### 3. 严格模式包含哪些检查？

**回答：** 严格模式是一系列类型检查选项的集合，确保代码类型安全。
```typescript
// tsconfig.json 中的严格模式
{
  "compilerOptions": {
    // 启用所有严格检查
    "strict": true,
    
    // 等价于单独启用以下所有选项：
    // "noImplicitAny": true,
    // "strictNullChecks": true,
    // "strictFunctionTypes": true,
    // "strictBindCallApply": true,
    // "strictPropertyInitialization": true,
    // "noImplicitThis": true,
    // "alwaysStrict": true
  }
}

// 1. noImplicitAny - 禁止隐式的 any 类型
function implicitAnyExample(param) { // 错误：参数隐式具有 'any' 类型
  return param;
}

function explicitAnyExample(param: any) { // 正确：显式声明 any
  return param;
}

function typedExample(param: string) { // 正确：明确类型
  return param;
}

// 2. strictNullChecks - 严格的 null 检查
let name: string;
// name = null; // 错误：不能将 null 分配给 string
// name = undefined; // 错误：不能将 undefined 分配给 string

let nullableName: string | null | undefined;
nullableName = null; // 正确
nullableName = undefined; // 正确
nullableName = "Alice"; // 正确

// 可选参数和属性
interface User {
  name?: string; // 等价于 string | undefined
}

function greet(user: User) {
  // console.log(user.name.toUpperCase()); // 错误：可能为 undefined
  if (user.name) {
    console.log(user.name.toUpperCase()); // 正确：类型守卫
  }
  console.log(user.name?.toUpperCase()); // 正确：可选链
}

// 3. strictFunctionTypes - 严格的函数类型检查
type Handler = (request: string) => void;

function handle(handler: Handler) {
  handler("request");
}

// 协变（宽松）检查
const stringHandler = (request: string) => console.log(request);
const anyHandler = (request: any) => console.log(request);
const objectHandler = (request: object) => console.log(request);

handle(stringHandler); // 正确
handle(anyHandler); // 正确（any 是特殊的）
// handle(objectHandler); // 错误：string 不能赋值给 object

// 4. strictBindCallApply - 严格的 bind/call/apply 检查
function add(a: number, b: number): number {
  return a + b;
}

// 宽松模式下可以，严格模式下错误
// add.call(undefined, "1", "2"); // 错误：参数类型不匹配
// add.apply(undefined, ["1", "2"]); // 错误：参数类型不匹配
// add.bind(undefined, "1")("2"); // 错误：参数类型不匹配

add.call(undefined, 1, 2); // 正确
add.apply(undefined, [1, 2]); // 正确
add.bind(undefined, 1)(2); // 正确

// 5. strictPropertyInitialization - 严格的属性初始化检查
class User {
  name: string; // 错误：属性没有初始化表达式
  age: number | undefined; // 正确：显式包含 undefined
  
  constructor(name: string) {
    this.name = name; // 如果在构造函数中初始化，则正确
  }
}

class User2 {
  name!: string; // 使用非空断言（谨慎使用）
  
  init(name: string) {
    this.name = name;
  }
}

// 6. noImplicitThis - 禁止隐式的 this
class Counter {
  count = 0;
  
  increment() {
    // 严格模式下 this 类型明确
    this.count++;
  }
  
  // 错误：'this' 隐式具有类型 'any'
  // printCount() {
  //   console.log(this.count);
  // }
  
  // 正确：显式指定 this 类型
  printCount(this: Counter) {
    console.log(this.count);
  }
}

// 7. alwaysStrict - 以严格模式解析并输出 "use strict"
// 输出文件会包含 "use strict"; 指令

// 8. 额外的严格检查选项
{
  "compilerOptions": {
    // 报告未使用的局部变量
    "noUnusedLocals": true,
    
    // 报告未使用的参数
    "noUnusedParameters": true,
    
    // 检查函数是否有隐式返回
    "noImplicitReturns": true,
    
    // 检查 switch 语句是否完整
    "noFallthroughCasesInSwitch": true,
    
    // 检查不可达代码
    "allowUnreachableCode": false,
    
    // 检查未使用的标签
    "allowUnusedLabels": false
  }
}

// 9. 实际应用：启用所有严格检查
{
  "compilerOptions": {
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true,
    "allowUnreachableCode": false,
    "allowUnusedLabels": false
  }
}

// 10. 逐步启用严格模式
// 阶段1：基础严格检查
{
  "compilerOptions": {
    "noImplicitAny": true,
    "strictNullChecks": true
  }
}

// 阶段2：启用更多检查
{
  "compilerOptions": {
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true
  }
}

// 阶段3：启用所有检查
{
  "compilerOptions": {
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true
  }
}
```

### 4. 路径映射如何配置？

**回答：** 使用 `baseUrl` 和 `paths` 配置模块路径别名。
```typescript
// tsconfig.json 路径映射配置
{
  "compilerOptions": {
    // 1. baseUrl - 基础目录
    "baseUrl": "./", // 相对于 tsconfig.json 的目录
    
    // 2. paths - 路径映射
    "paths": {
      // 简单别名
      "@/*": ["src/*"],
      
      // 具体路径映射
      "components/*": ["src/components/*"],
      "utils/*": ["src/utils/*"],
      "styles/*": ["src/styles/*"],
      "assets/*": ["src/assets/*"],
      
      // 通配符后缀
      "helpers/*": ["src/helpers/*", "src/shared/helpers/*"],
      
      // 精确匹配
      "config": ["src/config/index.ts"],
      "constants": ["src/constants/index.ts"],
      
      // 相对路径映射
      "../shared/*": ["../shared/src/*"] // 跨项目引用
    },
    
    // 3. 其他相关配置
    "moduleResolution": "node", // 必须使用 node 模块解析
    "rootDirs": ["src", "generated"], // 虚拟目录
    "typeRoots": ["./node_modules/@types", "./types"] // 类型声明位置
  }
}

// 4. 使用路径别名
// 传统相对路径导入（容易出错）
import { Button } from "../../../components/Button";
import { formatDate } from "../../../utils/date";
import { API_URL } from "../../../config";

// 使用路径别名（更清晰）
import { Button } from "components/Button";
import { formatDate } from "utils/date";
import { API_URL } from "config";

// 使用 @ 别名（Vue/React 常见）
import { UserService } from "@/services/UserService";
import { useAuth } from "@/hooks/useAuth";
import "@/styles/global.css";

// 5. 实际应用：React 项目配置
{
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"],
      "components/*": ["src/components/*"],
      "pages/*": ["src/pages/*"],
      "hooks/*": ["src/hooks/*"],
      "utils/*": ["src/utils/*"],
      "services/*": ["src/services/*"],
      "styles/*": ["src/styles/*"],
      "types/*": ["src/types/*"]
    }
  }
}

// 6. 实际应用：Node.js 项目配置
{
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"],
      "controllers/*": ["src/controllers/*"],
      "services/*": ["src/services/*"],
      "models/*": ["src/models/*"],
      "middlewares/*": ["src/middlewares/*"],
      "utils/*": ["src/utils/*"],
      "config/*": ["src/config/*"]
    }
  }
}

// 7. 实际应用：monorepo 配置
// packages/app/tsconfig.json
{
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@app/*": ["src/*"],
      "@shared/*": ["../shared/src/*"], // 引用其他包
      "@ui/*": ["../ui/src/*"]
    }
  }
}

// 8. 路径映射与打包工具集成
// webpack.config.js
const path = require('path');

module.exports = {
  resolve: {
    alias: {
      '@': path.resolve(__dirname, 'src'),
      'components': path.resolve(__dirname, 'src/components'),
      'utils': path.resolve(__dirname, 'src/utils')
    }
  }
};

// vite.config.ts
import { defineConfig } from 'vite';
import path from 'path';

export default defineConfig({
  resolve: {
    alias: {
      '@': path.resolve(__dirname, 'src'),
      'components': path.resolve(__dirname, 'src/components')
    }
  }
});

// 9. 使用 rootDirs 创建虚拟目录
{
  "compilerOptions": {
    "rootDirs": [
      "src/views",
      "generated/views" // 编译时视为同一个目录
    ]
  }
}

// src/views/home.ts 可以导入 generated/views/components/Header.ts
// 就好像它们在同一目录中

// 10. 处理第三方库类型
{
  "compilerOptions": {
    "paths": {
      // 为没有类型定义的库提供自定义类型
      "untyped-lib": ["./types/untyped-lib.d.ts"],
      
      // 覆盖第三方库的类型
      "some-library": ["./types/custom-some-library.d.ts"]
    }
  }
}

// 11. 使用 references 进行项目引用
// tsconfig.json
{
  "references": [
    { "path": "./packages/shared" },
    { "path": "./packages/core" }
  ],
  "compilerOptions": {
    "composite": true,
    "baseUrl": ".",
    "paths": {
      "@shared/*": ["packages/shared/src/*"],
      "@core/*": ["packages/core/src/*"]
    }
  }
}

// 12. 路径映射错误排查
// 常见问题：
// - 路径不存在：检查 baseUrl 和 paths 配置
// - 模块未找到：确保文件扩展名正确
// - 类型错误：检查 .d.ts 文件是否存在

// 13. 动态导入支持
async function loadModule() {
  // 路径别名也支持动态导入
  const module = await import('@/components/Button');
  return module;
}

// 14. 使用 tsconfig-paths 在运行时解析路径
// 在 Node.js 中使用路径别名
// 安装：npm install tsconfig-paths
// 在入口文件添加：
require('tsconfig-paths/register');
// 或使用命令行：
// node -r tsconfig-paths/register dist/app.js
```

### 5. 如何处理第三方库的类型声明？

**回答：** 使用 DefinitelyTyped 类型声明、自定义声明文件或 `skipLibCheck` 选项。
```typescript
// 1. 使用 @types 包（DefinitelyTyped）
// 安装类型声明
// npm install --save-dev @types/react @types/node @types/lodash

// 在代码中使用
import React from 'react';
import lodash from 'lodash';
import fs from 'fs';

// TypeScript 会自动找到 node_modules/@types 中的类型声明

// 2. 查看已安装的类型声明
// package.json
{
  "devDependencies": {
    "@types/react": "^18.0.0",
    "@types/node": "^18.0.0",
    "@types/lodash": "^4.14.0"
  }
}

// 3. 没有类型声明的库的处理方式

// 方法A：使用 declare module（推荐）
// types/custom-library.d.ts
declare module 'custom-library' {
  export function doSomething(input: string): string;
  export const version: string;
  export default function init(options: any): void;
}

// 使用
import init, { doSomething, version } from 'custom-library';

// 方法B：使用 require 和类型断言
const lib = require('untyped-lib') as {
  method: () => void;
  value: string;
};

// 方法C：使用 import 和类型断言
import * as untypedLib from 'untyped-lib';
const typedLib = untypedLib as any;

// 方法D：创建完整的类型声明文件
// types/untyped-lib/index.d.ts
declare namespace UntypedLib {
  interface Options {
    timeout?: number;
    retry?: boolean;
  }
  
  function initialize(options?: Options): void;
  function process(data: any): any;
}

export = UntypedLib;

// 4. 扩展第三方库的类型
// types/express.d.ts
import { Request } from 'express';

declare global {
  namespace Express {
    interface Request {
      user?: {
        id: string;
        name: string;
      };
    }
  }
}

// 5. 覆盖第三方库的类型
// 如果第三方库的类型定义有误，可以创建自定义类型
// types/corrected-library.d.ts
declare module 'incorrect-typed-library' {
  // 重新导出正确的类型
  export function correctFunction(param: string): number;
  export const correctConstant: boolean;
}

// 6. 使用三斜线指令引用类型
// app.d.ts
/// <reference path="./custom-types.d.ts" />
/// <reference types="node" />

// 7. 配置 typeRoots 和 types
{
  "compilerOptions": {
    // 指定类型声明文件的位置
    "typeRoots": [
      "./node_modules/@types", // 默认位置
      "./types", // 自定义类型目录
      "./src/types" // 项目类型目录
    ],
    
    // 只包含指定的类型声明
    "types": [
      "node",
      "jest",
      "react",
      "react-dom"
      // 不包含其他 @types 包
    ]
  }
}

// 8. 跳过库的类型检查
{
  "compilerOptions": {
    "skipLibCheck": true // 跳过所有 .d.ts 文件的类型检查
  }
}

// 9. 实际应用：处理模块增强
// 为第三方库添加自定义功能
// types/axios-custom.d.ts
import { AxiosRequestConfig } from 'axios';

declare module 'axios' {
  export interface AxiosRequestConfig {
    customConfig?: {
      retry?: number;
      cache?: boolean;
    };
  }
}

// 10. 实际应用：处理 CSS 模块
// types/css-modules.d.ts
declare module '*.module.css' {
  const classes: { [key: string]: string };
  export default classes;
}

declare module '*.module.scss' {
  const classes: { [key: string]: string };
  export default classes;
}

// 使用
import styles from './Button.module.css';
console.log(styles.button);

// 11. 实际应用：处理图片和资源
declare module '*.png' {
  const value: string;
  export default value;
}

declare module '*.jpg' {
  const value: string;
  export default value;
}

declare module '*.svg' {
  const value: string;
  export default value;
}

declare module '*.json' {
  const value: any;
  export default value;
}

// 12. 使用 declare global 扩展全局类型
declare global {
  interface Window {
    MY_APP: {
      version: string;
      init: () => void;
    };
  }
  
  const __DEV__: boolean;
  const __VERSION__: string;
}

// 13. 处理 CommonJS 模块
// 对于导出 module.exports 的 CommonJS 模块
declare module 'commonjs-library' {
  // 使用 export = 语法
  function mainFunction(): void;
  export = mainFunction;
}

// 或
declare module 'commonjs-library' {
  namespace MyLib {
    export function doSomething(): void;
    export const version: string;
  }
  
  export = MyLib;
}

// 14. 创建 types 目录结构
// types/
//   custom-library/
//     index.d.ts
//   global.d.ts
//   images.d.ts
//   css-modules.d.ts
//   express/
//     index.d.ts

// 15. 发布类型声明
// 如果开发自己的库，可以在 package.json 中指定类型
{
  "name": "my-library",
  "version": "1.0.0",
  "main": "dist/index.js",
  "types": "dist/index.d.ts", // 类型声明文件位置
  "typings": "dist/index.d.ts" // 别名，和 types 相同
}

// 16. 使用 JSDoc 为 JavaScript 库添加类型
// 对于 .js 文件，可以使用 JSDoc 注释
// @ts-check
/** @type {import('./types').User} */
const user = getUser();

/** @type {(a: number, b: number) => number} */
function add(a, b) {
  return a + b;
}
```

## 3.10 实战与优化

### 1. 如何处理循环引用问题？

**回答：** 重构代码结构、使用接口/类型前置声明、动态导入或依赖注入。
```typescript
// 1. 循环引用示例（会导致问题）
// user.ts
import { Post } from './post';

export class User {
  constructor(public name: string) {}
  
  getPosts(): Post[] {
    // 需要 Post 类型
    return [];
  }
}

// post.ts  
import { User } from './user';

export class Post {
  constructor(public author: User, public content: string) {}
}

// 2. 解决方案A：使用接口/类型前置声明
// types.ts（定义共享接口）
export interface IUser {
  name: string;
  getPosts(): IPost[];
}

export interface IPost {
  author: IUser;
  content: string;
}

// user.ts
import { IPost } from './types';

export class User implements IUser {
  constructor(public name: string) {}
  
  getPosts(): IPost[] {
    return [];
  }
}

// post.ts
import { IUser } from './types';

export class Post implements IPost {
  constructor(public author: IUser, public content: string) {}
}

// 3. 解决方案B：使用类型导入
// user.ts
import type { Post } from './post'; // 只导入类型，不导入值

export class User {
  constructor(public name: string) {}
  
  getPosts(): Post[] {
    return [];
  }
}

// post.ts
import type { User } from './user'; // 只导入类型

export class Post {
  constructor(public author: User, public content: string) {}
}

// 4. 解决方案C：模块重构
// 将相互依赖的部分提取到第三个模块
// shared-types.ts
export interface UserData {
  name: string;
}

export interface PostData {
  author: UserData;
  content: string;
}

// user.ts
import { PostData } from './shared-types';

export class User {
  constructor(public name: string) {}
  
  getPosts(): PostData[] {
    return [];
  }
}

// post.ts
import { UserData } from './shared-types';

export class Post {
  constructor(public author: UserData, public content: string) {}
}

// 5. 解决方案D：使用函数延迟依赖
// user.ts
export class User {
  constructor(public name: string) {}
  
  // 使用工厂函数延迟 Post 的创建
  createPost(content: string): any {
    // 动态导入或使用工厂
    return { author: this, content };
  }
}

// 6. 解决方案E：依赖注入
// user.ts
export interface PostFactory {
  createPost(author: User, content: string): any;
}

export class User {
  constructor(
    public name: string,
    private postFactory?: PostFactory
  ) {}
  
  createPost(content: string) {
    if (this.postFactory) {
      return this.postFactory.createPost(this, content);
    }
    return null;
  }
}

// 7. 解决方案F：使用命名空间
// app.ts
namespace App {
  export interface IUser {
    name: string;
  }
  
  export interface IPost {
    author: IUser;
    content: string;
  }
}

// user.ts
namespace App {
  export class User implements IUser {
    constructor(public name: string) {}
  }
}

// post.ts
namespace App {
  export class Post implements IPost {
    constructor(public author: IUser, public content: string) {}
  }
}

// 8. 解决方案G：使用 barrel 文件（索引文件）
// 创建 barrel 文件可能导致循环引用，要小心使用
// index.ts
export { User } from './user';
export { Post } from './post';

// 9. 实际应用：服务层循环引用
// auth-service.ts 需要 user-service
// user-service.ts 需要 auth-service

// 解决方案：提取共享类型到独立的文件
// types/auth.ts
export interface AuthPayload {
  userId: string;
  token: string;
}

// types/user.ts
export interface UserProfile {
  id: string;
  name: string;
  email: string;
}

// 10. 实际应用：React 组件循环引用
// ComponentA.tsx 导入 ComponentB
// ComponentB.tsx 导入 ComponentA

// 解决方案：提取共享逻辑到 hooks
// useSharedLogic.ts
import { useState } from 'react';

export function useSharedLogic() {
  const [value, setValue] = useState('');
  return { value, setValue };
}

// 11. 使用动态导入解决运行时依赖
async function loadUserModule() {
  const { User } = await import('./user');
  return User;
}

async function loadPostModule() {
  const { Post } = await import('./post');
  return Post;
}

// 12. 使用 TypeScript 3.8+ 的 import type
// 确保只导入类型，不导入运行时依赖
import type { User } from './user';
import type { Post } from './post';

export function createRelationship(user: User, post: Post) {
  // 只使用类型，不实例化
  return { user, post };
}

// 13. 配置 tsconfig.json 检测循环引用
{
  "compilerOptions": {
    // 检测循环引用（需要 TypeScript 4.4+）
    // "noUncheckedSideEffectImports": true
  }
}

// 14. 使用工具检测循环引用
// 安装：npm install -g madge
// 检测：madge --circular src/

// 15. 架构设计建议
// - 遵循依赖倒置原则（DIP）
// - 使用依赖注入容器
// - 分层架构（表现层、业务层、数据层）
// - 事件驱动架构减少直接依赖
```

### 2. 如何优化 TypeScript 编译性能？

**回答：** 使用增量编译、项目引用、适当配置、缓存等策略。
```typescript
// 1. 启用增量编译
{
  "compilerOptions": {
    "incremental": true, // 启用增量编译
    "tsBuildInfoFile": "./build/.tsbuildinfo" // 编译信息文件位置
    
    // 或使用复合选项（包含 incremental）
    // "composite": true
  }
}

// 2. 使用项目引用（适合 monorepo）
// tsconfig.json（根配置）
{
  "references": [
    { "path": "./packages/core" },
    { "path": "./packages/shared" },
    { "path": "./packages/app" }
  ],
  "files": [] // 根配置不直接编译文件
}

// packages/core/tsconfig.json
{
  "extends": "../../tsconfig.base.json",
  "compilerOptions": {
    "composite": true, // 启用项目引用
    "outDir": "./dist",
    "rootDir": "./src"
  },
  "references": [
    { "path": "../shared" } // 依赖其他项目
  ]
}

// 编译命令：
// tsc --build // 构建所有项目（智能增量）
// tsc --build --force // 强制重新构建

// 3. 优化 include/exclude 配置
{
  // 明确指定包含的文件
  "include": [
    "src/**/*.ts",
    "src/**/*.tsx"
  ],
  
  // 排除不必要的文件
  "exclude": [
    "node_modules",
    "dist",
    "build",
    "coverage",
    "**/*.test.ts",
    "**/*.spec.ts",
    "**/*.stories.tsx",
    "**/__tests__/**",
    "**/__mocks__/**"
  ],
  
  // 或明确指定文件
  // "files": [
  //   "src/main.ts",
  //   "src/app.ts"
  // ]
}

// 4. 优化编译器选项
{
  "compilerOptions": {
    // 跳过库的类型检查（谨慎使用）
    "skipLibCheck": true,
    
    // 跳过声明文件的类型检查
    "skipDefaultLibCheck": true,
    
    // 禁用源映射（生产环境）
    "sourceMap": false,
    "inlineSourceMap": false,
    "declarationMap": false,
    
    // 移除注释（生产环境）
    "removeComments": true,
    
    // 禁用声明文件生成（如果不发布库）
    "declaration": false,
    
    // 禁用增量相关文件（如果不需要）
    "incremental": false,
    
    // 简单的模块解析
    "moduleResolution": "node",
    
    // 禁用严格的元数据发射
    "emitDecoratorMetadata": false
  }
}

// 5. 使用 isolatedModules（适合打包工具）
{
  "compilerOptions": {
    "isolatedModules": true // 确保每个文件都能独立编译
  }
}

// 6. 配置 typeRoots 和 types
{
  "compilerOptions": {
    // 限制类型声明搜索范围
    "typeRoots": ["./node_modules/@types"],
    
    // 只包含必要的类型声明
    "types": [
      "node",
      "react",
      "react-dom"
      // 明确列出，而不是包含所有
    ]
  }
}

// 7. 使用 tsc --watch 的优化
// 在开发时使用监视模式
// tsc --watch --preserveWatchOutput

// 使用并发编译
// 在 package.json 中配置
{
  "scripts": {
    "dev": "tsc --watch --preserveWatchOutput & nodemon dist/app.js",
    "build": "tsc"
  }
}

// 8. 使用第三方工具加速
// 使用 esbuild 或 swc 进行转译（保留类型检查）
// esbuild 配置示例：
// esbuild.config.js
const esbuild = require('esbuild');

esbuild.build({
  entryPoints: ['src/index.ts'],
  bundle: true,
  outfile: 'dist/bundle.js',
  platform: 'node',
  target: 'node14',
  sourcemap: true
}).catch(() => process.exit(1));

// 9. 缓存策略
// 使用持久化缓存
// 配合 webpack 的缓存
// webpack.config.js
module.exports = {
  cache: {
    type: 'filesystem',
    cacheDirectory: path.resolve(__dirname, '.webpack_cache')
  }
};

// 10. 代码分割和懒加载
// 使用动态导入减少初始编译量
async function loadFeature() {
  const feature = await import('./heavy-feature');
  feature.init();
}

// 11. 避免大型类型操作
// 避免深度嵌套的复杂类型
// 避免过多的条件类型
// 使用 interface 而不是复杂的 type

// 12. 使用项目引用进行增量构建
// 只构建更改的项目
// tsc --build packages/core

// 13. 监控编译性能
// 使用 --extendedDiagnostics 查看详细统计
// tsc --extendedDiagnostics

// 输出示例：
// Files:                        1234
// Lines:                      123456
// Nodes:                      456789
// Identifiers:                234567
// Symbols:                    345678
// Types:                      567890
// Memory used:               1234567K
// I/O read:                   0.01s
// I/O write:                  0.02s
// Parse time:                 0.12s
// Bind time:                  0.05s
// Check time:                 0.34s
// Emit time:                  0.08s
// Total time:                 0.59s

// 14. 升级 TypeScript 版本
// 新版本通常有性能改进
// 定期升级到最新稳定版

// 15. 代码结构优化
// 减少文件数量（适当合并）
// 减少导入数量
// 使用 barrel 文件要谨慎（可能影响性能）

// 16. 使用工具分析
// 安装 typescript-coverage-report
// npx typescript-coverage-report

// 使用 @typescript/analyze-trace
// tsc --generateTrace traceDir
// npx @typescript/analyze-trace traceDir
```

### 3. 类型体操是什么？

**回答：** 使用 TypeScript 的类型系统进行复杂类型操作和转换，实现类型级别的编程。
```typescript
// 1. 基本类型操作
// 字符串操作
type Greeting = "Hello, World";
type UppercaseGreeting = Uppercase<Greeting>; // "HELLO, WORLD"
type LowercaseGreeting = Lowercase<Greeting>; // "hello, world"
type CapitalizedGreeting = Capitalize<Greeting>; // "Hello, world"
type UncapitalizedGreeting = Uncapitalize<"Hello">; // "hello"

// 2. 条件类型
type IsString<T> = T extends string ? true : false;
type Test1 = IsString<"hello">; // true
type Test2 = IsString<123>; // false

// 3. 递归类型
// 创建元组类型
type Tuple<N extends number, T = any, R extends any[] = []> = 
  R['length'] extends N ? R : Tuple<N, T, [...R, T]>;

type FiveNumbers = Tuple<5, number>; // [number, number, number, number, number]

// 4. 模板字面量类型
type Route<Path extends string> = 
  Path extends `/${infer Rest}` ? `api${Path}` : never;

type ApiRoute = Route<"/users">; // "api/users"

// 5. 类型推断
type First<T extends any[]> = T extends [infer F, ...any[]] ? F : never;
type Last<T extends any[]> = T extends [...any[], infer L] ? L : never;

type FirstItem = First<[1, 2, 3]>; // 1
type LastItem = Last<[1, 2, 3]>; // 3

// 6. 映射类型高级用法
// 将属性变为 getter
type Getters<T> = {
  [K in keyof T as `get${Capitalize<string & K>}`]: () => T[K];
};

type Person = { name: string; age: number };
type PersonGetters = Getters<Person>;
// { getName: () => string; getAge: () => number; }

// 7. 过滤属性
type FilterProperties<T, U> = {
  [K in keyof T as T[K] extends U ? K : never]: T[K];
};

type User = { id: number; name: string; age: number; email: string };
type StringProps = FilterProperties<User, string>; // { name: string; email: string; }

// 8. 深度修改类型
type DeepReadonly<T> = {
  readonly [K in keyof T]: T[K] extends object ? DeepReadonly<T[K]> : T[K];
};

type DeepPartial<T> = {
  [K in keyof T]?: T[K] extends object ? DeepPartial<T[K]> : T[K];
};

// 9. 联合类型操作
type UnionToIntersection<U> = 
  (U extends any ? (k: U) => void : never) extends ((k: infer I) => void) ? I : never;

type Union = { a: number } | { b: string };
type Intersection = UnionToIntersection<Union>; // { a: number } & { b: string }

// 10. 元组类型操作
type Reverse<T extends any[]> = 
  T extends [infer First, ...infer Rest] ? [...Reverse<Rest>, First] : [];

type Reversed = Reverse<[1, 2, 3]>; // [3, 2, 1]

// 11. 实际应用：路由类型安全
type ExtractParams<Path> = 
  Path extends `${string}:${infer Param}/${infer Rest}`
    ? Param | ExtractParams<`/${Rest}`>
    : Path extends `${string}:${infer Param}`
    ? Param
    : never;

type RouteParams = ExtractParams<"/users/:userId/posts/:postId">;
// "userId" | "postId"

// 12. 实际应用：表单验证类型
type ValidationRule<T> = (value: T) => string | null;

type FormValidation<T> = {
  [K in keyof T]?: ValidationRule<T[K]>;
};

type UserForm = { name: string; age: number; email: string };
type UserValidation = FormValidation<UserForm>;
// { name?: ValidationRule<string>; age?: ValidationRule<number>; email?: ValidationRule<string>; }

// 13. 实际应用：API 响应类型
type ApiResponse<T, E = string> = 
  | { success: true; data: T }
  | { success: false; error: E };

type UserResponse = ApiResponse<{ id: number; name: string }>;

function handleResponse(response: UserResponse) {
  if (response.success) {
    console.log(response.data.name); // 类型安全
  } else {
    console.error(response.error);
  }
}

// 14. 类型安全的 EventEmitter
type EventMap = {
  click: { x: number; y: number };
  change: { value: string };
  load: void;
};

type EventEmitter<T extends Record<string, any>> = {
  on<K extends keyof T>(
    event: K,
    listener: (data: T[K]) => void
  ): void;
  
  emit<K extends keyof T>(
    event: K,
    data: T[K]
  ): void;
};

// 15. 挑战：实现 Promise.all 的类型
type PromiseAll<T extends readonly any[]> = 
  T extends readonly [infer First, ...infer Rest]
    ? [First extends Promise<infer R> ? R : First, ...PromiseAll<Rest>]
    : [];

// 使用
const promises = [Promise.resolve(1), Promise.resolve("hello"), Promise.resolve(true)] as const;
type Result = PromiseAll<typeof promises>; // [number, string, boolean]
```

### 4. 如何处理动态属性？

**回答：** 使用索引签名、Record 类型、映射类型或类型断言。
```typescript
// 1. 索引签名 - 处理未知属性
interface DynamicObject {
  [key: string]: string | number;
}

const obj: DynamicObject = {
  name: "John",
  age: 30,
  city: "NY" // 可以动态添加
};

// 2. Record 类型
type UserData = Record<string, any>;

const userData: UserData = {
  id: 1,
  name: "Alice",
  preferences: {
    theme: "dark",
    notifications: true
  }
};

// 3. 部分已知属性 + 动态属性
interface User {
  id: number;
  name: string;
  [key: string]: any; // 允许其他属性
}

const user: User = {
  id: 1,
  name: "Bob",
  age: 25, // 动态属性
  email: "bob@example.com" // 动态属性
};

// 4. 类型安全的动态属性访问
function getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {
  return obj[key];
}

const person = { name: "Alice", age: 30 };
const name = getProperty(person, "name"); // string
const age = getProperty(person, "age"); // number
// const invalid = getProperty(person, "gender"); // 错误

// 5. 运行时类型检查
function safeGet<T>(obj: any, key: string): T | undefined {
  if (key in obj) {
    return obj[key] as T;
  }
  return undefined;
}

const value = safeGet<string>(userData, "name");

// 6. 使用 keyof 和映射类型
type DynamicForm<T> = {
  values: T;
  errors: Partial<Record<keyof T, string>>;
  touched: Partial<Record<keyof T, boolean>>;
};

interface LoginForm {
  username: string;
  password: string;
  rememberMe: boolean;
}

const form: DynamicForm<LoginForm> = {
  values: {
    username: "",
    password: "",
    rememberMe: false
  },
  errors: {
    username: "Required" // 类型安全
  },
  touched: {
    username: true
  }
};

// 7. 处理来自 API 的动态数据
interface ApiResponse {
  success: boolean;
  data?: Record<string, any>;
  error?: string;
}

async function fetchData(): Promise<ApiResponse> {
  const response = await fetch('/api/data');
  const data = await response.json();
  
  // 运行时验证
  if (data && typeof data === 'object' && 'success' in data) {
    return data as ApiResponse;
  }
  
  throw new Error("Invalid API response");
}

// 8. 使用类型守卫
function isUser(obj: any): obj is { name: string; age: number } {
  return (
    obj &&
    typeof obj.name === 'string' &&
    typeof obj.age === 'number'
  );
}

function processData(data: any) {
  if (isUser(data)) {
    console.log(data.name, data.age); // 类型安全
  }
}

// 9. 索引访问类型
type User = {
  id: number;
  name: string;
  email: string;
  age: number;
};

type UserKeys = keyof User; // "id" | "name" | "email" | "age"
type UserValues = User[keyof User]; // number | string

function getValue<T, K extends keyof T>(obj: T, key: K): T[K] {
  return obj[key];
}

// 10. 动态创建类型
type DynamicType<T extends string> = {
  [K in T]: K;
};

type Colors = DynamicType<"red" | "green" | "blue">;
// { red: "red"; green: "green"; blue: "blue"; }

// 11. 处理枚举的动态属性
enum Status {
  Pending = "pending",
  Active = "active",
  Inactive = "inactive"
}

type StatusConfig = Record<Status, { color: string; icon: string }>;

const config: StatusConfig = {
  [Status.Pending]: { color: "yellow", icon: "⏳" },
  [Status.Active]: { color: "green", icon: "✅" },
  [Status.Inactive]: { color: "gray", icon: "❌" }
};

// 12. 使用泛型约束
function mergeObjects<T extends Record<string, any>>(
  obj1: T,
  obj2: Partial<T>
): T {
  return { ...obj1, ...obj2 };
}

const base = { a: 1, b: "hello" };
const merged = mergeObjects(base, { b: "world" }); // { a: 1, b: "world" }

// 13. 实际应用：配置对象
interface AppConfig {
  api: {
    baseUrl: string;
    timeout: number;
  };
  features: Record<string, boolean>;
  [key: string]: any; // 允许扩展
}

const config: AppConfig = {
  api: {
    baseUrl: "https://api.example.com",
    timeout: 5000
  },
  features: {
    darkMode: true,
    analytics: false
  },
  customSetting: "value" // 动态属性
};

// 14. 使用 as const 获得字面量类型
const routes = {
  home: "/",
  about: "/about",
  contact: "/contact"
} as const;

type RouteKeys = keyof typeof routes; // "home" | "about" | "contact"
type RouteValues = typeof routes[RouteKeys]; // "/" | "/about" | "/contact"

// 15. 动态属性与静态属性结合
class DynamicClass {
  private data: Record<string, any> = {};
  
  set<T>(key: string, value: T): void {
    this.data[key] = value;
  }
  
  get<T>(key: string): T | undefined {
    return this.data[key] as T;
  }
  
  has(key: string): boolean {
    return key in this.data;
  }
}
```

### 6. TypeScript 4.0+ 新增了哪些特性？

**回答：** 可变元组类型、标签元组元素、构造器的类属性推断等。
```typescript
// 1. 可变元组类型（Variadic Tuple Types） - TS 4.0
type Strings = [string, string];
type Numbers = [number, number];

// 创建组合类型
type StringNumberPairs = [...Strings, ...Numbers]; // [string, string, number, number]

function concat<T extends any[], U extends any[]>(
  arr1: [...T],
  arr2: [...U]
): [...T, ...U] {
  return [...arr1, ...arr2];
}

const result = concat([1, 2], ["a", "b"]); // [number, number, string, string]

// 2. 标签元组元素（Labeled Tuple Elements） - TS 4.0
type Point = [x: number, y: number];
type Range = [start: number, end: number];

function createPoint(x: number, y: number): Point {
  return [x, y]; // 元组元素有标签
}

// 3. 构造器的类属性推断 - TS 4.0
class Square {
  // TypeScript 4.0 可以推断 area 为 number
  area;
  
  constructor(public sideLength: number) {
    this.area = sideLength * sideLength;
  }
}

// 4. 短路赋值运算符 - TS 4.0
// a &&= b 等价于 a = a && b
// a ||= b 等价于 a = a || b  
// a ??= b 等价于 a = a ?? b

let x = 0;
let y = "";
let z: string | null = null;

x &&= 5; // x = 0 && 5 → 0
y ||= "default"; // y = "" || "default" → "default"
z ??= "default"; // z = null ?? "default" → "default"

// 5. catch 子句的 unknown 类型 - TS 4.0
try {
  // 可能抛出错误
} catch (error: unknown) { // TS 4.0 前是 any，现在是 unknown
  // 需要类型检查
  if (error instanceof Error) {
    console.log(error.message);
  }
}

// 6. 模板字面量类型 - TS 4.1
type HttpMethod = "GET" | "POST" | "PUT" | "DELETE";
type ApiEndpoint = `${HttpMethod} /api/${string}`;

const endpoint: ApiEndpoint = "GET /api/users"; // 正确
// const invalid: ApiEndpoint = "PATCH /api/users"; // 错误

// 7. 键重映射（Key Remapping） - TS 4.1
type Getters<T> = {
  [K in keyof T as `get${Capitalize<string & K>}`]: () => T[K];
};

type User = { name: string; age: number };
type UserGetters = Getters<User>;
// { getName: () => string; getAge: () => number; }

// 8. 递归条件类型 - TS 4.1
type Awaited<T> = T extends Promise<infer U> ? Awaited<U> : T;

type Result = Awaited<Promise<Promise<string>>>; // string

// 9. 抽象构造签名 - TS 4.2
abstract class Animal {
  abstract makeSound(): void;
}

function createAnimal(AnimalClass: abstract new () => Animal) {
  // 可以接受抽象类
  // 但不能实例化
}

// 10. 前置/后置条件断言 - TS 4.3
function assertIsString(value: unknown): asserts value is string {
  if (typeof value !== "string") {
    throw new Error("Not a string");
  }
}

function doSomething(value: unknown) {
  assertIsString(value); // 断言后，value 是 string
  console.log(value.toUpperCase());
}

// 11. 静态索引签名 - TS 4.3
class Users {
  static cache: { [id: string]: User } = {};
  
  static get(id: string): User | undefined {
    return this.cache[id];
  }
}

// 12. override 关键字 - TS 4.3
class Base {
  greet() {
    console.log("Hello!");
  }
}

class Derived extends Base {
  override greet() { // 明确表示重写
    console.log("Hi!");
  }
  
  // override greet(name: string) { // 错误：没有匹配的基类方法
  //   console.log(`Hi ${name}!`);
  // }
}

// 13. 模板字符串类型改进 - TS 4.4
type Color = "red" | "green" | "blue";
type EventName = `on${Capitalize<Color>}Click`;

const event: EventName = "onRedClick"; // 正确

// 14. 控制流分析改进 - TS 4.4
function example(value: unknown) {
  if (typeof value === "string") {
    // value 是 string
    console.log(value.toUpperCase());
  } else if (Array.isArray(value)) {
    // value 是 any[]
    console.log(value.length);
  }
}

// 15. 更严格的复合选项 - TS 4.5
// tsc --strict --exactOptionalPropertyTypes
interface User {
  name: string;
  age?: number; // 明确区分 undefined 和缺失
}

const user: User = { name: "Alice" };
// user.age = undefined; // 错误（严格模式下）

// 16. 导入类型中的 type 修饰符 - TS 4.5
import { type User, createUser } from "./user";
// 明确表示 User 是类型导入

// 17. Awaited 类型 - TS 4.5
type P1 = Promise<string>;
type R1 = Awaited<P1>; // string

type P2 = Promise<Promise<string>>;
type R2 = Awaited<P2>; // string

// 18. 模板字符串类型推断 - TS 4.5
type ExtractRoute<T> = 
  T extends `${infer Method} ${infer Path}` 
    ? { method: Method; path: Path }
    : never;

type Route = ExtractRoute<"GET /api/users">;
// { method: "GET"; path: "/api/users" }

// 19. 新的模块设置 - TS 4.7
// module: "node16" 或 "nodenext"
// 更好地支持 ESM 和 CommonJS 互操作

// 20. 实例化表达式 - TS 4.7
function createArray<T>(): T[] {
  return [];
}

// 创建特定类型的数组工厂
const stringArray = createArray<string>; // () => string[]
const numberArray = createArray<number>; // () => number[]

const strings = stringArray(); // string[]
const numbers = numberArray(); // number[]
```

### 7. 如何实现类型安全的 EventEmitter？

**回答：** 使用泛型和映射类型，确保事件名和回调函数参数的类型安全。
```typescript
// 1. 类型安全的 EventEmitter 实现
type EventMap = Record<string, any>;

class TypedEventEmitter<T extends EventMap> {
  private listeners: {
    [K in keyof T]?: Array<(data: T[K]) => void>;
  } = {};

  // 添加事件监听器
  on<K extends keyof T>(event: K, listener: (data: T[K]) => void): void {
    if (!this.listeners[event]) {
      this.listeners[event] = [];
    }
    this.listeners[event]!.push(listener);
  }

  // 移除事件监听器
  off<K extends keyof T>(event: K, listener: (data: T[K]) => void): void {
    const eventListeners = this.listeners[event];
    if (eventListeners) {
      const index = eventListeners.indexOf(listener);
      if (index > -1) {
        eventListeners.splice(index, 1);
      }
    }
  }

  // 触发事件
  emit<K extends keyof T>(event: K, data: T[K]): void {
    const eventListeners = this.listeners[event];
    if (eventListeners) {
      // 复制数组，防止在回调中修改监听器数组
      eventListeners.slice().forEach(listener => listener(data));
    }
  }

  // 一次性监听器
  once<K extends keyof T>(event: K, listener: (data: T[K]) => void): void {
    const onceListener = (data: T[K]) => {
      listener(data);
      this.off(event, onceListener);
    };
    this.on(event, onceListener);
  }

  // 移除所有监听器
  removeAllListeners<K extends keyof T>(event?: K): void {
    if (event) {
      delete this.listeners[event];
    } else {
      this.listeners = {};
    }
  }
}

// 2. 使用示例
// 定义事件类型
interface AppEvents {
  click: { x: number; y: number };
  change: string;
  load: void; // 无参数事件
  error: Error;
  data: { id: number; value: string };
}

// 创建 EventEmitter 实例
const emitter = new TypedEventEmitter<AppEvents>();

// 添加监听器（类型安全）
emitter.on('click', (data) => {
  console.log(`Clicked at (${data.x}, ${data.y})`);
});

emitter.on('change', (value) => {
  console.log(`Value changed to: ${value}`);
});

emitter.on('load', () => {
  console.log('Loaded');
});

// 触发事件（类型安全）
emitter.emit('click', { x: 100, y: 200 });
emitter.emit('change', 'new value');
emitter.emit('load', undefined); // void 事件需要 undefined

// 错误示例（会被 TypeScript 捕获）
// emitter.on('click', (data: string) => {}); // 错误：参数类型不匹配
// emitter.emit('click', { x: '100', y: 200 }); // 错误：x 应该是 number
// emitter.emit('unknown', {}); // 错误：未知事件

// 3. 一次性监听器
emitter.once('data', (data) => {
  console.log(`Received data once: ${data.id} - ${data.value}`);
});

emitter.emit('data', { id: 1, value: 'test' }); // 触发
emitter.emit('data', { id: 2, value: 'test2' }); // 不会触发（监听器已移除）

// 4. 移除监听器
const changeListener = (value: string) => {
  console.log(`Change: ${value}`);
};

emitter.on('change', changeListener);
emitter.off('change', changeListener);

// 5. 实际应用：UI 组件事件
interface ButtonEvents {
  click: { target: HTMLElement; timestamp: number };
  hover: { isHovering: boolean };
  focus: void;
}

class Button {
  private emitter = new TypedEventEmitter<ButtonEvents>();
  
  onClick() {
    this.emitter.emit('click', {
      target: document.createElement('button'),
      timestamp: Date.now()
    });
  }
  
  onHover(isHovering: boolean) {
    this.emitter.emit('hover', { isHovering });
  }
  
  // 暴露 EventEmitter 方法
  addEventListener<K extends keyof ButtonEvents>(
    event: K,
    listener: (data: ButtonEvents[K]) => void
  ) {
    this.emitter.on(event, listener);
  }
  
  removeEventListener<K extends keyof ButtonEvents>(
    event: K,
    listener: (data: ButtonEvents[K]) => void
  ) {
    this.emitter.off(event, listener);
  }
}

// 6. 实际应用：状态管理
interface StoreEvents<T> {
  change: { oldState: T; newState: T };
  action: { type: string; payload: any };
  error: { action: string; error: Error };
}

class Store<T> {
  private state: T;
  private emitter = new TypedEventEmitter<StoreEvents<T>>();
  
  constructor(initialState: T) {
    this.state = initialState;
  }
  
  dispatch(action: { type: string; payload: any }) {
    const oldState = this.state;
    // 更新状态（简化示例）
    this.emitter.emit('action', action);
    
    // 模拟状态变化
    const newState = { ...oldState, ...action.payload };
    this.state = newState;
    
    this.emitter.emit('change', { oldState, newState });
  }
  
  subscribe(listener: (data: { oldState: T; newState: T }) => void) {
    this.emitter.on('change', listener);
    return () => this.emitter.off('change', listener);
  }
  
  getState(): T {
    return this.state;
  }
}

// 7. 支持异步监听器
class AsyncEventEmitter<T extends EventMap> extends TypedEventEmitter<T> {
  async emitAsync<K extends keyof T>(event: K, data: T[K]): Promise<void> {
    const eventListeners = this.listeners[event];
    if (eventListeners) {
      const promises = eventListeners.map(listener => 
        Promise.resolve(listener(data)).catch(error => {
          console.error(`Error in ${String(event)} listener:`, error);
        })
      );
      await Promise.all(promises);
    }
  }
}

// 8. 支持通配符监听器
interface ExtendedEventMap extends EventMap {
  '*': { event: string; data: any };
}

class ExtendedEventEmitter<T extends EventMap> extends TypedEventEmitter<T & ExtendedEventMap> {
  emit<K extends keyof T>(event: K, data: T[K]): void {
    super.emit(event, data);
    super.emit('*', { event: String(event), data });
  }
}

// 9. 性能优化版本（使用 WeakMap 存储监听器）
class OptimizedEventEmitter<T extends EventMap> {
  private listeners = new WeakMap<object, Map<keyof T, Array<(data: any) => void>>>();
  private target = {};
  
  on<K extends keyof T>(event: K, listener: (data: T[K]) => void): void {
    let eventMap = this.listeners.get(this.target);
    if (!eventMap) {
      eventMap = new Map();
      this.listeners.set(this.target, eventMap);
    }
    
    let eventListeners = eventMap.get(event);
    if (!eventListeners) {
      eventListeners = [];
      eventMap.set(event, eventListeners);
    }
    
    eventListeners.push(listener);
  }
  
  emit<K extends keyof T>(event: K, data: T[K]): void {
    const eventMap = this.listeners.get(this.target);
    if (eventMap) {
      const eventListeners = eventMap.get(event);
      if (eventListeners) {
        eventListeners.forEach(listener => listener(data));
      }
    }
  }
}

// 10. 使用 Proxy 实现更灵活的 EventEmitter
function createEventEmitter<T extends EventMap>(): TypedEventEmitter<T> {
  return new TypedEventEmitter<T>();
}

// 创建类型安全的 EventEmitter 工厂
const appEmitter = createEventEmitter<AppEvents>();
```

### 8. d.ts 的作用

**回答：** 声明文件，用于描述 JavaScript 库的类型信息，不包含实现。
```typescript
// 1. 声明文件的基本结构
// my-library.d.ts

// 声明变量
declare const VERSION: string;
declare let DEBUG: boolean;

// 声明函数
declare function greet(name: string): string;

// 声明类
declare class Calculator {
  constructor();
  add(a: number, b: number): number;
  subtract(a: number, b: number): number;
  static readonly PI: number;
}

// 声明接口
declare interface Point {
  x: number;
  y: number;
}

// 声明类型别名
declare type Coordinates = [number, number];

// 声明命名空间
declare namespace MathUtils {
  function add(a: number, b: number): number;
  function multiply(a: number, b: number): number;
  const PI: number;
}

// 声明模块
declare module "my-module" {
  export function doSomething(): void;
  export const importantValue: number;
  export default class MainClass {
    constructor(config: any);
    run(): void;
  }
}

// 2. 全局声明
// global.d.ts
declare global {
  // 扩展 Window 接口
  interface Window {
    myApp: {
      version: string;
      init(): void;
    };
  }
  
  // 扩展 String 原型
  interface String {
    toTitleCase(): string;
  }
  
  // 声明全局变量
  const APP_NAME: string;
  
  // 声明全局函数
  function formatDate(date: Date): string;
}

// 3. 模块声明
// 为没有类型定义的库创建声明
declare module "untyped-library" {
  export function initialize(options: any): void;
  export function process(data: any): any;
  export const version: string;
  export default function main(): void;
}

// 4. 模块增强
// 扩展第三方库的类型
declare module "axios" {
  export interface AxiosRequestConfig {
    customConfig?: {
      retry?: number;
      cache?: boolean;
    };
  }
}

// 扩展 Express
declare module "express" {
  interface Request {
    user?: {
      id: string;
      name: string;
    };
  }
}

// 5. 三斜线指令
/// <reference types="node" /> // 引用 @types/node
/// <reference path="./custom-types.d.ts" /> // 引用其他声明文件
/// <reference lib="es2015.promise" /> // 引用内置库声明

// 6. 条件类型声明
// 根据文件类型提供不同的类型
declare module "*.module.css" {
  const classes: { [className: string]: string };
  export default classes;
}

declare module "*.module.scss" {
  const classes: { [className: string]: string };
  export default classes;
}

declare module "*.png" {
  const value: string;
  export default value;
}

declare module "*.jpg" {
  const value: string;
  export default value;
}

declare module "*.svg" {
  import React = require("react");
  export const ReactComponent: React.FC<React.SVGProps<SVGSVGElement>>;
  const src: string;
  export default src;
}

declare module "*.json" {
  const value: any;
  export default value;
}

// 7. 合并声明
// 接口可以合并
interface User {
  name: string;
}

// 在另一个文件中
interface User {
  age: number;
}

// 最终 User 接口包含 name 和 age

// 8. 命名空间声明
declare namespace MyLibrary {
  export interface Config {
    apiUrl: string;
    timeout: number;
  }
  
  export function initialize(config: Config): void;
  export function doSomething(): void;
  export const version: string;
}

// 9. 类型导出
// 导出类型供其他文件使用
export { User, Product, Order } from "./types";

// 重新导出
export * from "./interfaces";
export { default as UserService } from "./services/UserService";

// 10. 实际应用：为 jQuery 创建声明
// jquery.d.ts
declare namespace JQuery {
  interface AjaxSettings {
    url: string;
    type?: string;
    data?: any;
    success?: (data: any, textStatus: string, jqXHR: JQuery.jqXHR) => void;
    error?: (jqXHR: JQuery.jqXHR, textStatus: string, errorThrown: string) => void;
  }
  
  interface Static {
    ajax(settings: AjaxSettings): JQuery.jqXHR;
    (selector: string): JQueryInstance;
    (readyCallback: () => void): void;
  }
  
  interface JQueryInstance {
    addClass(className: string): this;
    removeClass(className: string): this;
    html(): string;
    html(content: string): this;
    on(event: string, handler: (event: JQuery.Event) => void): this;
  }
  
  namespace Event {
    interface OriginalEvent {
      preventDefault(): void;
      stopPropagation(): void;
    }
  }
  
  interface jqXHR {
    done(callback: (data: any, textStatus: string, jqXHR: jqXHR) => void): jqXHR;
    fail(callback: (jqXHR: jqXHR, textStatus: string, errorThrown: string) => void): jqXHR;
  }
}

declare const $: JQuery.Static;
declare const jQuery: JQuery.Static;

// 11. 使用 declare 避免运行时错误
// 描述已存在的全局变量
declare const process: {
  env: {
    NODE_ENV: 'development' | 'production' | 'test';
    [key: string]: string | undefined;
  };
};

// 使用
if (process.env.NODE_ENV === 'development') {
  console.log('Development mode');
}

// 12. 在项目中使用 .d.ts 文件
// types/ 目录结构：
// types/
//   index.d.ts          # 主声明文件
//   global.d.ts         # 全局声明
//   images.d.ts         # 图片模块声明
//   css-modules.d.ts    # CSS 模块声明
//   express/           # Express 类型扩展
//     index.d.ts
//   custom-library/    # 自定义库声明
//     index.d.ts

// tsconfig.json 配置：
{
  "compilerOptions": {
    "typeRoots": ["./node_modules/@types", "./types"]
  }
}
```
