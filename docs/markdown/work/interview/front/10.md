# 九、JS场景题


## 9.1 面试题1

### 1.优化自己的面试

- 被问到场景题，怎么应对，SOP（流程化 -- SOP）

    1. 交代背景
    2. 调研方案（要有多个）
    3. 方案落地
    4. 反思，追求最优解

- 举例:当面试官问到：1000w 行表格如何渲染？

    维格表、飞书表格、钉钉表格、在线表格最求大数据量

    ```md
    1. 数据足够大，大数据公司，需要在前端展示大量数据，以往防卡顿，所以我们想要通过更好方案实现

    2. 我作为责任人，调研这部分方案

        1. dom
        2. 虚拟表格
        3. canvas table
        4. 可视区绘制算法优化
        5. canvas 结合 Webassembly 技术实现 （skia + Webassembly）

    3. 我封装了画布表格引擎，解决了上述问题，并且实现 1000W 数据加载流畅交互

    4. 在这个过程中遇到了哪些问题，我是怎么解决问题的
    ```
### 2.js 超过Number 最大值的数怎么处理？

- `Number.MAX_VALUE` 可以打印出数据

- 用到的方向：

    1. 大数据的计算：由前端计算数据得到
    2. 格式展示：后端传到前端的数据
    3. 用户输入：表格输入组件（像input输入框）

- 大数据处理
    - 金融 （数据敏感）
    - 科学计算 （小数乘小数）
    - 数据分析 （小数超出32位）

- 解决方案
    - BigInt

        ```js
        const bigNum = BigInt("1515513155151513151515151515151515")

        bigNum + bigNum
        ```
    - decimal.js

        ```js
        const decimal = new Decimal("1e+308")
        ```
    - big.js

- 比如我们用户输入场景需要限制大小
- 总结：
    1. bigint 处理大数据
    2. decimal 来处理
    3. 格式化，格式化成用户好读的格式 1000000000, 1亿
    4. 表达校验，不允许用户输入超过多少位的数字

### 3.大文件上传

背景作为佐证，不像是网上抄来的。
我之前是做AI 产品方面的，我们会涉及到用户自定义**模型**（1G 以上）

- 经常遇到一些问题：
    
    - 网络断开之后，之前传的没了
    - 传着传着，网络波动了，结果啥都没了
    - 关机了，想接着传，做不到
- 专业术语：

    - 断点续传
    - 断开重连重传
    - 切片上传

- 方案：

    - 前端切片 chunk 1024M(1048576K)，500K, const size = 1048576/500
    - 将切片传递给后端，切的片要取名： hash,index
    - 后端组合切片
- 给面试官加料

    - 前端切片：主进程卡顿，web-worker 多线程切片，处理完成后交给主进程发送
    - 切完后，将 blob ，存储到 IndexedDB，下次用户进来之后，嗅探以下是否存在未完成上传的切片，有就常识继续上传
    - websocket,实时通知，和请求序列的控制 wss
    - 整体说一下是我主导这个大文件上传器整体设计

        - 组件设计
        - props、事件、状态
        - 拖拽上传、多文件选择
        - 通用化不同文件的上传，上传统一协议

- 代码落地

    ```js
    const CHUNK_SIZE = 5 * 1024 * 1024;// 每块大小为5MB
    function uploadFile(){
        const file = document.getElementById("fileInput").files[0];
        if(!file){
            flert("请选择文件");
            return;
        }

        const totalChunk = Math.ceil(file.size/ChUNK_SIZE);
        let currentChunk = 0;
        function uploadChunk(){
            if(currentChunk >= totalCHunks){
                console.log("Upload complete");
                return;
            }

            const start = currentChunk * CHUNK_SIZE;
            const end = Math.min(start + CHUNK_SIZE,file.size);
            const chunk = file.slice(start,end)

            const formData = new FormData();
            formData.append("file",chunk);
            formData.append("chunkNumber",currentChunk + 1);
            formData.append("totalChunks",totaolChunks);

            fetch("/upload",{
                method:"POST",
                body: formData
            }).then(reponse =>{
                if(response.ok){
                    currentChunk++;
                    uploadCHunk(); // 递归调用上传下一块
                } else{
                    console.error("Chunk upload failed");
                }
            }).catch(error =>{
                console.error("Upload error",error)
            });
        }

        uploadChunk();
    }
    ```

### 4.在前端怎么实现页面截图

- 背景

    - 飞书文档，内容在列表页想要查看
    - 内容导出为 png
    - 射击类软件，出图

- 以内容导出为 png 来详解

    - 医疗，医疗单子
    - 文档，导出文档
- 方案

    - 截图
        - canvas
        - puppeteer (无头headless 浏览器)、无头表格、无头UI
        - html2canvas (canvas)
    - 上传CDN

- 落地

    - 截图工具的时候，需要考虑通用性， `selector` body(全页面截图)，.header(局部截图)、dom
    - 设计具体协议
        - 函数式、组件式
        - 隐藏canvas
    - 代码编写

        - 安装插件

            ```bash
            pnpm i html2canvas
            ```
        - 使用函数

            ```js
            function takeScreenshot(){
                const element = document.getElementById('screenshot-target');
                html2canvas(element).then(canvas =>{
                    const img = canvas.toDataURL("image/png")
                    const link = document.createElement("a");
                    link.href = img;
                    link.download = 'screenshot.png';
                    link.click();
                })
            }
            ```
### 5.H5 移动端适配问题如何解决

- 背景：项目想支持 PC、移动端
- 方案

    - 根据端来开发不同页面（成本最高）
    - 根据不同端加载不同 css 样式（可取）
    - 根据响应式，来运行不同的样式规则（**常用**）
    - style 预处理器来做

- 考虑的问题：
    1. 设置视窗，通过元信息配置 meta

        ```html
        <meta name="viewport" content="width=device-width,initial-scale=1.0">
        ```
    2. 掌握媒体查询

        ```css
        body{
            font-size:16px;
        }

        /* 在某一些设备尺寸下，这个 size 是要更改的 */
        /* 当我的尺寸 大于 xxx 小于 xxx 的时候，需要什么样式？ */
        @media(min-width:780px) and (max-width:1024px){
            body{
                font-size:18px;
            }
        }
        ```
    3. 弹性布局（flex 布局）
        - 主轴方向：flex-derection
        - 对齐方式：justify-content,align-items
        - 弹性属性：flex
    
    4. 图片响应式

        ```html
        <picture>
            <source srcset="image-large.jpg" media="(min-width:800px)">
            <source srcset="image-medium.jpg" media="(min-width:400px)">
            <img src="image-small.jpg" alt="Responsive Image">
        <picture>
        ```
    5. rem

        rem 单位的基础值 有 html 的font-size 决定

        ```css
        html{
            font-size:16px;
        }
        /* 1rem 现在等于多少 */
        .header{
            font-size:1rem; 
        }
        ```
    6. em单位

        ```css
        html{
            font-size:16px;
        }
        /* 1rem 现在等于多少 */
        .header_title{
            font-size: 0.8em 
        }
        ```
### 6.如何修改第三方的包

1. 背景

    难言之隐，来自于设计、产品、老板boss
2. 方案

    - 稳定版，直接拔下来，node_modules,直接修改
    - patch 方案

        - `patch-package`

            ```sh
            pnpm i patch-package postinstall
            ```     

        - npm 有很多钩子

            - prepare
            - postinstall
            - publish
            - ... npm hook

        - package.json

            ```json
            {
                "scripts":{
                    "postinstall":"patch-package"
                }
            }
            ```
        - 创建补丁

            ```bash
            npx patch-package rspack
            ```

            这个时候会在项目生成 `patches/rspack+1.0.0.patch`

    - fork package（自己来维护）

        直接改源码。源码改完之后，构建，发布到 npm 私服（verdaccio、阿里云效制品库）

        修改的一些内容，如果想共享给社区，给原来的作者提 PR、code review、test、合并了，你的代码就贡献给社区，提升知名度

### 7. 使用同一个连接，如何实现 PC 打开是 web应用、手机打开是一个 H5应用

1. 背景

    为了不增加ip，一个链家访问页面，想同时适配 PC、Mobile.

2. 方案

    区分 PC、Mobile，抓不要矛盾，二元对立，判断

    - 先识别端

        1. js 识别，userAgent

            ```js
            console.log(navigator.useAgent)
            // 判断
            // 正则

            function isMobile(){
                return /Mobi|Andriod/.test(navigator.useAgent)
            }
            if(isMobile()){

            }
            ```
            - react
                ```jsx
                <DeviceProvider value={{type:isMobile()}}></DeviceProvider>

                // 子组件使用
                function Header(){
                    const {type} = useContext(DeviceProvider)
                }
                ```
            - vue

                ```js
                // 非常重要的api
                provide("deviceType",isMObile())

                // 子组件使用
                const devicetype = inject("deviceType")
                ```
    - 端内容渲染器（内容加载器）

        - 媒体查询，flex布局

            ```js
            const App=()=>{
                const isDesktop= useMediaQuery({ minWidth: 1024 });
                const isMobile= useMediaQuery({ maxWidth: 1024 });
                return (

                    <div>
                        {isDesktop && (
                            <div>
                                <h1>Desktop Web Application</h1>
                                <p>This content is displayed on desktop devices.</p>
                            </div>
                        )}
                        {isMobile && (
                            <div>
                                <h1>Mobile H5 Application</h1>
                                <p>This content is displayed on mobile devices.</p>
                            </div>
                        )}
                    </div>      
                );
            }
            export default App;
            ```

### 8. 当QPS 达到峰值时，改如何处理

1. 背景

    当前端应用的QPS (每秒查询次数) 达到峰值时，会对服务器和应用的性能造成很大的压力，甚至可能导致系统崩溃，为了解决这个问题，我们需要采取一系列措施来优化和管理高并发请求

2. 方案

    - 请求限流

        全栈岗位，nodejs 为例，限流。

         <!-- rate-limit -->
         ```js
         const ratelimit = require("express-rate-limit");

         const limiter = rateLimit({
            windowMs:60 * 1000,
            max: 100,
            message: "你搞的太多了，省省，待会儿再来"
         })
         ```
    - 请求合并

        短时间内的请求进行合并，一次降低服务端压力

        - debounce
        - throttle

        ```js
        function debounce(func,delay){
            let timout;
            return function(...args){
                clearTimeout(timeout);
                timeout = setTimeout(()=>func.apply(this,args),delay)
            }
        }

        const fetchData = debounce(()=>{
            fetch("api/data")
                .then(response => response.json())
                .then(data =>{
                    console.log(data);
                })
                .catch(error =>{
                    console.error("Fetch error:",error)
                })
        })

        document.getElementById("fetchButton").addEventListener("click",fetchData);
        ```
    - 请求缓存

        react、vue

        **swr** 里面针对于请求的内容缓存
        请求参数、请求方法、请求逻辑依赖的内容没有花生变化，直接命中缓存

    - 任务队列

        针对于请求，我们设计一个任务队列，通过滑动窗口

        任务 job,视频转码 后端请求 使用 `bull`

        ```js
        const Bull = require("bull")
        const tackQueue = new Bull("task queue");

        app.post("/api/startTask",(req,res)=>{
            const taskId = Date.now().toString();
            taskQueue.add({taskId})
            res.send({taskId});
        })

        app.get("/api/taskStatus/:taskId",(req,res)=>{
            const taskId = req.params.taskId;
            // 检查任务章台并返回
            taskQueue.getJob(taskId).then(job => {
                if(job){
                    res.send({status:job.finished()?"completed":"pending"});
                }else{
                    res.send({status:"not found"})
                }
            })
        })

        /// 处理队列中的任务
        taskQueue.process((job,done)=>{
            // 模拟耗时操作
            setTimout(()=>{
                done();
            },10000); //10秒钟
        })
        ```

### 9. 如何实现网页加载进度条

怎么拿到进度
- 方法兼容性
- fetch、ajax
怎么绘制进度
- dom
- svg

1. 背景

    为了提升整站用户加载等待提亚，考虑使用加载进度条反馈给用户加载工程

2. 方案

    - Ajax 拿到进度，svg/dom 绘制进度

        ```html
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>Loading Progress Bar Example</title>
            <style>
                #progress-bar{
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 4px;
                    background-color: #29d;
                    transition: width 0.4s ease;
                    z-index: 9999;
                }
            </style>
        </head>
        <body>
            <div id="progress-bar"></div>

            </div>
            <script>
                function loadResource(url){
                    const xhr=new XMLHttpRequest();
                    xhr.open('GET',url,true);
                    xhr.onprogress=function(event){
                        if(event.lengthComputable){
                            const percentComplete=(event.loaded/event.total)*100;
                            document.getElementById('progress-bar').style.width=percentComplete+'%';
                        }
                    };
                    xhr.onload = function() {
                        if(xhr.status === 200){
                            document.getElementById('progress-bar').style.width='100%';
                            setTimeout(() => {
                                document.getElementById('progress-bar').style.width='0%';
                            }, 500);
                        }
                    };
                    xhr.send();
                }

                window.addEventListener('load',function(){
                    loadResource('https://jsonplaceholder.typicode.com/posts');
                });
            </script>
        </body>
        </html>
        ```

        fetch 可不可以，不可以

    - 框架页面加载

        - React 页面加载过度进度条

            ```jsx
            import React,{useEffect} from 'react';
            import { BrowerRouter as Router,Route,Switch,useHistory} from "react-router-dom";
            import NProgress from "nprogress"
            import "nprogress/nprogress.css"

            const Home = () => <div>Home</div>;
            const About = () => <div>About</div> ；

            const App = () =>{
                const history = useHistory();

                useEffect(()=>{
                    NProgress.configure({ showSpinner:false });

                    const handleStart = () =>{
                        NProgress.start()
                    };
                    const handleStop = () => {
                        NProgress.done()
                    }

                    history.listen(()=>{
                        handleStart();
                        handleStop();
                    })

                    return () =>{
                        history.listen().cancle()
                    }

                },[history])

                return (
                    <Router>
                        <Switch>
                            <Route path="/" exact component = {Home}>
                            <Route path="/about" exact component = {About}>
                        </Switch>
                    </Router>
                )
            }
            ```
        - Vue 

            通过借助导航守卫

            ```js
            const router = createRouter() // vue-router

            // 全局导航守卫
            router.beforeEach()
            ```

### 10. 了解过前端水印功能

1. 背景

    为了保证用户隐私，数据相对安全，实现水印，飞书（名字）WaterMark
    - 文档保护
    - 图片保护
    - 视频保护

2. 方案

    - 明水印(肉眼可见的水印)

        1. 背景水印

            ```html
            <!DOCTYPE html>
            <html lang="en">
            <head>
                <meta charset="UTF-8">
                <meta name="viewport" content="width=device-width, initial-scale=1.0">
                <title>Page Watermark</title>
                <style>
                    body{
                        background-image:url('data:image/svg+xml;base64,<BASE64_ENCODED_SVG>');
                        background-repeat:repeat;
                        opacity: 0.1;
                    }
                </style>
            </head>
            <body>
                <h1>Watermark Content</h1>
                <p>This page has a watermark background.</p>
            </body>
            </html>
            ```

            内容生成，`svg`

            ```js
            function createWatermarkSVG(text){
                const svg = `
                   <svg xmlns="http://www.w3.org/2000/svg" width="200" height="200" viewBox="0 0 200 200">
                        <text x="50%" y="50%" dy=".35em" text-anchor="middle" fill="rgba(0,0,0,0.1)" font-size="30" tranform="rotate(-45, 100, 100)">
                            ${text}
                        </text>
                    </svg>
                `
                return `data:image/svg+xml;base64,${btoa(svg)}`
            }

            const watermarkText = "知识库"
            document.body.style.background = `url('${createWatermarkSVG(watermarkText)}')`
            ```
        2. 图片水印

            ```html
            <!DOCTYPE html>
            <html lang="en">
            <head>
                <meta charset="UTF-8">
                <meta name="viewport" content="width=device-width, initial-scale=1.0">
                <title>Image Watermark</title>
            </head>
            <body>
                <canvas id="canvas" style="display: none;"></canvas>
                <img id="sourceImage" src="source-image.jpg" alt="Source">
                <img id="watermarkedImag" alt="Watermarked Image">

                <script>
                    function addWatermark(imageSrc, watermarkText) {
                        const canvas = document.getElementById('canvas')
                        const ctx = canvas.getContext('2d')
                        const image = new Image()   
                        image.src = imageSrc
                        image.onload = () => {  
                            canvas.width = image.width
                            canvas.height = image.height
                            ctx.drawImage(image, 0, 0)
                            ctx.font = '48px serif'
                            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)'
                            ctx.fillText(watermarkText, 20, image.height - 60)
                            const watermarkedImage = document.getElementById('watermarkedImag')
                            watermarkedImage.src = canvas.toDataURL()
                        }
                    }

                    const imageSrc = document.getElementById('sourceImage').src;
                    addWatermark(imageSrc, 'Sample Watermark');
                </script>
            </body>
            </html>
            ```
    - 暗水印 (肉眼不可见的)

        黑科技，将信息写入刀文件二进制代码里面

        二进制的编辑处理，保证文件不变化，暗水印服务

### 11. web 应用中如何对静态资源加载失败的场景做降级处理

1. 场景

    - 图片
    - css 文件
    - javascript 文件
    - CDN
    - 字体文件
    - 服务端渲染失败

2. 解决方案

    - 图片处理
        - 占位符，alt 来描述图片
        - 重试机制 (404、无权限)
        - 上报
            ```html
            <img src="image.jpg" alt="Example Image" onerror="handleImageError(this)">
            ```

            ```js
            function handleImageError(image){
                image.onerror = null; // 方式死循环
                image.src = `placeholder.jpg`; // 使用占位图
            }
            ```
    - css 文件处理

        资源没加载到

        1. 关键性样式，通过内联
        2. 备用样式
        3. 上报

        ```html
        <head>
            <style>
                /* 内联关键样式 */
                body {
                    font-family:Arial,sans-serif;
                }
            </style>
            <link rel="stylesheet" href="styles.css" onerror="handleCssError()">
        </head>
        ```

        ```js
        function handleCssError(){
            // 加载备用样式
            const fallbackCss = document.createElement("link");
            fallbackCss.rel = 'stylesheet';
            fallbackCss.href = "fallback-styles.css";
            document.head.appendChild(fallbackCss)
        }
        ```
    - javascript 文件处理

        网络异常，导致资源没加载

        1. 内联脚本
        2. 备用脚本处理
        3. 上报

    - CDN 处理
        1. 本地备份，如果 cdn 出错了，就使用本地备份
        2. 动态切换，切到另一个有用的 cdn 服务

        ```html
        <head>
            <script src="https://cdn.example.com/library.js" onerror="handleCdnError()"></script>
        </head>
        ```

        ```js
        handleCdnError(){
            // 加载本地备份
            const fallbackScript = document.createElement('script');
            fallbackScript.scr = 'local-library.js';
            document.head.appendChild(fallbackScript);

            // 或者动态切换到另一个CDN
            // const alternativeCdn = doucument.createElement("script");
            // alternativeCdn.src = "https://cdn.alternative.com/library.js";
            // document.head.appendChild(alternativeCdn);
        }
        ```

    - 字体

        1. 使用降级字体 apple、微软雅黑
        2. webfont 处理字体问题

            ```css
            @font-face{
                font-family: 'CustomFont';
                src: url("customfont.woff2") format('woff2');
                font-display:swap; /* 使用 swap策略 */
            }

            body{
                font-family:'CustomFont',Arial,sans-serif;
            }
            ```
    - ssr 方面

        1. 降级的 html 用作渲染
        2. 切换为 CSR

### 12. 怎样实际一个全栈请求好事统计工具

1. 背景

    通过这个统计工具，可以更清晰看到整个站点性能情况，首屏加载时间（FP/FCP）,

    1. 监控请求耗时：HTTP、中间件，axios
    2. 前端监控：监控整个请求，记录耗时数据
    3. 后端监控：后端记录
    4. 数据汇总：数据清洗加工，数据可视化，可视化图表

2. 方案

    ```js
    (function(){
        const originalXhrOpen = XMLHttpRequest.prototype.open;
        XMLHttpRequest.prototype.open = function(...args){
            this._startTime = performance.now();
            this.addEventListener("load",function(){
                const duration = performance.now() - this._startTime;
                console.log(`XHR ${args[1]} took ${duration}ms`);
                reportRequestDuration(args[1],duration,"XHR");
            })
            originalXhrOpen.apply(this,args);
        };
        
        const originalFetch = window.fetch;
        window.fetch = async function(...args){
            const startTime = performance.now();
            const reponse = await oraiginalFetch.apply(this,args);
            const duration = performance.now() - startTime;
            console.log(`Fetch ${args[0]} took ${duration}ms`)
            reportRequestDuration(args[0],duration,"Fetch");
        }

        // 通过fetch 上报
        function reportRequestDurution(url, durution, type){
            // Report to backend or log it loaclly
            fetch('/api/report-request-duration'.{
                method: "POST",
                headers: {"Content-Type": 'application/json'},
                body: JSON.stringify({url,duration,type})
            })
        }

        // 通过图片进行上报
        const img = document.createElement('img')
        img.src = "/getRequetInfo"
    })();
    ```

### 13. 请说说你对函数式编程思想的理解

函数式编程，基本概念

1. 基本概念

    - 函数为一等公民，函数封装的方式解决问题
    - 函数概念
        1. 纯函数，没有任何副作用，相同输入（参数）得到相同输出（返回值）

            ```js
            // 纯函数示例
            function add(a,b){
                return a + b;
            }
        2. 不可变性
        3. 高阶函数，函数柯里化

            ```js
            // 高阶函数示例
            function withLogging(fn){
                return function(...args){
                    console.log('Arguments:',args);
                    const result = fn(...args);
                    console.log("Result:",result);
                    return result;
                }
            }

            const addWithLoggging = withLogging(add);
            addWithLoggging(1,2); // logs: Argunments: [1,2], Result: 3
            ```
        4. 函数组合，类似于面向对象继承

            ```js
            // 函数组合示例
            const compose = (...fns) => (x) => fns.reduceRight((v,fn)=>fn(v),x);

            const double = x => x * 2;
            const square = x => x * x;

            const doubleAndSquare = componse(square,double);
            console.log(doubleAndSquare(3)) //36
            ```

            ```js
            const useName = () => 'heyi'
            const useAge = () => 18

            const usePerson = () =>{
                const name = useName()
                const age = useAge()

                return {
                    name,
                    age
                }
            }
            ```

2. 总结优点

    1. 可测试性，更好写单元测试
    2. 可维护性
    3. 并发
    4. 简洁


## 9.2 自己总结的场景题

### 1. 如何优化首屏加载速度


1. 减少资源体积（减小传输量）

    *   **代码压缩与 Tree Shaking**  
        使用 Webpack、Vite 等构建工具对 JS/CSS 进行压缩（minify），并通过 Tree Shaking 去除未使用的代码。
    *   **图片优化**
        *   使用现代格式（WebP/AVIF）替代 JPEG/PNG；
        *   按需加载合适尺寸（响应式图片 + `srcset`）；
        *   使用 CDN 图片裁剪服务；
        *   静态图标优先使用 SVG 或 Icon Font。
    *   **字体优化**  
        使用 `font-display: swap` 避免阻塞渲染，按需加载子集（subset）字体。



2. 减少请求数量（合并 & 按需）

    *   **代码分割（Code Splitting）**  
        利用动态 `import()` 拆分非首屏模块，避免打包成一个大 bundle。
    *   **懒加载（Lazy Load）**  
        非关键组件（如下方内容、弹窗、路由页面）使用 React.lazy / Vue 异步组件延迟加载。
    *   **合并小资源（谨慎使用）**  
        在 HTTP/2 普及后，合并 CSS/JS 不再总是必要，但小图标可考虑雪碧图或内联 SVG。

3. 提升资源加载效率（更快获取资源）

    *   **利用浏览器缓存**
        *   设置合理的 `Cache-Control` 和 ETag；
        *   对静态资源使用哈希命名（如 `app.a1b2c3.js`）实现长期缓存。
    *   **使用 CDN**  
        将静态资源部署到离用户更近的 CDN 节点，降低网络延迟。
    *   **预加载关键资源**
        *   `<link rel="preload">` 加载首屏关键 JS/CSS/字体；
        *   `<link rel="prefetch">` 预加载后续可能用到的资源（如跳转页面）。
    *   **服务端推送（HTTP/2 Server Push）**（较少用，需谨慎）


4. 优化渲染路径（更快看到内容）

    *   **关键渲染路径优化（Critical Rendering Path）**
        *   内联首屏关键 CSS（Critical CSS），避免 CSS 阻塞渲染；
        *   非关键 CSS 异步加载（如通过 `media="print"` hack 或 loadCSS）；
        *   减少 DOM 深度和复杂选择器。
    *   **服务端渲染（SSR）或静态生成（SSG）**  
        如 Next.js、Nuxt.js、VuePress 等，让首屏 HTML 直接包含内容，提升 FCP（First Contentful Paint）。
    *   **骨架屏（Skeleton Screen）**  
        在数据加载前展示 UI 占位，提升感知性能。
    *   **避免大型 JS 阻塞主线程**  
        将非必要逻辑延迟执行（`requestIdleCallback` 或拆分任务）。

5. 监控与持续优化

    *   使用 Lighthouse、WebPageTest、Performance API 监测核心指标（FCP、LCP、TTI）；
    *   建立性能基线，结合 CI/CD 做性能回归检测；
    *   A/B 测试不同优化策略的实际效果。

6.  总结（收尾加分）

    > “在实际项目中，我会先通过 Lighthouse 或 Chrome DevTools 分析瓶颈，再针对性地应用上述策略。比如我们曾通过 SSR + 关键 CSS 内联 + 图片懒加载，将 LCP 从 4.2s 降到 1.5s，显著提升了用户体验和 SEO 排名。”


### 2. 微前端

微前端（Micro Frontends）是一种将前端应用拆分成多个小型、独立、可独立开发、部署和维护的前端子应用的架构模式。它的核心思想是“将微服务理念延伸到前端”。

传统单体前端应用随着业务增长会变得庞大、难以维护，团队协作效率低。而微前端通过将不同功能模块（比如用户中心、商品管理、订单系统等）拆分为独立的子应用，每个子应用可以由不同团队使用不同技术栈（如 React、Vue、Angular 等）独立开发、测试和部署，最后在主应用中集成。

**常见的实现方式包括**：

- iframe 集成：简单但通信和体验较差；
- 模块联邦（Module Federation）：Webpack 5 提供的能力，支持动态加载远程模块；
- Web Components：基于标准组件封装；
- 路由分发 + JS 沙箱：如 qiankun、single-spa 等框架，通过主应用控制路由，动态加载子应用并隔离其运行环境（CSS/JS 沙箱）。

**微前端的优点包括**：

- 提升团队自治与交付效率；
- 技术栈无关，便于渐进式重构；
- 独立部署，降低发布风险。

**缺点也有**：

- 架构复杂度高，调试和性能优化更难；
- 公共依赖管理、状态共享、样式冲突等问题需额外处理；
- 初期建设成本较高。
所以，微前端更适合大型复杂系统、多团队协作、遗留系统渐进式迁移等场景，而不是所有项目都需要它。

### 3. 微任务与宏任务


1. **基本定义**

    *   **宏任务（Macro Task）**：由宿主环境（浏览器/Node.js）提供的异步任务，包括：
        
        *   `script`（整体代码）
            
        *   `setTimeout` / `setInterval`
            
        *   I/O 操作（如文件读写）
            
        *   UI 渲染（浏览器）
            
        *   `setImmediate`（Node.js）
            
        *   `requestAnimationFrame`（浏览器）
            
        *   网络请求（如 `fetch` 回调）
            
    *   **微任务（Micro Task）**：由 JavaScript 引擎自身提供的异步任务，包括：
        
        *   `Promise.then` / `.catch` / `.finally`
            
        *   `async/await`（本质是 Promise）
            
        *   `MutationObserver`（浏览器）
            
        *   `queueMicrotask`
            
        *   `process.nextTick`（Node.js，优先级高于普通微任务）
            

2. **执行顺序与事件循环机制**

    1.  **同步代码执行** → 遇到异步任务时，宏任务进入宏任务队列，微任务进入微任务队列。
        
    2.  **当前宏任务执行完毕** → 立即清空**微任务队列**中的所有任务。
        
    3.  **微任务清空后** → 如有必要进行 UI 渲染 → 从宏任务队列取出**下一个宏任务**执行。
        
    4.  循环此过程。
        

    **关键规则**：**每个宏任务执行后，都会立即清空当前的微任务队列**，微任务执行期间新产生的微任务也会被加入当前队列并继续执行，直到微任务队列为空。


3. **核心区别**

    | 特性  | 宏任务 | 微任务 |
    | --- | --- | --- |
    | **来源** | 宿主环境（浏览器/Node.js API） | JavaScript 引擎（Promise 等） |
    | **执行时机** | 每个事件循环的“轮次”中执行一个 | 在每个宏任务**结束后、下一个宏任务前**全部执行 |
    | **优先级** | 较低  | 较高（总是优先于下一个宏任务） |
    | **典型例子** | `setTimeout`、`setInterval` | `Promise.then`、`queueMicrotask` |
    | **队列类型** | 宏任务队列（Task Queue） | 微任务队列（Microtask Queue/Job Queue） |


4. **代码示例说明**

    ```javascript
    console.log('1. 同步开始');

    setTimeout(() => {
    console.log('4. 宏任务 setTimeout');
    }, 0);

    Promise.resolve().then(() => {
    console.log('3. 微任务 Promise');
    });

    console.log('2. 同步结束');

    // 输出顺序：
    // 1. 同步开始
    // 2. 同步结束
    // 3. 微任务 Promise
    // 4. 宏任务 setTimeout
    ```


5. **进阶补充（加分项）**

    *   **微任务嵌套**：如果在微任务中又产生新的微任务，会继续在当前批次执行，直到队列清空（可能阻塞页面渲染）。
        
    *   **UI 渲染时机**：浏览器通常在宏任务之间执行渲染，微任务执行可能延迟渲染（因为微任务在渲染前执行）。
        
    *   **Node.js 差异**：Node.js 中 `process.nextTick` 优先级高于 `Promise`（同属微任务但有顺序差异）。
        
    *   **实际应用**：理解这一点有助于避免异步时序问题（如状态更新后立刻操作 DOM 可能需用 `queueMicrotask` 或 `Promise` 确保 DOM 已更新）。


6. **一句话总结**

   **先同步，再微任务，后宏任务，微任务总在下一个宏任务之前执行。**



### 4. 强缓存与协商缓存

1. 概念相关

    浏览器缓存是前端性能优化中非常重要的一环，主要目的是为了减少网络请求的延迟和流量消耗，从而提升网页的加载速度和用户体验。它主要分为两大类：强缓存和协商缓存。
    
    其核心流程是：当浏览器请求一个资源时，会先检查本地缓存。如果没有缓存或缓存失效，才会向服务器发起请求。

2. 分述强缓存与协商缓存

    **（1）强缓存（Strong Cache）**

    * **定义**：在这个阶段，浏览器不会向服务器发送请求，而是直接使用本地缓存。它的行为完全由客户端决定。
        
    * **如何实现**：主要通过 HTTP 响应头中的 `Cache-Control`和 `Expires`字段来控制。
        
        * **`Cache-Control`（HTTP/1.1，优先级更高）**：这是最常用、最关键的字段。
            
            * `max-age=`： 表示缓存内容在多少秒后失效（例如 `max-age=300`表示5分钟后缓存失效）。
                
            * `no-cache`： **注意**，这个名字有点误导，它并不是不缓存，而是**跳过强缓存，直接进入协商缓存**。
                
            * `no-store`： 这才是真正的“不缓存”，每次都要从服务器重新获取。
                
            * `public`： 响应可以被任何对象（客户端、代理服务器等）缓存。
                
            * `private`： 响应只能被单个用户（浏览器）缓存，不能被代理服务器缓存。
                
            
        * **`Expires`（HTTP/1.0）**：指定一个绝对的过期时间（GMT格式）。缺点是依赖客户端时间，如果用户修改了本地时间，会导致缓存失效不准确。
            
        
    *  **缓存结果状态码**：**200 (from disk cache)**​ 或 **200 (from memory cache)**。
        

    **（2）协商缓存（Negotiation Cache）**

    *   **定义**：当强缓存失效后，浏览器会携带缓存标识向服务器发起请求，由服务器决定是否使用缓存。如果资源没变，服务器返回 304 状态码，告诉浏览器可以继续使用缓存；如果资源变了，服务器返回 200 和新的资源。
        
    *   **如何实现**：通过成对的请求/响应头字段来控制。
        
        *   **第一对：`Last-Modified`/ `If-Modified-Since`**
            
            *   **服务端响应**：在第一次请求时，服务器通过 `Last-Modified`头部返回资源最后的修改时间。
                
            *   **浏览器下次请求**：当强缓存失效，浏览器会带上 `If-Modified-Since`头部，这个值就是之前收到的 `Last-Modified`的值。
                
            *   **服务器判断**：服务器对比资源的当前修改时间和这个值，如果没变，返回 304；如果变了，返回 200 和新资源。
                
            
        *   **第二对：`ETag`/ `If-None-Match`（优先级更高）**
            
            *    **服务端响应**：`ETag`是服务器为资源生成的一个唯一标识符（通常是哈希值）。当资源变化时，`ETag`也会改变。它比 `Last-Modified`更精确，因为后者只能精确到秒级，且有时文件内容改变但修改时间不变的情况。
                
            *   **浏览器下次请求**：浏览器会带上 `If-None-Match`头部，值为之前收到的 `ETag`。
                
            *   **服务器判断**：服务器比较当前的 `ETag`和浏览器传来的值，如果一致返回 304，不一致返回 200 和新资源。
                
    *   **缓存结果状态码**：**304 (Not Modified)**。

3. 对比与总结

    “所以，我们可以这样总结整个缓存机制的工作流程：”

    1.  浏览器第一次请求资源，服务器返回资源，并在响应头中设置缓存策略（如 `Cache-Control`, `ETag`等）。
        
    2.  再次请求时，浏览器先判断是否命中**强缓存**（通过 `Cache-Control`和 `Expires`）。
        
        *   如果命中，直接使用本地缓存，状态码 200。
            
        
    3.  如果未命中强缓存，则发起请求进行**协商缓存**验证。
        
        *   浏览器携带缓存标识（`If-Modified-Since`/ `If-None-Match`）给服务器。
            
        *  服务器验证后，返回 304（告知浏览器使用缓存）或 200（返回新资源）。

    “它们的**核心区别**在于：强缓存不发请求，协商缓存要发请求。”

4. 结合实际应用（加分项）

    “在实际项目中，我们会根据资源的类型设置不同的缓存策略：

    *    **对于 HTML 文件**：我们通常设置为 `no-cache`或 `max-age=0`，即走协商缓存。因为 HTML 经常更新，需要确保用户能尽快获取到最新版本。
        
    *  **对于 CSS、JS、图片等静态资源**：我们会设置一个很长的缓存时间，比如 `max-age=31536000`（一年）。同时，我们会通过给文件名添加哈希指纹（如 `style.a1b2c3.css`）来实现“缓存破坏”。这样当文件内容变化时，文件名就变了，相当于请求一个新资源，旧的缓存自然失效。这是最有效的缓存策略。
        
    *   **对于非常敏感的动态数据**：可能会使用 `no-store`完全禁用缓存。”

5. 流程图

    ```markdown
    浏览器发起请求 -> 检查强缓存（是否过期？）
        -> 未过期：200 (from cache) [结束]
        -> 已过期：携带 `If-None-Match` 等向服务器发起请求 -> 服务器验证
            -> 资源未变：返回 304，使用缓存
            -> 资源已变：返回 200 和新资源
    ```
    