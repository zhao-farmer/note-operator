# 自己的面试题

## 1. 定时任务的使用和执行流程

1. @Scheduled (Spring 内置)

    这是 最常用、最简单​ 的定时任务实现方式，适合大多数场景。
    使用示例：

    ```java
    import org.springframework.scheduling.annotation.EnableScheduling;
    import org.springframework.scheduling.annotation.Scheduled;
    import org.springframework.stereotype.Component;
    import java.time.LocalDateTime;

    @Component
    @EnableScheduling // 1. 在主类或配置类上添加此注解启用定时任务
    public class ScheduledTasks {
        
        // 2. 在方法上添加 @Scheduled 注解
        // 固定延迟5秒执行（上次执行结束后5秒再执行）
        @Scheduled(fixedDelay = 5000)
        public void taskWithFixedDelay() {
            System.out.println("固定延迟任务执行: " + LocalDateTime.now());
        }
        
        // 固定频率3秒执行（每3秒执行一次，无论上次是否完成）
        @Scheduled(fixedRate = 3000)
        public void taskWithFixedRate() {
            System.out.println("固定频率任务执行: " + LocalDateTime.now());
        }
        
        // Cron表达式：每天10:00执行
        @Scheduled(cron = "0 0 10 * * ?")
        public void taskWithCronExpression() {
            System.out.println("Cron表达式任务执行: " + LocalDateTime.now());
        }
        
        // 初始延迟2秒后开始执行
        @Scheduled(initialDelay = 2000, fixedRate = 5000)
        public void taskWithInitialDelay() {
            System.out.println("带初始延迟的任务: " + LocalDateTime.now());
        }
    }
    ```
  
2. 配置参数（在 application.yml 中）：

    ```yml
    spring:
      task:
        scheduling:
          # 定时任务线程池配置
          pool:
            size: 10  # 线程池大小，默认1
          thread-name-prefix: "scheduled-task-"  # 线程名前缀
          # 关闭时等待任务完成
          shutdown:
            await-termination: true
            await-termination-period: 30s
    ```
3. 执行流程：
	1. 应用启动​ → Spring 扫描所有带有 @Component的 Bean
	2. 发现 @Scheduled 注解的方法​ → 将其注册到 ScheduledAnnotationBeanPostProcessor
	3. 创建任务调度器​ → 使用 ThreadPoolTaskScheduler
	4. 按规则调度执行​ → 根据 cron/fixedDelay/fixedRate 规则触发执行
	5. 线程池管理​ → 默认单线程，可通过配置改为线程池

## 2. 过滤器与拦截器的区别

在 Java Web 开发中，**过滤器（Filter）** 和 **拦截器（Interceptor）** 都可以用于在请求处理前后执行一些通用逻辑（如日志记录、权限校验、字符编码设置等），但它们在**作用范围、实现机制、依赖框架、执行时机**等方面有明显区别。以下是详细对比：

1. 基本定义

	| 项目 | 过滤器（Filter） | 拦截器（Interceptor） |
	|------|------------------|------------------------|
	| 所属规范 | **Servlet 规范**的一部分 | **Spring 框架**提供的功能（非 Servlet 标准） |
	| 依赖容器 | 依赖 **Servlet 容器**（如 Tomcat） | 依赖 **Spring 容器** |
	| 适用范围 | 可用于任何基于 Servlet 的 Web 应用（包括非 Spring 项目） | 仅适用于 **Spring MVC 或 Spring Boot** 等 Spring Web 项目 |


2. 执行时机与流程

	1. 请求处理流程中的位置：

		```
		客户端
		↓
		[Filter] → (doFilter)
		↓
		[DispatcherServlet]
		↓
		[Interceptor.preHandle()]
		↓
		Controller 方法执行
		↓
		[Interceptor.postHandle()]
		↓
		视图渲染
		↓
		[Interceptor.afterCompletion()]
		↓
		[Filter] → (filterChain.doFilter() 后的代码)
		↓
		响应返回客户端
		```

	2. **Filter**：
		- 在 **DispatcherServlet 之前和之后**执行。
		- 能拦截 **所有进入容器的请求**（包括静态资源、JSP、Servlet 等）。
	3. **Interceptor**：
		- 在 **DispatcherServlet 之后、Controller 之前/之后**执行。
		- **只拦截被 Spring MVC 处理的请求**（即映射到 `@Controller` 的请求）。

		> ✅ 举例：访问 `/static/logo.png`  
		> - Filter 会执行  
		> - Interceptor **不会执行**（除非配置了静态资源放行或被 Spring 处理）

3. 功能与能力对比

	| 能力 | Filter | Interceptor |
	|------|--------|-------------|
	| 获取 `HttpServletRequest` / `HttpServletResponse` | ✅ | ✅ |
	| 修改请求/响应内容（如包装 request） | ✅（常用） | ❌（一般不能） |
	| 设置字符编码、压缩响应等底层操作 | ✅ | ❌ |
	| 访问 Spring Bean（如 Service） | ❌（除非手动获取上下文） | ✅（天然支持 DI） |
	| 中断请求流程 | ✅（不调用 `chain.doFilter()`） | ✅（`preHandle` 返回 `false`） |
	| 获取 Controller 方法信息（如方法名、注解） | ❌ | ✅（通过 `HandlerMethod`） |


4. 配置方式

	1. Filter（Servlet 方式）：

		```java
		@WebFilter("/*")
		public class MyFilter implements Filter {
			public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) {
				// 前置处理
				chain.doFilter(req, res); // 放行
				// 后置处理
			}
		}
		```
    或在 `web.xml` 中配置。

    2. Interceptor（Spring 方式）：
		
		```java
		@Component
		public class MyInterceptor implements HandlerInterceptor {
			@Override
			public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) {
				// Controller 之前
				return true; // false 则中断
			}

			@Override
			public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) {
				// Controller 之后，视图渲染前
			}

			@Override
			public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) {
				// 视图渲染后（类似 finally）
			}
		}
    	```

	**需在配置类中注册**：

	```java
	@Configuration
	public class WebConfig implements WebMvcConfigurer {
		@Override
		public void addInterceptors(InterceptorRegistry registry) {
			registry.addInterceptor(new MyInterceptor()).addPathPatterns("/**");
		}
	}
	```

5. 典型使用场景

	| 场景 | 推荐使用 |
	|------|----------|
	| 设置全局字符编码（如 UTF-8） | ✅ Filter |
	| 日志记录（记录所有请求，包括静态资源） | ✅ Filter |
	| 权限校验（仅针对 Controller 接口） | ✅ Interceptor |
	| 性能监控（统计 Controller 执行时间） | ✅ Interceptor |
	| 请求/响应内容加密、压缩 | ✅ Filter |
	| 注入用户信息到 ThreadLocal（结合 Spring Security） | ✅ Interceptor |

6. 总结

	> **Filter 是 Servlet 层面的“网关”，作用于整个 Web 应用；Interceptor 是 Spring MVC 层面的“中间件”，作用于 Controller 请求处理过程。**

## 3. 面向切面编程的流程


1. 核心概念（先理解术语）

	| 概念 | 说明 |
	|------|------|
	| **Aspect（切面）** | 横切关注点的模块化，通常是一个类（用 `@Aspect` 标注） |
	| **Join Point（连接点）** | 程序执行过程中的某个点，如方法调用、异常抛出等（Spring AOP 中仅支持方法级别的连接点） |
	| **Advice（通知）** | 在特定连接点上执行的动作，如“方法前做什么”、“方法后做什么” |
	| **Pointcut（切入点）** | 匹配连接点的表达式，决定哪些方法会被拦截 |
	| **Weaving（织入）** | 将切面应用到目标对象并创建代理对象的过程（Spring 在运行时通过代理实现） |

2. Spring AOP 切面编程的标准流程

	- 步骤 1：添加依赖（Spring Boot 示例）
		```xml
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-aop</artifactId>
		</dependency>
		```
		> Spring Boot 自动启用 `@EnableAspectJAutoProxy`

	- 步骤 2：定义切面类（使用 `@Aspect`）

		```java
		import org.aspectj.lang.annotation.Aspect;
		import org.aspectj.lang.annotation.Before;
		import org.aspectj.lang.annotation.After;
		import org.aspectj.lang.annotation.Around;
		import org.aspectj.lang.ProceedingJoinPoint;
		import org.springframework.stereotype.Component;

		@Aspect
		@Component
		public class LoggingAspect {

			// 前置通知：在目标方法执行前运行
			@Before("execution(* com.example.service.*.*(..))")
			public void logBefore() {
				System.out.println("【前置通知】方法即将执行");
			}

			// 后置通知：无论是否异常，方法结束后执行
			@After("execution(* com.example.service.*.*(..))")
			public void logAfter() {
				System.out.println("【后置通知】方法已结束");
			}

			// 环绕通知：最强大，可控制是否执行目标方法
			@Around("execution(* com.example.service.*.*(..))")
			public Object logAround(ProceedingJoinPoint joinPoint) throws Throwable {
				System.out.println("【环绕通知】进入方法: " + joinPoint.getSignature().getName());
				
				long start = System.currentTimeMillis();
				Object result = joinPoint.proceed(); // 执行目标方法
				long time = System.currentTimeMillis() - start;
				
				System.out.println("【环绕通知】方法执行耗时: " + time + "ms");
				return result;
			}
		}
		```
	- 步骤 3：编写目标业务类（被代理的对象）

		```java
		@Service
		public class UserService {
			public void saveUser(String name) {
				System.out.println("保存用户: " + name);
			}
		}
		```
	- 步骤 4：调用目标方法（触发 AOP）

		```java
		@RestController
		public class UserController {
			@Autowired
			private UserService userService;

			@GetMapping("/save")
			public String save() {
				userService.saveUser("张三"); // 此处会触发切面逻辑
				return "OK";
			}
		}
		```

3. 执行流程详解（以 `@Around` 为例）

	当调用 `userService.saveUser("张三")` 时，实际执行的是 **Spring 生成的代理对象**，流程如下：

	1. **容器启动时**：

		- Spring 扫描 `@Aspect` 类和目标 Bean（如 `UserService`）。
		- 根据 `@Pointcut` 表达式匹配需要增强的方法。
		- 通过 **JDK 动态代理**（接口）或 **CGLIB 代理**（类）为目标对象创建代理。

	2. **方法调用时**：

		```text
		调用 userService.saveUser()
				↓
		进入代理对象的 invoke() 方法
				↓
		执行 @Around 通知（logAround）
				↓
		调用 joinPoint.proceed() → 实际执行 UserService.saveUser()
				↓
		继续执行 @Around 的后续逻辑
				↓
		（如有）执行 @After 通知
		```

		> 注意：`@Before` 和 `@After` 实际上是被包装在 `@Around` 内部实现的。


4. 常用通知类型对比

	| 注解 | 时机 | 是否能阻止方法执行 | 典型用途 |
	|------|------|------------------|--------|
	| `@Before` | 方法执行前 | ❌ | 参数校验、日志记录 |
	| `@After` | 方法执行后（finally） | ❌ | 资源清理 |
	| `@AfterReturning` | 方法成功返回后 | ❌ | 处理返回结果 |
	| `@AfterThrowing` | 方法抛出异常后 | ❌ | 异常日志、回滚 |
	| `@Around` | 环绕整个方法 | ✅（不调用 `proceed()` 即可阻止） | 性能监控、缓存、事务 |



5. 切入点表达式（Pointcut）语法示例

	```java
	// 任意公共方法
	execution(public * *(..))

	// service 包下所有类的所有方法
	execution(* com.example.service..*(..))

	// 指定注解的方法
	@annotation(org.springframework.web.bind.annotation.GetMapping)

	// 多个条件组合
	@Pointcut("execution(* com.example.service.*.*(..)) && @annotation(Loggable)")
	```

6. 注意事项

	1. **代理限制**：
		- Spring AOP 是基于代理的，**同一个类内部方法调用不会触发 AOP**（如 `this.methodB()` 调用 `methodA()`，而 `methodA` 有切面，则不会生效）。
		- 解决方案：使用 `AopContext.currentProxy()` 或改用 AspectJ 编译时织入。

	2. **性能**：
		- AOP 会带来轻微性能开销，但通常可忽略。

	3. **顺序**：
		- 多个切面可通过 `@Order` 或实现 `Ordered` 接口控制执行顺序。

7.  总结：AOP 流程一句话

	> **定义切面 → 配置切入点 → Spring 在运行时为目标对象生成代理 → 调用方法时自动织入通知逻辑。**

## 4. 如果让你做技术选型，你选vue还是react

我会根据具体项目需求、团队背景和长期维护成本来综合判断，而不是单纯偏好某一个框架。

首先，Vue 和 React 各有优势：

**Vue 的优势在于**：
- 上手门槛低，模板语法直观，适合快速开发；
- 官方提供完整的工具链（Vue CLI / Vite + Vue Router + Pinia），开箱即用；
- 对中小型项目或需要快速交付的业务非常友好；
- 响应式系统自动追踪依赖，开发者心智负担较小。


**React 的优势在于**：

- 灵活性高，生态极其丰富，社区活跃；
- 函数式编程 + Hooks 模式更适合构建复杂、可复用的 UI 逻辑；
- 在大型应用、跨平台（如 React Native）或需要高度定制化的场景中表现更佳；
- 更强调“一切皆组件”和单向数据流，有利于构建可预测的状态管理。


举个例子：

- 如果是做一个内部管理系统、营销落地页或团队里新人较多，我会倾向于选择 Vue，因为它能更快上手、减少学习成本，提升开发效率。

- 如果是构建一个大型 SaaS 平台、需要高度组件复用、未来可能拓展到移动端，或者团队已经有 React 经验，那我会选择 React。


另外，我也会考虑团队技术栈一致性。如果公司已有大量 React 项目，强行引入 Vue 可能会增加维护成本；反之亦然。

## 5. 