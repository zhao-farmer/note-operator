# 三、框架篇

![](/work/interview/java/101.png)

## 3.1 spring系列

### 1. 单例bean是线程安全的吗

1. 问题

    - Spring框架中的单例bean是线程安全的吗?
    - Spring框架中的bean是单例的？

        ```java
        @Service
        @Scope("singleton")
        public class UserServiceImpl implements UserService {
        
        }
        ```

        - singleton: bean在每个Spring IOC容器实例中只有一个实例
        - prototype: 一个bean的定义可以有多个实例


2. Spring框架中的单例bean是线程安全的吗？

    ![](/work/interview/java/102.png)

    Spring bean并没有可变的状态(比如Service类和DAO类)，所以在某种程度上说Spring的单例bean是线程安全的。
    
    Spring框架中有一个@Scope注解，默认的值就是singleton，单例的。因为一般在spring的bean的中都是注入无状态的对象，没有线程安全问题，如果在bean中定义了可修改的成员变量，是要考虑线程安全问题的，可以使用多例或者加锁来解决


3. 面试现场

    - 面试官:Spring框架中的单例bean是线程安全的吗?
    - 候选人:
        
        不是线程安全的，是这样的
        
        当多用户同时请求一个服务时，容器会给每一个请求分配一个线程，这是多个线程会并发执行该请求对应的业务逻辑(成员方法)，如果该处理逻辑中有对该单列状态的修改(体现为该单例的成员属性)，则必须考虑线程同步问题。
        
        Spring框架并没有对单例bean进行任何多线程的封装处理。关于单例bean的线程安全和并发问题需要开发者自行去搞定。
        
        比如:我们通常在项目中使用的Springbean都是不可可变的状态(比如Service类和DAO类)，所以在某种程度上说Spring的单例bean是线程安全的。
        
        如果你的bean有多种状态的话(比如ViewModel对象)，就需要自行保证线程安全。最浅显的解决办法就是将多态bean的作用由“singleton"变更为"prototype”

### 2. AOP相关

1. 问题

    - 什么是AOP，你们项目中有没有使用到AOP（对AOP的理解，有没有真的用过aop）

        AOP称为面向切面编程，用于将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取并封装为一个可重用的模块，这个模块被命名为“切面”(Aspect)，减少系统中的重复代码，降低了模块间的耦合度，同时提高了系统的可维护性。

    - 常见的AOP使用场景

        - 记录操作日志
        - 缓存处理
        - Spring中内置的事务处理
    - 记录操作日志

        ![](/work/interview/java/103.png)

        获取请求的用户名、请求方式、访问地址、模块名称、登录ip、操作时间，记录到数据库的日志表中

        ![](/work/interview/java/104.png)

        - 代码实现

            - UserController

                ```java
                @RestController
                @RequestMapping("/user")
                public class UserController {
                    
                    @Autowired
                    private UserService userService;
                    
                    @GetMapping("/getById/{id}")
                    @Log(name = "根据用户id获取用户")
                    public User getById(@PathVariable("id") Integer id) {
                        return userService.getById(id);
                    }
                }
                ```
            - SysAspect 

                ```java
                @Component
                @Aspect  //切面类
                public class SysAspect {
                    
                    // 切点
                    @Pointcut("@annotation(com.itheima.annotation.Log)") 
                    private void pointcut() {
                        
                    }
                    
                    @Around("pointcut()")
                    public Object around(ProceedingJoinPoint joinPoint) throws Throwable {
                        
                        //获取用户名
                        //需要通过解析session或token获取
                        
                        //获取被增强类和方法的信息
                        Signature signature = joinPoint.getSignature();
                        MethodSignature methodSignature = (MethodSignature) signature;
                        //获取被增强的方法对象
                        Method method = methodSignature.getMethod();
                        //从方法中解析注解
                        if(method != null){
                            Log logAnnotation = method.getAnnotation(Log.class);
                            System.out.println(logAnnotation.name());
                        }
                        
                        //方法名字
                        String name = method.getName();
                        System.out.println(name);
                        
                        //通过工具类获取Request对象
                        RequestAttributes reqa = RequestContextHolder.getRequestAttributes();
                        ServletRequestAttributes sra = (ServletRequestAttributes)reqa;
                        HttpServletRequest request = sra.getRequest();
                        
                        //访问的url
                        String url = request.getRequestURI().toString();
                        System.out.println(url);
                        
                        //请求方式
                        String methodName = request.getMethod();
                        System.out.println(methodName);
                        
                        //操作时间
                        System.out.println(new Date());
                        
                        //保存到数据库（操作日志）
                        //....
                        
                        return joinPoint.proceed();
                    }
                }
                ```
            - Log

                ```java
                @Target({ ElementType.PARAMETER, ElementType.METHOD })
                @Retention(RetentionPolicy.RUNTIME)
                @Documented
                public @interface Log {
                    /**
                    * 模块名称
                    */
                    public String name() default "";
                }
                ```

2. 问题：Spring中事务是如何实现的

    Spring支持编程式事务管理和声明式事务管理两种方式。
    
    - 编程式事务控制:需使用TransactionTemplate来进行实现，对业务代码有侵入性，项目中很少使用
    - 声明式事务管理:声明式事务管理建立在AOP之上的。其本质是通过AOP功能，对方法前后进行拦截，将事务处理的功能编织到拦截的方法中，也就是在目标方法开始之前加入一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务。

    ![](/work/interview/java/105.png)

3. 回答问题：

    1. 什么是AOP

        面向切面编程，用于将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取公共模块复用，降低耦合
    
    2. 你们项目中有没有使用到AOP
        
        记录操作日志，缓存，spring实现的事务
        
        核心是:使用aop中的环绕通知+切点表达式(找到要记录日志的方法)，通过环绕通知的参数获取请求方法的参数(类、方法、注解、请求方式等)，获取到这些参数以后，保存到数据库
    
    3. Spring中的事务是如何实现的
        
        其本质是通过AOP功能，对方法前后进行拦截，在执行方法之前开启事务，在执行完目标方法之后根据执行情况提交或者回滚事务。

4. 面试现场

    - 面试官：什么是AOP？
    - 候选人：AOP，即面向切面编程，在Spring中用于将那些与业务无关但对多个对象产生影响的公共行为和逻辑抽取出来，实现公共模块复用，降低耦合。常见的应用场景包括公共日志保存和事务处理。

    - 面试官：你们项目中有没有使用到AOP？
    - 候选人：我们之前在后台管理系统中使用AOP来记录系统操作日志。主要思路是使用AOP的环绕通知和切点表达式，找到需要记录日志的方法，然后通过环绕通知的参数获取请求方法的参数，例如类信息、方法信息、注解、请求方式等，并将这些参数保存到数据库。

    - 面试官：Spring中的事务是如何实现的？
    - 候选人：Spring实现事务的本质是利用AOP完成的。它对方法前后进行拦截，在执行方法前开启事务，在执行完目标方法后根据执行情况提交或回滚事务。

### 3. Spring事务失效的场景

1. 问题：Spring中事务失效的场景有哪些

    - 情况一：异常捕获处理

        - <b style="color:blue;font-weight:blod">代码</b>

            ```java
            @Transactional
            public void update(Integer from, Integer to, Double money) {
                try {
                    // 转账的用户不能为空
                    Account fromAccount = accountDao.selectById(from);
                    // 判断用户的钱是否够转账
                    if (fromAccount.getMoney() - money >= 0) {
                        fromAccount.setMoney(fromAccount.getMoney() - money);
                        accountDao.updateById(fromAccount);
                    }
                    // 模拟异常
                    int a = 1/0;

                    // 被转账的用户
                    Account toAccount = accountDao.selectById(to);
                    toAccount.setMoney(toAccount.getMoney() + money);
                    accountDao.updateById(toAccount);
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            ```

        - <b style="color:red;font-weight:blod">原因</b>

            事务通知只有捉到了目标抛出的异常，才能进行后续的回滚处理，如果目标自己处理掉异常，事务通知无法知悉
        - <b style="color:green;font-weight:blod">解决</b>

            在catch块添加throw new RuntimeException(e)抛出
    - 情况二：抛出检查异常

        - <b style="color:blue;font-weight:blod">代码</b>

            ```java
            @Transactional
            public void update(Integer from, Integer to, Double money) throws FileNotFoundException {
                
                // 转账的用户不能为空
                Account fromAccount = accountDao.selectById(from);
                
                // 判断用户的钱是否够转账
                if (fromAccount.getMoney() - money >= 0) {
                    fromAccount.setMoney(fromAccount.getMoney() - money);
                    accountDao.updateById(fromAccount);
                }
                
                // 读取文件
                new FileInputStream("dddd");
                
                // 被转账的用户
                Account toAccount = accountDao.selectById(to);
                toAccount.setMoney(toAccount.getMoney() + money);
                accountDao.updateById(toAccount);
            }
            ```
        - <b style="color:red;font-weight:blod">原因</b>

            Spring默认只会回滚非检查异常
        - <b style="color:green;font-weight:blod">解决</b>

            配置rollbackFor属性
            <br>@Transactional(rollbackFor=Exception.class)
    - 情况三：非public方法
        
        - <b style="color:blue;font-weight:blod">代码</b>

            ```java
            @Transactional(rollbackFor = Exception.class)
            void update(Integer from, Integer to, Double money) throws FileNotFoundException {
                
                // 转账的用户不能为空
                Account fromAccount = accountDao.selectById(from);
                
                // 判断用户的钱是否够转账
                if (fromAccount.getMoney() - money >= 0) {
                    fromAccount.setMoney(fromAccount.getMoney() - money);
                    accountDao.updateById(fromAccount);
                }
                
                // 读取文件
                new FileInputStream("dddd");
                
                // 被转账的用户
                Account toAccount = accountDao.selectById(to);
                toAccount.setMoney(toAccount.getMoney() + money);
                accountDao.updateById(toAccount);
            }

            ```
        - <b style="color:red;font-weight:blod">原因</b>

            Spring 为方法创建代理、添加事务通知、前提条件都是该方法是 public 的, Spring默认只会回滚非检查异常
        - <b style="color:green;font-weight:blod">解决</b>

          改为 public 方法

2. Spring中事务失效的场景有哪些
    - 异常捕获处理，自己处理了异常，没有抛出，解决:手动抛出
    - 抛出检查异常，配置rollbackFor属性为Exception
    - 非public方法导致的事务失效，改为public

3. 面试现场
    - 面试官： Spring中事务失效的场景有哪些？
    - 候选人：在项目中，我遇到过几种导致事务失效的场景：

        1. 如果方法内部捕获并处理了异常，没有将异常抛出，会导致事务失效。因此，处理异常后应该确保异常能够被抛出。
        2. 如果方法抛出检查型异常（checked exception），并且没有在@Transactional注解上配置rollbackFor属性为Exception，那么异常发生时事务可能不会回滚。
        3. 如果事务注解的方法不是公开（public）修饰的，也可能导致事务失效。

### 4. Spring的bean的生命周期

1. 问题：Spring的bean的生命周期
    1. Spring容器是如何管理和创建bean实例
    2. 方便调试和解决问题

2. BeanDefinition
    
    Spring容器在进行实例化时，会将xml配置的`<bean>`的信息封装成一个BeanDefinition对象，Spring根据BeanDefinition来创建Bean对象，里面有很多的属性用来描述Bean
    
    ```xml
    <!-- 定义UserDao Bean，采用懒加载策略 -->
    <bean id="userDao" class="com.itheima.dao.impl.UserDaoImpl" lazy-init="true"/>

    <!-- 定义UserService Bean，单例模式，并注入UserDao依赖 -->
    <bean id="userService" class="com.itheima.service.UserServiceImpl" scope="singleton">
        <property name="userDao" ref="userDao"/>
    </bean>
    ```

    ![](/work/interview/java/107.png)

    - beanClassName: bean 的类名
    - initMethodName:初始化方法名称
    - properryValues:bean 的属性值
    - scope:作用域
    - lazyInit:延迟初始化

3. bean的生命周期

    ![](/work/interview/java/106.png)

    - 代码示例

        - config/SpringConfig.java

            ```java
            @Configuration
            @ComponentScan("com.itheima.lifecycle")
            public class SpringConfig {
            }
            ```
        - lifecycle/User.java

            ```java
            @Component
            public class User implements BeanNameAware, BeanFactoryAware, ApplicationContextAware, InitializingBean {

                public User() {
                    System.out.println("User的构造方法执行了.........");
                }

                private String name ;

                @Value("张三")
                public void setName(String name) {
                    System.out.println("setName方法执行了.........");
                }

                @Override
                public void setBeanName(String name) {
                    System.out.println("setBeanName方法执行了.........");
                }

                @Override
                public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
                    System.out.println("setBeanFactory方法执行了.........");
                }

                @Override
                public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
                    System.out.println("setApplicationContext方法执行了........");
                }

                @PostConstruct
                public void init() {
                    System.out.println("init方法执行了.................");
                }

                @Override
                public void afterPropertiesSet() throws Exception {
                    System.out.println("afterPropertiesSet方法执行了........");
                }

                @PreDestroy
                public void destory() {
                    System.out.println("destory方法执行了...............");
                }

            }
            ```
        - lifecycle/MyBeanPostProcessor.java

            ```java
            @Component
            public class MyBeanPostProcessor implements BeanPostProcessor {

                @Override
                public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
                    if (beanName.equals("user")) {
                        System.out.println("postProcessBeforeInitialization方法执行了->user对象初始化方法前开始增强....");
                    }
                    return bean;
                }

                @Override
                public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
                    if (beanName.equals("user")) {
                        System.out.println("postProcessAfterInitialization->user对象初始化方法后开始增强....");
                        //cglib代理对象
                        Enhancer enhancer = new Enhancer();
                        //设置需要增强的类
                        enhancer.setSuperclass(bean.getClass());
                        //执行回调方法，增强方法
                        enhancer.setCallback(new InvocationHandler() {
                            @Override
                            public Object invoke(Object o, Method method, Object[] objects) throws Throwable {
                                //执行目标方法
                                return method.invoke(method,objects);
                            }
                        });
                        //创建代理对象
                        return enhancer.create();
                    }
                    return bean;
                }

            }
            ```

        - Test.java

            ```java
            public class UserTest {
                public static void main(String[] args) {
                    ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class);
                    User user = ctx.getBean(User.class);
                    System.out.println(user);
                }

            }
            ```
    - 运行结果

        ![](/work/interview/java/108.png)

4. 问题：Spring的bean的生命周期
    1. 通过BeanDefinition获取bean的定义信息
    2. 调用构造函数实例化bean
    3. bean的依赖注入
    4. 处理Aware接囗(BeanNameAware、BeanFactoryAware、ApplicationContextAware)
    5. Bean的后置处理器BeanPostProcessor-
    6. 前置初始化方法(InitializingBean、init-method)
    7. Bean的后置处理器BeanPostProcessor-后置
    8. 销毁bean

5. 面试现场

    - 面试官：Spring的bean的生命周期？
    - 候选人：
        
        Spring中bean的生命周期包括以下步骤：

        1. 通过BeanDefinition获取bean的定义信息。
        2. 调用构造函数实例化bean。
        3. 进行bean的依赖注入，例如通过setter方法或@Autowired注解。
        4. 处理实现了Aware接口的bean。
        5. 执行BeanPostProcessor的前置处理器。
        6. 调用初始化方法，如实现了InitializingBean接口或自定义的init-method。
        7. 执行BeanPostProcessor的后置处理器，可能在这里产生代理对象。
        8. 最后是销毁bean。

### 5. Spring中的循环依赖

1. 问题：Spring中的循环引用

    ![](/work/interview/java/109.png)

    在创建A对象的同时需要使用的B对象，在创建B对象的同时需要使用到A对象

2. 什么是Spring的循环依赖

    ![](/work/interview/java/110.png)

    三级缓存解决循环依赖

    Spring解决循环依赖通过三级缓存，对应的三级缓存如下所示：

    ```java
    // 单实例对象注册器
    public class DefaultSingletonBeanRegistry extends SimpleAliasRegistry implements SingletonBeanRegistry {

        private static final int SUPPRESSED_EXCEPTIONS_LIMIT = 100;

        private final Map<String, Object> singletonObjects = new ConcurrentHashMap(256);  // 一级缓存

        private final Map<String, ObjectFactory<?>> singletonFactories = new HashMap(16);  // 三级缓存

        private final Map<String, Object> earlySingletonObjects = new ConcurrentHashMap(16);  // 二级缓存
    }
    ```

    | 缓存名称 | 源码名称 | 作用 |
    |---------|---------|------|
    | 一级缓存 | singletonObjects | 单例池，缓存已经经历了完整的生命周期，已经初始化完成的bean对象 |
    | 二级缓存 | earlySingletonObjects | 缓存早期的bean对象（生命周期还没走完） |
    | 三级缓存 | singletonFactories | 缓存的是ObjectFactory，表示对象工厂，用来创建某个对象的 |

    1. 一级缓存作用:限制bean在beanFactory中只存一份，即实现singleton scope，解决不了循环依赖

    2. 一级缓存与二级缓存：

        如果要想打破循环依赖,就需要一个中间人的参与,这个中间人就是二级缓存。

        - 普通对象

            ![](/work/interview/java/111.png)

        - 代理对象（会失败）

            ![](/work/interview/java/112.png)
    3. 三级缓存，解决如果A是代理对象的问题

        ![](/work/interview/java/113.png)
    
3. 三级缓存也解决不了的循环依赖

    - 构造方法出现了循环依赖怎么解决

    ![](/work/interview/java/114.png)


4. Spring中的循环引用
    - 循环依赖:循环依赖其实就是循环引用，也就是两个或两个以上的bean互相持有对方,最终形成闭环。比如A依赖于B,B依赖于A
    
    - 循环依赖在spring中是允许存在，spring框架依据三级缓存已经解决了大部分的循环依赖
    
    1. 一级缓存:单例池，缓存已经经历了完整的生命周期，已经初始化完成的bean对象
    2. 二级缓存:缓存早期的bean对象(生命周期还没走完)
    3. 三级缓存:缓存的是ObjectFactory，表示对象工厂，用来创建某个对象的


5. 构造方法出现了循环依赖怎么解决?
    
    - A依赖于B，B依赖于A，注入的方式是构造函数原因:由于bean的生命周期中构造函数是第一个执行的，spring框架并不能解决构造函数的的依赖注入
    - 解决方案:使用@Lazy进行懒加载，什么时候需要对象再进行bean对象的创建

6. 面试现场

    - 面试官： sring中的循环引用？
    - 候选人：循环依赖发生在两个或两个以上的bean互相持有对方，形成闭环。Spring框架允许循环依赖存在，并通过三级缓存解决大部分循环依赖问题：

        1. 一级缓存：单例池，缓存已完成初始化的bean对象。
        2. 二级缓存：缓存尚未完成生命周期的早期bean对象。
        3. 三级缓存：缓存ObjectFactory，用于创建bean对象。

    - 面试官： 那具体解决流程清楚吗？
    - 候选人：解决循环依赖的流程如下：
        1. 实例化A对象，并创建ObjectFactory存入三级缓存。
        2. A在初始化时需要B对象，开始B的创建逻辑。
        3. B实例化完成，也创建ObjectFactory存入三级缓存。
        4. B需要注入A，通过三级缓存获取ObjectFactory生成A对象，存入二级缓存。
        5. B通过二级缓存获得A对象后，B创建成功，存入一级缓存。
        6. A对象初始化时，由于B已创建完成，可以直接注入B，A创建成功存入一级缓存。
        7. 清除二级缓存中的临时对象A。

    - 面试官： 构造方法出现了循环依赖怎么解决？
    - 候选人：由于构造函数是bean生命周期中最先执行的，Spring框架无法解决构造方法的循环依赖问题。可以使用@Lazy懒加载注解，延迟bean的创建直到实际需要时。

### 6. SpringMvc的执行流程

1. 问题：SpringMVC的执行流程知道吗

    Springmvc的执行流程是这个框架最核心的内容

    - 视图阶段（老旧JSP等）

        ![](/work/interview/java/115.png)
    - 前后端分离阶段（接口开发，异步）

        ![](/work/interview/java/116.png)
2. 问答

    SpringMVC的执行流程知道嘛？


    - 版本1:视图版本，jsp
        1. 用户发送出请求到前端控制器DispatcherServlet
        2. DispatcherServet收到请求调用HandlerMapping(处理器映射器)
        3. HandlerMapping找到具体的处理器，生成处理器对象及处理器拦截器(如果有)，再一起返回给DispatcherServlet.
        4. DispatcherServlet调用HandlerAdapter(处理器适配器)
        5. HandlerAdapter经过适配调用具体的处理器(Handler/Controller)
        6. Controller执行完成返回ModelAndView对象
        7. HandlerAdapter将Controller执行结果ModelAndView返回给DispatcherServlet
        8. DispatcherServlet将ModelAndView传给ViewReslover(视图解析器)
        9. ViewReslover解析后返回具体View(视图)
        10. DispatcherServlet根据View进行渲染视图(即将模型数据填充至视图中)
        11. DispatcherServlet响应用户
    - 版本2：前后端开发，接口开发

        1. 用户发送出请求到前端控制器DispatcherServlet
        2. DispatcherServlet收到请求调用HandlerMapping(处理器映射器)
        3. HandlerMapping找到具体的处理器，生成处理器对象及处理器拦截器(如果有)，再一起返回给DispatcherServlet.
        4. DispatcherServlet调用HandlerAdapter(处理器适配器)
        5. HandlerAdapter经过适配调用具体的处理器(Handler/Controller)
        6. 方法上添加了@ResponseBody
        7. 通过HttpMessageConverter来返回结果转换为JSON并响应

3. 面试现场

    - 面试官 SpringMVC的执行流程？
    - 候选人：SpringMVC的执行流程包括以下步骤：
        1. 用户发送请求到前端控制器DispatcherServlet。
        2. DispatcherServlet调用HandlerMapping找到具体处理器。
        3. HandlerMapping返回处理器对象及拦截器（如果有）给DispatcherServlet。
        4. DispatcherServlet调用HandlerAdapter。
        5. HandlerAdapter适配并调用具体处理器（Controller）。
        6. Controller执行并返回ModelAndView对象。
        7. HandlerAdapter将ModelAndView返回给DispatcherServlet。
        8. DispatcherServlet传给ViewResolver进行视图解析。
        9. ViewResolver返回具体视图给DispatcherServlet。
        10. DispatcherServlet渲染视图并响应用户。

### 7. Springboot自动配置原理

1. 问题：Springboot自动配置原理

    ![](/work/interview/java/117.png)

    - @SpringBootConfiguration:该注解与 @Configuration 注解作用相同，用来声明当前也是一个配置类。
    - @ComponentScan:组件扫描，默认扫描当前引导类所在包及其子包。
    - @EnableAutoConfiguration:SpringBoot实现自动化配置的核心注解,

        - 配置的流程

            ![](/work/interview/java/118.png)
        - 自动配置类（redis）

            ![](/work/interview/java/119.png)

2. 回答：Springboot自动配置原理
    1. 在Spring Boot项目中的引导类上有一个注解@SpringBootApplication，这个注解是对三个注解进行了封装，分别是:
        - @SpringBootConfiguration
        - @EnableAutoConfiguration
        - @ComponentScan
    2. 其中`@EnableAutoConfiguration`是实现自动化配置的核心注解。该注解通过   `@lmport`注解导入对应的配置选择器。内部就是读取了该项目和该项目引用的Jar包的的classpath路径下`META-INF/spring.factories`更件中的所配置的类的全类名。在这些配置类中所定义的Bean会根据条件注解·来决定是否需要将其导入到Spring容器中。
    
    3. 条件判断会有像`@ConditionaOnClass`这样的注解，判断是否有对应的class文件，如果有则加载该类，把这个配置类的所有的Bean放入spring容器中使用。

3. 面试现场

    - 面试官： Springboot自动配置原理？
    - 候选人：Spring Boot的自动配置原理基于@SpringBootApplication注解，它封装了@SpringBootConfiguration、@EnableAutoConfiguration和@ComponentScan。@EnableAutoConfiguration是核心，它通过@Import导入配置选择器，读取META-INF/spring.factories文件中的类名，根据条件注解决定是否将配置类中的Bean导入到Spring容器中。

### 8. SpringMVC常见注解？

1. Spring的常见注解有哪些？

    | 注解 | 说明 |
    |------|------|
    | `@Component`、`@Controller`、`@Service`、`@Repository` | 使用在类上用于实例化 Bean |
    | `@Autowired` | 使用在字段上用于根据类型依赖注入 |
    | `@Qualifier` | 结合 @Autowired 一起使用用于根据名称进行依赖注入 |
    | `@Scope` | 标注 Bean 的作用范围 |
    | `@Configuration` | 指定当前类是一个 Spring 配置类，当创建容器时会从该类上加载注解 |
    | `@ComponentScan` | 用于指定 Spring 在初始化容器时要扫描的包 |
    | `@Bean` | 使用在方法上，标注将该方法的返回值存储到 Spring 容器中 |
    | `@Import` | 使用 @Import 导入的类会被 Spring 加载到 IOC 容器中 |
    | `@Aspect`、`@Before`、`@After`、`@Around`、`@Pointcut` | 用于切面编程（AOP） |

2. SpringMVC常见的注解有哪些？

    | 注解 | 说明 |
    |------|------|
    | `@RequestMapping` | 用于映射请求路径，可以定义在类上和方法上。用于类上，则表示类中的所有的方法都是以该地址作为父路径 |
    | `@RequestBody` | 注解实现接收http请求的json数据，将json转换为java对象 |
    | `@RequestParam` | 指定请求参数的名称 |
    | `@PathVariable` | 从请求路径中获取请求参数(/user/{id})，传递给方法的形式参数 |
    | `@ResponseBody` | 注解实现将controller方法返回对象转化为json对象响应给客户端 |
    | `@RequestMapping` | 获取指定的请求头数据 |
    | `@RestController` | `@Controller` + `@ResponseBody` |
3. Springboot常见注解有哪些？

    | 注解 | 说明 |
    |------|------|
    | `@SpringBootConfiguration` | 组合了 @Configuration 注解，实现配置文件的功能 |
    | `@EnableAutoConfiguration` | 打开自动配置的功能，也可以关闭某个自动配置的选项 |
    | `@ComponentScan` | Spring 组件扫描 |

4. 面试现场

    - 面试官：Spring 的常见注解有哪些？
    - 候选人：Spring的常见注解包括：
        1. 声明Bean的注解：@Component、@Service、@Repository、@Controller。
        2. 依赖注入相关注解：@Autowired、@Qualifier、@Resource。
        3. 设置作用域的注解：@Scope。
        4. 配置相关注解：@Configuration、@ComponentScan、@Bean。
        5. AOP相关注解：@Aspect、@Before、@After、@Around、@Pointcut。

    - 面试官： SpringMVC常见的注解有哪些？
    - 候选人：SpringMVC的常见注解有：
        - @RequestMapping：映射请求路径。
        - @RequestBody：接收HTTP请求的JSON数据。
        - @RequestParam：指定请求参数名称。
        - @PathVariable：从请求路径中获取参数。
        - @ResponseBody：将Controller方法返回的对象转化为JSON。
        - @RequestHeader：获取请求头数据。
        - @PostMapping、@GetMapping等。

    - 面试官： Springboot常见注解有哪些？
    - 候选人：Spring Boot的常见注解包括：
        - @SpringBootApplication：由@SpringBootConfiguration、@EnableAutoConfiguration和@ComponentScan组成。
        - 其他注解如@RestController、@GetMapping、@PostMapping等，用于简化Spring MVC的配置。

## 3.2 mybatis

### 3.2.1 Mybatis执行流程

1. Mybatis执行流程-讲解

    - mybatis-config.xml 文件
        
        ```xml
        <!--
        environments：配置数据库连接环境信息。可以配置多个environment，通过default属性切换不同的environment
        -->
        <environments default="development">
            <environment id="development">
                <transactionManager type="JDBC"/>
                <dataSource type="POOLED">
                    <!--数据库连接信息-->
                    <property name="driver" value="com.mysql.jdbc.Driver"/>
                    <property name="url" value="jdbc:mysql:///mybatis?useSSL=false"/>
                    <property name="username" value="root"/>
                    <property name="password" value="root"/>
                </dataSource>
            </environment>
        </environments>
        <mappers>
        <!--加载sql映射文件-->
        <mapper resource="com/itheima/mapper/UserMapper.xml"/>
            <!--Mapper代理方式-->
            <package name="com.itheima.mapper"/>
        </mappers>
        ```
    - Mybatis执行流程

        ![](/work/interview/java/120.png)

    - Mapper的配置文件
        - 代码

            ```xml
            <select id="selectById" resultType="user">
                select * from tb_user where id = #{id}
            </select>
            ```
        - 映射配置说明

            - **`<select>`**：定义查询操作的映射
            - **`id="selectById"`**：该查询语句的唯一标识符
            - **`resultType="user"`**：指定返回结果映射到的 Java 类型
            - **SQL 语句**：从 `tb_user` 表中根据 `id` 参数查询用户信息
            - **`#{id}`**：MyBatis 的参数占位符，会替换为实际的 id 值
        - MappedStatement对象

            ![](/work/interview/java/121.png)

2. Mybatis执行流程-回答

    1. 读取MyBatis配置文件:mybatis-config.xml加载运行环境和映射文件
    2. 构造会话工厂SqlSessionFactory
    3. 会话工厂创建SqlSession对象(包含了执行SQL语句的所有方法)
    4. 操作数据库的接口，Executor执行器，同时负责查询缓存的维护
    5. Executor接口的执行方法中有一个MappedStatement类型的参数，封装了映射信息
    6. 输入参数映射
    7. 输出结果映射

3. 面试现场

    - 面试官： MyBatis执行流程？
    - 候选人：MyBatis的执行流程如下：
        1. 读取MyBatis配置文件mybatis-config.xml。
        2. 构造会话工厂SqlSessionFactory。
        3. 会话工厂创建SqlSession对象。
        4. 操作数据库的接口，Executor执行器。
        5. Executor执行方法中的MappedStatement参数。
        6. 输入参数映射。
        7. 输出结果映射。

### 3.2.2 Mybatis是否支持延迟加载


1. Mybatis是否支持延迟加载-讲解

    Mybatis支持延迟加载，但默认没有开启

    ![](/work/interview/java/122.png)

    - 方法1:UserMapper修改关联查询

        ```xml{13-16}
        <?xml version="1.0" encoding="UTF-8" ?>
        <!DOCTYPE mapper
                PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
                "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
        <mapper namespace="com.itheima.mapper.UserMapper">

            <resultMap id="userResultMap" type="user" autoMapping="true">
                <id property="id" column="id"></id>
                <result property="username" column="username"></result>
                <result property="password" column="password"></result>
                <result property="gender" column="gender"></result>
                <result property="addr" column="addr"></result>
                <collection property="ordersList" ofType="order"
                        select="com.itheima.mapper.OrderMapper.selectById"
                        column="id" fetchType="lazy">
                </collection>
            </resultMap>
            <select id="selectById" resultMap="userResultMap">
                select *
                from tb_user
                where id = #{id}
            </select>
        </mapper>
        ```
    - 方法2：全局配置 mybatis-config.xml

        ```xml
        <settings>
            <setting name="lazyLoadingEnabled" value = "true" />
        </settings>
        ```
    - 方法调用

        ```java
        @Test
        public void testSelectById2() throws IOException {
            //1. 加载mybatis的核心配置文件，获取 SqlSessionFactory
            String resource = "mybatis-config.xml";
            InputStream inputStream = Resources.getResourceAsStream(resource);
            SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);

            //2. 获取SqlSession对象，用它来执行sql
            SqlSession sqlSession1 = sqlSessionFactory.openSession();

            //3. 执行sql
            //3.1 获取UserMapper接口的代理对象
            UserMapper userMapper1 = sqlSession1.getMapper(UserMapper.class);

            User user1 = userMapper1.selectById(6);
            System.out.println(user1);
            sqlSession1.close();

            SqlSession sqlSession2 = sqlSessionFactory.openSession();

            System.out.println("---------------------");
            UserMapper userMapper2 = sqlSession2.getMapper(UserMapper.class);
            User user2 = userMapper2.selectById(6);
            System.out.println(user2);

            //4.关闭资源
            sqlSession2.close();
        }
        ```

2. 延迟加载的原理

    1. 使用CGLIB创建目标对象的代理对象
    2. 当调用目标方法`user.getOrderlist()`时，进入拦截器invoke方法，发现`user.getOrderlist()`是nul值，执行sql查询order列表
    3. 把order查询上来，然后调用`user.setOrderlist(List<Order>orderlist)`，接着完成`user.getOrderlist()`方法的调用

    ![](/work/interview/java/123.png)

3. 面试回答

    1. Mybatis是否支持延迟加载?
        - 延迟加载的意思是:就是在需要用到数据时才进行加载，不需要用到数据时就不加载数据。
        - Mybatis支持一对一关联对象和一对多关联集合对象的延迟加载
        - 在Mybatis配置文件中，可以配置是否启用延迟加载`lazyLoadingEnabled=true|false`，默认是关闭的
    2. 延迟加载的底层原理知道吗?
        1. 使用CGLIB创建目标对象的代理对象
        2. 当调用目标方法时，进入拦截器invoke方法，发现目标方法是nul值，执行sql查询
        3. 获取数据以后，调用set方法设置属性值，再继续查询目标方法，就有值了

4. 面试现场

    - 面试官：Mybatis是否支持延迟加载？
    - 候选人：MyBatis支持延迟加载，即在需要用到数据时才加载。可以通过配置文件中的lazyLoadingEnabled配置启用或禁用延迟加载。

    - 面试官 延迟加载的底层原理知道吗？
    - 候选人：延迟加载的底层原理主要使用CGLIB动态代理实现：
        1. 使用CGLIB创建目标对象的代理对象。
        2. 调用目标方法时，如果发现是null值，则执行SQL查询。
        3. 获取数据后，设置属性值并继续查询目标方法。

### 3.2.3 Mybatis的一级缓存、二级缓存

1. Mybatis的一级、二级缓存用过吗?

    ![](/work/interview/java/124.png)

    - 本地缓存，基于PerpetualCache，本质是一个HashMap
    - 一级缓存:作用域是session级别
    - 二级缓存:作用域是namespace和mapper的作用域，不依赖于session

2. 一级缓存

    - 一级缓存:基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session，当Session进行flush或close之后，该Session中的所有Cache就将清空，默认打开一级缓存

    - 代码

        ```java{16-20}
        @Test
        public void testSelectById() throws IOException {
            //1. 加载mybatis的核心配置文件，获取 SqlSessionFactory
            String resource = "mybatis-config.xml";
            InputStream inputStream = Resources.getResourceAsStream(resource);
            SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);

            //2. 获取SqlSession对象，用它来执行sql
            SqlSession sqlSession = sqlSessionFactory.openSession();
            //3. 执行sql
            //3.1 获取UserMapper接口的代理对象
            UserMapper userMapper1 = sqlSession.getMapper(UserMapper.class);
            UserMapper userMapper2 = sqlSession.getMapper(UserMapper.class);

            User user = userMapper1.selectById(6); // 查询第一次
            System.out.println(user);

            System.out.println("---------------------");
            User user1 = userMapper2.selectById(6); // 查询第二次
            System.out.println(user1);

            //4.关闭资源
            sqlSession.close();
        }
        ```

    - 运行结果

        ![](/work/interview/java/125.png)

4. 二级缓存

    - 二级缓存：基于namespace和mapper的作用域起作用的，不是依赖于SQLsession，默认也是采用 PerpetualCache,HashMap 存储

    - 代码 

        ```java{16-20}
        @Test
        public void testSelectById() throws IOException {
            //1. 加载mybatis的核心配置文件，获取 SqlSessionFactory
            String resource = "mybatis-config.xml";
            InputStream inputStream = Resources.getResourceAsStream(resource);
            SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);

            //2. 获取SqlSession对象，用它来执行sql
            SqlSession sqlSession = sqlSessionFactory.openSession();
            //3. 执行sql
            //3.1 获取UserMapper接口的代理对象,查询后关闭
            UserMapper userMapper1 = sqlSession.getMapper(UserMapper.class);  
            User user = userMapper1.selectById(6); // 查询第一次
            System.out.println(user);
            sqlSession.close();

            //3.2 获取UserMapper接口的代理对象，查询后关闭
            System.out.println("---------------------");
            UserMapper userMapper2 = sqlSession.getMapper(UserMapper.class);
            User user1 = userMapper2.selectById(6); // 查询第二次
            System.out.println(user1);
            sqlSession.close();
        }
        ```
    - 二级缓存默认是关闭的(开启方式，两步)

        - 配置全局文件

            ```xml
            <!--  开启二级缓存 -->
            <setting name="cacheEnabled" value="true"/>
            ```
        - 映射文件

            使用`<cache/>`标签让当前mapper生效二级缓存

5. 面试回答

    1. Mybatis的一级、二级缓存用过吗?
        - 一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session，当Session进行flush或close之后，该Session中的所有Cache就将清空，默认打开一级缓存
        - 二级缓存是基于namespace和mapper的作用域起作用的，不是依赖于SQLsession，默认也是采用PerpetualCache，HashMap 存。需要单独开启，一个是核心配置，一个是mapper映射文件

    2. Mybatis的二级缓存什么时候会清理缓存中的数据
        
        当某一个作用域(一级缓存 Session/二级缓存Namespaces)的进行了`新增`、`修改`、`删除`操作后，默认该作用域下所有 select 中的缓存将被 clear。

6. 面试现场

    - 面试官 Mybatis的一级、二级缓存用过吗？
    - 候选人：MyBatis的一级缓存是基于PerpetualCache的HashMap本地缓存，作用域为Session，默认开启。二级缓存需要单独开启，作用域为Namespace或mapper，默认也是采用PerpetualCache，HashMap存储。

    - 面试官 Mybatis的二级缓存什么时候会清理缓存中的数据？
    - 候选人：当作用域（一级缓存Session/二级缓存Namespaces）进行了新增、修改、删除操作后，默认该作用域下所有select中的缓存将被清空